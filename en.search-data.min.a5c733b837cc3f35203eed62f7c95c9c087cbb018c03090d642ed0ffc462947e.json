[{"id":0,"href":"/en/co/def/","title":"Basic definitions","section":"Documents for CO","content":"include: co/def.h.\n#typedefs #Fixed-length integer type def.h defines the following 8 types of integers:\ntypedef int8_t int8; typedef int16_t int16; typedef int32_t int32; typedef int64_t int64; typedef uint8_t uint8; typedef uint16_t uint16; typedef uint32_t uint32; typedef uint64_t uint64; These types have the same length on different platforms, and there is no portability problem. Google Code Style recommends not to use built-in integer types such as short, long, long long, etc.\n#macros #Maximum and minimum values of integer types MAX_UINT8 MAX_UINT16 MAX_UINT32 MAX_UINT64 MAX_INT8 MAX_INT16 MAX_INT32 MAX_INT64 MIN_INT8 MIN_INT16 MIN_INT32 MIN_INT64 These macros respectively defines the maximum and minimum values of the 8 integer types.\n#DISALLOW_COPY_AND_ASSIGN This macro is used to disable copy constructor and assignment operations in C++ classes.\nExample class T { public: T(); DISALLOW_COPY_AND_ASSIGN(T); }; #__arch64, __arch32 __arch64 is defined as 1 on 64 bit platforms, __arch32 is defined as 1 on 32 bit platforms.\nExample #if __arch64 inline size_t murmur_hash(const void* s, size_t n) { return murmur_hash64(s, n, 0); } #else inline size_t murmur_hash(const void* s, size_t n) { return murmur_hash32(s, n, 0); } #endif #__forceinline __forceinline is a keyword in VS. Linux and mac platforms use the following macro simulation:\n#define __forceinline __attribute__((always_inline)) #__thread __thread is a keyword in gcc/clang to support TLS, the windows platform uses the following macro simulation:\n#define __thread __declspec(thread) Example // get id of the current thread __forceinline unsigned int gettid() { static __thread unsigned int id = 0; if (id != 0) return id; return id = __gettid(); } #unlikely This macro is used for branch prediction optimization. It only supports gcc/clang.\nExample // It is logically equivalent to if (v == 0) if (unlikey(v == 0)) { cout \u0026lt;\u0026lt; \u0026#34;v == 0\u0026#34; \u0026lt;\u0026lt; endl; } #fname and fnlen The __fname__ macro is used to get the filename component of __FILE__ at compile time. The __fnlen__ macro is used to get the length of __fname__ at compile time, \\0 not included.\nExample //test/xx.cc static_assert(__fname__[0] == \u0026#39;x\u0026#39;, \u0026#34;\u0026#34;); static_assert(__fnlen__ == 5, \u0026#34;\u0026#34;); "},{"id":1,"href":"/en/co/defer/","title":"defer","section":"Documents for CO","content":"include: co/defer.h.\n#defer defer is a macro provided by CO, which is similar to defer in golang.\n#include \u0026#34;co/defer.h\u0026#34; #include \u0026#34;co/time.h\u0026#34; #include \u0026#34;co/log.h\u0026#34; #include \u0026#34;co/json.h\u0026#34; void f(const Json\u0026amp; req, Json\u0026amp; res) { Timer t; LOG \u0026lt;\u0026lt; \u0026#34;req: \u0026#34; \u0026lt;\u0026lt; req; defer(LOG \u0026lt;\u0026lt; \u0026#34;res: \u0026#34; \u0026lt;\u0026lt; res \u0026lt;\u0026lt; \u0026#34;, time elapse: \u0026#34; \u0026lt;\u0026lt; t.us() \u0026lt;\u0026lt; \u0026#34;us\u0026#34;); // do something here } In the above example, the code in defer will be executed at the end of the function f, thus printing the output and time elapse of the function.\n"},{"id":2,"href":"/en/about/co/","title":"Introduction","section":"About","content":"#What is CO CO is an elegant and efficient C++ base library that supports Linux, Windows and Mac platforms. It implements a series of high-quality base components, such as go-style coroutine, coroutine-based network programming framework, command line parameter and config file parsing library, high-performance log library, unit testing framework, JSON library, etc.\nCO is an open source project on github under the MIT license. It contains code from some other projects, which may have different licenses, see LICENSE file for details.\n#History of CO Alvin(idealvin) has started to develop CO since 2013. The original purpose is to reduce third-party dependencies in C++ projects and improve the efficiency of C++ development. Beginning in 2015, Alvin introduced CO into industrial projects for use by himself and his colleagues, which greatly reduced the development cycle of C++ projects.\nAfter years of accumulation and precipitation, by 2019, Alvin implemented the coroutine mechanism in golang with C++ and provided a set of network programming framework based on coroutine. At the beginning of its birth, it was used in the development of embedded network programming and achieved immediate results.\nAs of 2021, CO coroutines have made considerable progress. At present, hooks are supported on Linux/Windows/Mac platforms, and coroutine lock, coroutine synchronization event, coroutine pool, and channel and waitgroup in golang have been implemented. Users can use CO to write C++ like golang.\n#Quick Start #Compiling It is recommended to install xmake and run the following command in the root directory of CO to build all sub-projects:\nxmake -a If you need to use http::Client, SSL or HTTPS features, you can use the following command to build:\nxmake f --with_libcurl=true --with_openssl=true xmake -a Xmake will automatically install libcurl and openssl from the network. Depending on the network, this process may be slow. xmake -a will build libco, gen, co/unitest and co/test. Users can run test programs in CO with the following commands:\nxmake r unitest xmake r flag xmake r log -cout xmake r co #Develop C++ projects with CO The simplest, you can directly include co/all.h and use all the features in CO. If you are worried about the compiling speed, you can also include only the header files that you need, such as including co/co.h, you can use co/flag, co/log and all features related to coroutines.\n#include \u0026#34;co/all.h\u0026#34; DEF_string(s, \u0026#34;nice\u0026#34;, \u0026#34;\u0026#34;); int main(int argc, char** argv) { flag::init(argc, argv); LOG \u0026lt;\u0026lt; FLG_s; return 0; } The above is a simple example. The first line of the main function is used to parse the command-line flags and the config file. Some components in CO use co/flag to define config items. Therefore, it is generally necessary to call flag::init() at the beginning of the main function for initialization.\nUsers can also use the macro DEF_main to define the main function:\n#include \u0026#34;co/all.h\u0026#34; DEF_string(s, \u0026#34;nice\u0026#34;, \u0026#34;\u0026#34;); DEF_main(argc, argv) { LOG \u0026lt;\u0026lt; FLG_s; return 0; } DEF_main has already called flag::init() internally, and users do not need to call it again. In addition, DEF_main makes code in the main function also run in coroutine, which is consistent with golang. Some coroutine-related components in CO must be used in coroutine. When CO is used to develop coroutine-based applications, it is recommended to define the main function with DEF_main.\n#Core features #co/flag co/flag is a simple and easy-to-use command line and config file parsing library. Some components in CO use it to define config items.\nco/flag provides a default value for each config item. Without config parameters, the program can run with the default config. Users can also pass in config parameters from command line or config file. When a config file is needed, users can run ./exe -mkconf to generate a config file.\n// xx.cc #include \u0026#34;co/flag.h\u0026#34; #include \u0026#34;co/cout.h\u0026#34; DEF_bool(x, false, \u0026#34;bool x\u0026#34;); DEF_bool(y, false, \u0026#34;bool y\u0026#34;); DEF_uint32(u32, 0, \u0026#34;...\u0026#34;); DEF_string(s, \u0026#34;hello world\u0026#34;, \u0026#34;string\u0026#34;); int main(int argc, char** argv) { flag::init(argc, argv); COUT \u0026lt;\u0026lt; \u0026#34;x: \u0026#34;\u0026lt;\u0026lt; FLG_x; COUT \u0026lt;\u0026lt; \u0026#34;y: \u0026#34;\u0026lt;\u0026lt; FLG_y; COUT \u0026lt;\u0026lt; \u0026#34;u32: \u0026#34;\u0026lt;\u0026lt; FLG_u32; COUT \u0026lt;\u0026lt; FLG_s \u0026lt;\u0026lt; \u0026#34;|\u0026#34; \u0026lt;\u0026lt; FLG_s.size(); return 0; } The above is an example of using co/flag. The macro at the beginning of DEF_ in the code defines 4 config items. Each config item is equivalent to a global variable. The variable name is FLG_ plus the config name. After the above code is compiled, it can be run as follows:\n./xx # Run with default configs ./xx -xy -s good # single letter named bool flags, can be set to true together ./xx -s \u0026#34;I\u0026#39;m ok\u0026#34; # string with spaces ./xx -u32 8k # Integers can have units: k,m,g,t,p, not case sensitive ./xx -mkconf # Automatically generate a config file: xx.conf ./xx xx.conf # run with a config file ./xx -config xx.conf # Same as above #co/log co/log is a high-performance local log library, some components in CO use it to print logs.\nco/log divides the log into five levels: debug, info, warning, error, and fatal. Printing a fatal level log will terminate the program. Users can print logs of different levels as follows:\nDLOG \u0026lt;\u0026lt; \u0026#34;hello \u0026#34;\u0026lt;\u0026lt; 23; // debug LOG \u0026lt;\u0026lt; \u0026#34;hello \u0026#34;\u0026lt;\u0026lt; 23; // info WLOG \u0026lt;\u0026lt; \u0026#34;hello \u0026#34;\u0026lt;\u0026lt; 23; // warning ELOG \u0026lt;\u0026lt; \u0026#34;hello \u0026#34;\u0026lt;\u0026lt; 23; // error FLOG \u0026lt;\u0026lt; \u0026#34;hello \u0026#34;\u0026lt;\u0026lt; 23; // fatal co/log also provides a series of CHECK macros, which can be regarded as an enhanced version of assert, and they will not be cleared in debug mode.\nvoid* p = malloc(32); CHECK(p != NULL) \u0026lt;\u0026lt; \u0026#34;malloc failed..\u0026#34;; CHECK_NE(p, NULL) \u0026lt;\u0026lt; \u0026#34;malloc failed..\u0026#34;; When the CHECK assertion fails, co/log will print the function call stack information, and then terminate the program.\nco/log is very fast. The following are some test results, for reference only:\nco/log vs glog (single thread)\nplatform google glog co/log win2012 HHD 1.6MB/s 180MB/s win10 SSD 3.7MB/s 560MB/s mac SSD 17MB/s 450MB/s linux SSD 54MB/s 1023MB/s co/log vs spdlog (Windows)\nthreads total logs co/log time(seconds) spdlog time(seconds) 1 1000000 0.103619 0.482525 2 1000000 0.202246 0.565262 4 1000000 0.330694 0.722709 8 1000000 0.386760 1.322471 co/log vs spdlog (Linux)\nthreads total logs co/log time(seconds) spdlog time(seconds) 1 1000000 0.096445 2.006087 2 1000000 0.142160 3.276006 4 1000000 0.181407 4.339714 8 1000000 0.303968 4.700860 #co/unitest co/unitest is a simple and easy-to-use unit test framework. Many components in CO use it to write unit test code, which guarantees the stability of CO.\n#include \u0026#34;co/unitest.h\u0026#34; #include \u0026#34;co/os.h\u0026#34; namespace test { DEF_test(os) { DEF_case(homedir) { EXPECT_NE(os::homedir(), \u0026#34;\u0026#34;); } DEF_case(cpunum) { EXPECT_GT(os::cpunum(), 0); } } } // namespace test The above is a simple example. The DEF_test macro defines a test unit, which is actually a function (a method in a class). The DEF_case macro defines test cases, and each test case is actually a code block. Multiple test units can be put in the same C++ project, the main function is simple as below:\n#include \u0026#34;co/unitest.h\u0026#34; int main(int argc, char** argv) { flag::init(argc, argv); unitest::run_all_tests(); return 0; } co/unitest contains the unit test code in CO. Users can run unitest with the following commands:\nxmake r unitest -a # Run all test cases xmake r unitest -os # Run test cases in the os unit #Coroutine CO has implemented a go-style coroutine, which has the following features:\nMulti-thread scheduling, the default number of threads is the number of system CPU cores. Shared stack, coroutines in the same thread share several stacks (the default size is 1MB), and the memory usage is low. Simple test on Linux shows that 10 millions of coroutines only take 2.8G of memory (for reference only). There is a flat relationship between coroutines, and new coroutines can be created from anywhere (including in coroutines). Support system API hook (Windows/Linux/Mac), you can directly use third-party network library in coroutine. Coroutineized socket API. Coroutine synchronization event co::Event. Coroutine lock co::Mutex. Coroutine pool co::Pool. channel co::Chan. waitgroup co::WaitGroup. #Create a coroutine go(ku); // void ku(); go(f, 7); // void f(int); go(\u0026amp;T::f, \u0026amp;o); // void T::f(); T o; go(\u0026amp;T::f, \u0026amp;o, 7); // void T::f(int); T o; go([](){ LOG \u0026lt;\u0026lt; \u0026#34;hello go\u0026#34;; }); The above is an example of creating coroutines with go(). go() is a function that accepts 1 to 3 parameters. The first parameter f is any callable object, as long as f(), (*f)(), f(p), (*f)(p), (o-\u0026gt;*f)() or (o-\u0026gt;*f)(p) can be called.\nThe coroutines created by go() will be evenly distributed to different scheduling threads. If users want some coroutines to run in the same thread, they can create coroutines in the following way:\nauto s = co::next_scheduler(); s-\u0026gt;go(f1); s-\u0026gt;go(f2); If users want to create coroutine in all scheduling threads, the following way can be used:\nauto\u0026amp; s = co::all_schedulers(); for (size_t i = 0; i \u0026lt;s.size(); ++i) { s[i]-\u0026gt;go(f); } #channel co::Chan, similar to the channel in golang, can be used to transfer data between coroutines.\n#include \u0026#34;co/co.h\u0026#34; DEF_main(argc, argv) { co::Chan\u0026lt;int\u0026gt; ch; go([ch]() { ch \u0026lt;\u0026lt; 7; }); int v = 0; ch \u0026gt;\u0026gt; v; LOG \u0026lt;\u0026lt; \u0026#34;v: \u0026#34;\u0026lt;\u0026lt; v; return 0; } The read and write operations of channel must be performed in coroutine, so the main function is defined with DEF_main in above code, so that code in the main function also runs in coroutine.\nThe channel object in the code is on the stack, while CO uses a shared stack implementation. Data on the stack of one coroutine may be overwritten by other coroutines. Generally, we cann\u0026rsquo;t share data on stack between coroutines. Therefore, we capture by value in the lambda to copy the channel and pass it to the newly created coroutine. The copy operation just increases the internal reference count by 1 and will not affect the performance.\nWhen creating a channel, we can add a timeout as follows:\nco::Chan\u0026lt;int\u0026gt; ch(8, 1000); After read or write operation, we can call co::timeout() to determine whether it has timed out. This method is simpler than the select-based implementation in golang.\nThe channel in CO is implemented based on memory copy. The data type passed can be a built-in type, a pointer type, or a structure type with simple memory copy semantics for the copy operation. Like std::string or container types in STL, the copy operation is not a simple memory copy, and generally cannot be passed directly in channel. For details, see Document of co::Chan.\n#waitgroup co::WaitGroup, similar to sync.WaitGroup in golang, can be used to wait for the exit of coroutines or threads.\n#include \u0026#34;co/co.h\u0026#34; DEF_main(argc, argv) { FLG_cout = true; co::WaitGroup wg; wg.add(8); for (int i = 0; i \u0026lt;8; ++i) { go([wg]() { LOG \u0026lt;\u0026lt; \u0026#34;co: \u0026#34;\u0026lt;\u0026lt; co::coroutine_id(); wg.done(); }); } wg.wait(); return 0; } #network programming CO provides a set of coroutineized socket APIs, most of them are consistent with the native socket APIs in form. In addition, CO has also implemented higher-level network programming components, including TCP, HTTP and RPC framework based on JSON, they are IPv6-compatible and support SSL at the same time, which is more convenient than socket APIs. Here is just a brief demonstration of the usage of HTTP, and the rest can be viewed in the documents.\nStatic web server\n#include \u0026#34;co/flag.h\u0026#34; #include \u0026#34;co/http.h\u0026#34; DEF_string(d, \u0026#34;.\u0026#34;, \u0026#34;root dir\u0026#34;); // Specify the root directory of the web server int main(int argc, char** argv) { flag::init(argc, argv); so::easy(FLG_d.c_str()); // mum never have to worry again return 0; } HTTP server\nhttp::Server serv; serv.on_req( [](const http::Req\u0026amp; req, http::Res\u0026amp; res) { if (req.is_method_get()) { if (req.url() == \u0026#34;/hello\u0026#34;) { res.set_status(200); res.set_body(\u0026#34;hello world\u0026#34;); } else { res.set_status(404); } } else { res.set_status(405); // method not allowed } } ); serv.start(\u0026#34;0.0.0.0\u0026#34;, 80); // http serv.start(\u0026#34;0.0.0.0\u0026#34;, 443, \u0026#34;privkey.pem\u0026#34;, \u0026#34;certificate.pem\u0026#34;); // https HTTP client\nvoid f() { http::Client c(\u0026#34;https://github.com\u0026#34;); c.get(\u0026#34;/\u0026#34;); LOG \u0026lt;\u0026lt; \u0026#34;response code: \u0026#34;\u0026lt;\u0026lt; c.response_code(); LOG \u0026lt;\u0026lt; \u0026#34;body size: \u0026#34;\u0026lt;\u0026lt; c.body_size(); LOG \u0026lt;\u0026lt; \u0026#34;Content-Length: \u0026#34;\u0026lt;\u0026lt; c.header(\u0026#34;Content-Length\u0026#34;); LOG \u0026lt;\u0026lt; c.header(); c.post(\u0026#34;/hello\u0026#34;, \u0026#34;data xxx\u0026#34;); LOG \u0026lt;\u0026lt; \u0026#34;response code: \u0026#34;\u0026lt;\u0026lt; c.response_code(); } go(f); "},{"id":3,"href":"/en/co/atomic/","title":"Atomic Operations","section":"Documents for CO","content":"include: co/atomic.h.\n#Memory Order Since v3.0, co has added a support for memory order. The six memory orders in co are defined as follows:\nenum memory_order_t { mo_relaxed, mo_consume, mo_acquire, mo_release, mo_acq_rel, mo_seq_cst, }; The default memory order of atomic operations in co is mo_seq_cst.\n#APIs removed since v3.0 atomic_get, use atomic_load instead. atomic_set, use atomic_store instead. atomic_reset, use atomic_store(\u0026amp;x, 0) instead. #load \u0026amp; store #atomic_load template\u0026lt;typename T\u0026gt; inline T atomic_load(const T* p, memory_order_t mo = mo_seq_cst); This function gets the value of the variable pointed to by p, T is any built-in type (including pointer type) with a length of 1, 2, 4, 8 bytes.\nmo can be any of mo_relaxed, mo_consume, mo_acquire, mo_seq_cst.\nExample\nint i = 7; int r = atomic_load(\u0026amp;i); // r = 7 int x = atomic_load(\u0026amp;i, mo_relaxed); #atomic_store template\u0026lt;typename T, typename V\u0026gt; inline void atomic_store(T* p, V v, memory_order_t mo = mo_seq_cst); This function sets the value pointed to by p to v, T is any built-in type (including pointer type) with a length of 1, 2, 4, 8 bytes, and V is any type that can be converted to type of T.\nmo can be any of mo_relaxed, mo_release, mo_seq_cst.\nExample\nint i = 7; atomic_store(\u0026amp;i, 3); // i -\u0026gt; 3 atomic_store(\u0026amp;i, 3, mo_release); #Swap operations #atomic_swap template\u0026lt;typename T, typename V\u0026gt; inline T atomic_swap(T* p, V v, memory_order_t mo = mo_seq_cst); Atomic swap operation, T is any built-in type (including pointer type) with a length of 1, 2, 4, 8 bytes, and V is any type that can be converted to type of T.\nThis function exchanges the value pointed to by p and v, and returns the value before the exchange.\nmo can be any type.\nExample\nbool b = false; int i = 0; void* p = 0; bool x = atomic_swap(\u0026amp;b, true); // b -\u0026gt; true, x = false int r = atomic_swap(\u0026amp;i, 1); // i -\u0026gt; 1, r = 0 void* q = atomic_swap(\u0026amp;p, (void*)8); // p -\u0026gt; 8, q = 0 #atomic_cas template\u0026lt;typename T, typename O, typename V\u0026gt; inline T atomic_cas( T* p, O o, V v, memory_order_t smo = mo_seq_cst, memory_order_t fmo = mo_seq_cst ); template \u0026lt;typename T, typename O, typename V\u0026gt; inline T atomic_compare_swap( T* p, O o, V v, memory_order_t smo = mo_seq_cst, memory_order_t fmo = mo_seq_cst ); Atomic swap operation, T is any built-in type (including pointer type) with a length of 1, 2, 4, 8 bytes, O and V are any types that can be converted to type of T.\nThis function exchanges with v only when the value pointed to by p is equal to o.\nThis function returns the value before the exchange operation.\nExample\nbool b = false; int i = 0; void* p = 0; bool x = atomic_cas(\u0026amp;b, false, true); // b -\u0026gt; true, x = false int r = atomic_cas(\u0026amp;i, 1, 2); // No swap, i remains unchanged, r = 0 void* q = atomic_cas(\u0026amp;p, 0, (void*)8); // p -\u0026gt; 8, q = 0 #atomic_bool_cas template\u0026lt;typename T, typename O, typename V\u0026gt; inline bool atomic_bool_cas( T* p, O o, V v, memory_order_t smo = mo_seq_cst, memory_order_t fmo = mo_seq_cst ); Like the atomic_cas, but returns true if the swap operation was successful, otherwise returns false. #Arithmetic operations #atomic_inc template\u0026lt;typename T\u0026gt; inline T atomic_inc(T* p, memory_order_t mo = mo_seq_cst); Atomic increment, T is any integer type with a length of 1, 2, 4, 8 bytes, and the parameter p is a pointer of type T.\nThis function performs an increment operation on the integer pointed to by p and returns the result after increment.\nExample\nint i = 0; uint64 u = 0; int r = atomic_inc(\u0026amp;i); // i -\u0026gt; 1, r = 1 uint64 x = atomic_inc(\u0026amp;u); // u -\u0026gt; 1, x = 1 #atomic_fetch_inc template\u0026lt;typename T\u0026gt; inline T atomic_fetch_inc(T* p, memory_order_t mo = mo_seq_cst); The same as atomic_inc, but returns the value before increment.\nExample\nint i = 0; uint64 u = 0; int r = atomic_fetch_inc(\u0026amp;i); // i -\u0026gt; 1, r = 0 uint64 x = atomic_fetch_inc(\u0026amp;u); // u -\u0026gt; 1, x = 0 #atomic_dec template\u0026lt;typename T\u0026gt; inline T atomic_dec(T* p, memory_order_t mo = mo_seq_cst); Atomic decrement, T is any integer type with a length of 1, 2, 4, 8 bytes, and the parameter p is a pointer of type T.\nThis function decrements the integer pointed to by p and returns the decremented result.\nExample\nint i = 1; uint64 u = 1; int r = atomic_dec(\u0026amp;i); // i -\u0026gt; 0, r = 0 uint64 x = atomic_dec(\u0026amp;u); // u -\u0026gt; 0, x = 0 #atomic_fetch_dec template\u0026lt;typename T\u0026gt; inline T atomic_fetch_dec(T* p, memory_order_t mo = mo_seq_cst); The same as atomic_dec, but returns the value before decrement.\nExample\nint i = 1; uint64 u = 1; int r = atomic_fetch_dec(\u0026amp;i); // i -\u0026gt; 0, r = 1 uint64 x = atomic_fetch_dec(\u0026amp;u); // u -\u0026gt; 0, x = 1 #atomic_add template\u0026lt;typename T, typename V\u0026gt; inline T atomic_add(T* p, V v, memory_order_t mo = mo_seq_cst); Atomic addition, T is any integer type with a length of 1, 2, 4, 8 bytes, V is any integer type, and the parameter p is a pointer of type T.\nThis function adds the value v to the integer pointed to by p, and returns the result after adding v.\nExample\nint i = 0; uint64 u = 0; int r = atomic_add(\u0026amp;i, 1); // i -\u0026gt; 1, r = 1 uint64 x = atomic_add(\u0026amp;u, 1); // u -\u0026gt; 1, x = 1 #atomic_fetch_add template\u0026lt;typename T, typename V\u0026gt; inline T atomic_fetch_add(T* p, V v, memory_order_t mo = mo_seq_cst); The same as atomic_add, but returns the value before adding v.\nExample\nint i = 0; uint64 u = 0; int r = atomic_fetch_add(\u0026amp;i, 1); // i -\u0026gt; 1, r = 0 uint64 x = atomic_fetch_add(\u0026amp;u, 1); // u -\u0026gt; 1, x = 0 #atomic_sub template\u0026lt;typename T, typename V\u0026gt; inline T atomic_sub(T* p, V v, memory_order_t mo = mo_seq_cst); Atomic subtraction, T is any integer type with a length of 1, 2, 4, 8 bytes, V is any integer type, and the parameter p is a pointer of type T.\nThis function subtracts value v from the integer pointed to by p, and returns the result of subtracting v.\nExample\nint i = 1; uint64 u = 1; int r = atomic_sub(\u0026amp;i, 1); // i -\u0026gt; 0, r = 0 uint64 x = atomic_sub(\u0026amp;u, 1); // u -\u0026gt; 0, x = 0 #atomic_fetch_sub template\u0026lt;typename T, typename V\u0026gt; inline T atomic_fetch_sub(T* p, V v, memory_order_t mo = mo_seq_cst); The same as atomic_sub, but returns the value before subtracting v.\nExample\nint i = 1; uint64 u = 1; int r = atomic_fetch_sub(\u0026amp;i, 1); // i -\u0026gt; 0, r = 1 uint64 x = atomic_fetch_sub(\u0026amp;u, 1); // u -\u0026gt; 0, x = 1 #Bit operation #atomic_or template\u0026lt;typename T, typename V\u0026gt; inline T atomic_or(T* p, V v, memory_order_t mo = mo_seq_cst); Atomic bitwise OR operation, T is any integer type with a length of 1, 2, 4, 8 bytes, V is any integer type, and the parameter p is a pointer of type T.\nThis function performs bitwise OR operation on the integer pointed to by p and v, and returns the result of the operation.\nExample\nint i = 5; uint64 u = 5; int r = atomic_or(\u0026amp;i, 3); // i |= 3, i -\u0026gt; 7, r = 7 uint64 x = atomic_or(\u0026amp;u, 3); // u |= 3, u -\u0026gt; 7, x = 7 #atomic_fetch_or template\u0026lt;typename T, typename V\u0026gt; inline T atomic_fetch_or(T* p, V v, memory_order_t mo = mo_seq_cst); The same as atomic_or, but returns the value before the bitwise OR operation.\nExample\nint i = 5; uint64 u = 5; int r = atomic_fetch_or(\u0026amp;i, 3); // i |= 3, i -\u0026gt; 7, r = 5 uint64 x = atomic_fetch_or(\u0026amp;u, 3); // u |= 3, u -\u0026gt; 7, x = 5 #atomic_and template\u0026lt;typename T, typename V\u0026gt; inline T atomic_and(T* p, V v, memory_order_t mo = mo_seq_cst); Atomic bitwise AND operation, T is any integer type with a length of 1, 2, 4, 8 bytes, V is any integer type, and the parameter p is a pointer of type T.\nThis function performs bitwise AND operation on the integer pointed to by p and v, and returns the result after the operation.\nExample\nint i = 5; uint64 u = 5; int r = atomic_and(\u0026amp;i, 3); // i \u0026amp;= 3, i -\u0026gt; 1, r = 1 uint64 x = atomic_and(\u0026amp;u, 3); // u \u0026amp;= 3, u -\u0026gt; 1, x = 1 #atomic_fetch_and template\u0026lt;typename T, typename V\u0026gt; inline T atomic_fetch_and(T* p, V v, memory_order_t mo = mo_seq_cst); The same as atomic_and, but returns the value before the bitwise AND operation.\nExample\nint i = 5; uint64 u = 5; int r = atomic_fetch_and(\u0026amp;i, 3); // i \u0026amp;= 3, i -\u0026gt; 1, r = 5 uint64 x = atomic_fetch_and(\u0026amp;u, 3); // u \u0026amp;= 3, u -\u0026gt; 1, x = 5 #atomic_xor template\u0026lt;typename T, typename V\u0026gt; inline T atomic_xor(T* p, V v, memory_order_t mo = mo_seq_cst); Atomic bitwise XOR operation, T is any integer type with a length of 1, 2, 4, 8 bytes, V is any integer type, and the parameter p is a pointer of type T.\nThis function performs a bitwise XOR operation on the integer pointed to by p and v, and returns the result of the operation.\nExample\nint i = 5; uint64 u = 5; int r = atomic_xor(\u0026amp;i, 3); // i ^= 3, i -\u0026gt; 6, r = 6 uint64 x = atomic_xor(\u0026amp;u, 3); // u ^= 3, u -\u0026gt; 6, x = 6 #atomic_fetch_xor template\u0026lt;typename T, typename V\u0026gt; inline T atomic_fetch_xor(T* p, V v, memory_order_t mo = mo_seq_cst); The same as atomic_xor, but returns the value before the bitwise XOR operation.\nExample\nint i = 5; uint64 u = 5; int r = atomic_fetch_xor(\u0026amp;i, 3); // i ^= 3, i -\u0026gt; 6, r = 5 uint64 x = atomic_fetch_xor(\u0026amp;u, 3); // u ^= 3, u -\u0026gt; 6, x = 5 "},{"id":4,"href":"/en/about/contact/","title":"Contact","section":"About","content":"Contact\nEmail: idealvin@qq.com github: https://github.com/idealvin/co gitee: https://gitee.com/idealvin/co zhihu: idealvin "},{"id":5,"href":"/en/co/fastring/","title":"fastring","section":"Documents for CO","content":"include: co/fastring.h.\n#fastring fastring is the string type in co. It implements most of the methods in std::string and also provides some methods that std::string does not support.\n#fastring::fastring 1. fastring() noexcept; 2. explicit fastring(size_t cap); 3. fastring(const void* s, size_t n); 4. fastring(const char* s); 5. fastring(const std::string\u0026amp; s); 6. fastring(size_t n, char c); 7. fastring(char c, size_t n); 8. fastring(const fastring\u0026amp; s); 9. fastring(fastring\u0026amp;\u0026amp; s) noexcept; The first is the default constructor, which creates an empty fastring without allocating any memory.\nThe second constructor also creates an empty fastring, but uses the parameter cap to specify the initial capacity.\nThe third constructor creates a fastring from the given byte sequence, and the parameter n is the sequence length.\nThe fourth constructor creates a fastring from a null-terminated string.\nThe fifth constructor creates a fastring from std::string.\nThe sixth and seventh constructors initialize fastring to a string of n characters c.\nThe eighth is the copy constructor, which will copy the internal memory.\nThe ninth one is the move constructor, which does not copy the memory.\nExample\nfastring s; // empty string, no memory allocation fastring s(32); // empty string, pre-allocated memory (capacity is 32) fastring s(\u0026#34;hello\u0026#34;); // initialize s to \u0026#34;hello\u0026#34; fastring s(\u0026#34;hello\u0026#34;, 3); // initialize s to \u0026#34;hel\u0026#34; fastring s(88,\u0026#39;x\u0026#39;); // initialize s to 88 \u0026#39;x\u0026#39; fastring s(\u0026#39;x\u0026#39;, 88); // initialize s to 88 \u0026#39;x\u0026#39; fastring t(s); // copy construction fastring x(std::move(s)); // Move construction, s itself becomes an empty string #fastring::operator= fastring\u0026amp; operator=(const char* s); fastring\u0026amp; operator=(const std::string\u0026amp; s); fastring\u0026amp; operator=(const fastring\u0026amp; s); fastring\u0026amp; operator=(fastring\u0026amp;\u0026amp; s) noexcept; Assign value of a string to fastring.\nExample\nfastring s; fastring t; s = \u0026#34;hello\u0026#34;; // s -\u0026gt; \u0026#34;hello\u0026#34; s = s; // nothing will be done s = s.c_str() + 2; // s -\u0026gt; \u0026#34;llo\u0026#34; s = std::string(\u0026#34;x\u0026#34;); // s -\u0026gt; \u0026#34;x\u0026#34; t = s; // t -\u0026gt; \u0026#34;x\u0026#34; t = std::move(s); // t -\u0026gt; \u0026#34;x\u0026#34;, s -\u0026gt; \u0026#34;\u0026#34; #——————————— #fastring::back char\u0026amp; back() const; This method returns a reference to the last character in fastring.\nIf fastring is empty, calling this method will cause undefined behavior.\nExample\nfastring s(\u0026#34;hello\u0026#34;); char c = s.back(); // c =\u0026#39;o\u0026#39; s.back() =\u0026#39;x\u0026#39;; // s -\u0026gt; \u0026#34;hellx\u0026#34; #fastring::front char\u0026amp; front() const; This method returns the reference of the first character in fastring. If fastring is empty, calling this method will cause undefined behavior. Example fastring s(\u0026#34;hello\u0026#34;); char c = s.front(); // c =\u0026#39;h\u0026#39; s.front() =\u0026#39;x\u0026#39;; // s -\u0026gt; \u0026#34;xello\u0026#34; #fastring::operator[] char\u0026amp; operator[](size_t n) const; This method returns the reference of the nth character in fastring.\nIf n is out of a reasonable range, calling this method will cause undefined behavior.\nExample\nfastring s(\u0026#34;hello\u0026#34;); char c = s[1]; // c =\u0026#39;e\u0026#39; s[1] =\u0026#39;x\u0026#39;; // s -\u0026gt; \u0026#34;hxllo\u0026#34; #——————————— #fastring::capacity size_t capacity() const; This method returns the capacity of fastring. #fastring::c_str const char* c_str() const; This method gets the equivalent C string. This method adds a \u0026lsquo;\\0\u0026rsquo; to the end of fastring, it will not change the size and content of fastring, but it may cause internal reallocation of memory. #fastring::data const char* data() const; This method is similar to c_str(), but it does not guarantee that the string ends with \u0026lsquo;\\0\u0026rsquo;. #fastring::empty bool empty() const; This method determines whether fastring is empty. #fastring::size size_t size() const; This method returns the length of fastring. #fastring::substr fastring substr(size_t pos) const; fastring substr(size_t pos, size_t len) const; The first version returns the substring starting at position pos.\nThe second version returns a substring of length len starting at position pos.\nExample\nfastring s(\u0026#34;hello\u0026#34;); s.substr(2); // \u0026#34;llo\u0026#34; s.substr(2, 2); // \u0026#34;ll\u0026#34; #——————————— #fastring::append 1. fastring\u0026amp; append(const void* s, size_t n); 2. fastring\u0026amp; append(const char* s); 3. fastring\u0026amp; append(const fastring\u0026amp; s); 4. fastring\u0026amp; append(const std::string\u0026amp; s); 5. fastring\u0026amp; append(size_t n, char c); 6. fastring\u0026amp; append(char c, size_t n); 7. fastring\u0026amp; append(char c); 8. fastring\u0026amp; append(signed char c); 9. fastring\u0026amp; append(unsigned char c); The first version appends a byte sequence, and n is the sequence length.\nThe second version appends a string ending with \u0026lsquo;\\0\u0026rsquo;, and s can be part of fastring that performs the append operation.\nThe third version appends a fastring, and s can be the fastring itself that performs the append operation.\nThe fourth version appends a std::string.\nThe 5th and 6th versions appends n characters c.\nThe 7th to 9th version appends a single character c.\nThis method returns a fastring reference, multiple append operations can be written to one line.\nExample\nfastring s; s.append(\u0026#39;c\u0026#39;); // s -\u0026gt; \u0026#34;c\u0026#34; s.append(2,\u0026#39;c\u0026#39;); // s -\u0026gt; \u0026#34;ccc\u0026#34; s.append(\u0026#39;c\u0026#39;, 2); // s -\u0026gt; \u0026#34;ccccc\u0026#34; s.clear(); s.append(\u0026#39;c\u0026#39;).append(2,\u0026#39;x\u0026#39;); // s -\u0026gt; \u0026#34;cxx\u0026#34; s.append(s.c_str() + 1); // s -\u0026gt; \u0026#34;cxxxx\u0026#34; s.append(s.data(), 3); // s -\u0026gt; \u0026#34;cxxxxcxx\u0026#34; #fastring::cat template\u0026lt;typename X, typename ...V\u0026gt; fastring\u0026amp; cat(X\u0026amp;\u0026amp; x, V\u0026amp;\u0026amp; ... v); Added in v2.0.3. Concatenate any number of elements to fastring.\nThis method appends elements in the parameters to fastring one by one through operator\u0026lt;\u0026lt;.\nExample\nfastring s(\u0026#34;hello\u0026#34;); s.cat(\u0026#39;\u0026#39;, 23, \u0026#34;xx\u0026#34;, false); // s -\u0026gt; \u0026#34;hello 23xxfalse\u0026#34; #fastring::operator\u0026laquo; fastring\u0026amp; operator\u0026lt;\u0026lt;(const signed char* s); fastring\u0026amp; operator\u0026lt;\u0026lt;(const unsigned char* s); template\u0026lt;typename T\u0026gt; fastring\u0026amp; operator\u0026lt;\u0026lt;(T\u0026amp;\u0026amp; t); The first two versions are added in v2.0.3, which are equivalent to fastring\u0026amp; operator\u0026lt;\u0026lt;(const char* s).\nIn the third version, T can be any basic type (bool, char, int, double, void*, etc.), and string type (const char*, fastring, std::string).\nFor argument of string type, it can be the fastring itself or a part of it that performs the operator\u0026lt;\u0026lt; operation.\nExample\nfastring s; s \u0026lt;\u0026lt; false; // s -\u0026gt; \u0026#34;false\u0026#34; s \u0026lt;\u0026lt; s; // s -\u0026gt; \u0026#34;falsefalse\u0026#34; (append itself) s.clear(); s \u0026lt;\u0026lt; \u0026#34;hello \u0026#34; \u0026lt;\u0026lt; 23; // s -\u0026gt; \u0026#34;hello 23\u0026#34; s \u0026lt;\u0026lt; s.c_str() + 6; // s -\u0026gt; \u0026#34;hello 2323\u0026#34; (append part of s) s \u0026lt;\u0026lt; \u0026#39; \u0026#39;; // s -\u0026gt; \u0026#34;hello 2323 \u0026#34; #fastring::operator+= fastring\u0026amp; operator+=(const char* s); fastring\u0026amp; operator+=(const fastring\u0026amp; s); fastring\u0026amp; operator+=(const std::string\u0026amp; s); fastring\u0026amp; operator+=(char c); fastring\u0026amp; operator+=(signed char c); fastring\u0026amp; operator+=(unsigned char c); This method is equivalent to the append() method.\nExample\nfastring s; s += \u0026#39;c\u0026#39;; // s -\u0026gt; \u0026#34;c\u0026#34; s += \u0026#34;xx\u0026#34;; // s -\u0026gt; \u0026#34;cxx\u0026#34; #——————————— #fastring::find 1. size_t find(char c) const; 2. size_t find(char c, size_t pos) const; 3. size_t find(char c, size_t pos, size_t len) const; 4. size_t find(const char* s) const; 5. size_t find(const char* s, size_t pos) const; 1, searches for character c starting from position 0.\n2, searches for character c starting at position pos.\n3, added in v3.0, searches for character c in range [pos, pos + len).\n4, starts from position 0 to find the substring s, which is implemented internally based on strstr(), and does not apply to fastring containing \u0026lsquo;\\0\u0026rsquo;.\n5, like the 4th, but searchs from position pos.\nThis method returns the position of the character or substring when the search succeeds, otherwise it returns fastring::npos.\nExample\nfastring s(\u0026#34;hello\u0026#34;); s.find(\u0026#39;l\u0026#39;); // return 2 s.find(\u0026#39;l\u0026#39;, 3); // return 3 s.find(\u0026#34;ll\u0026#34;); // return 2 s.find(\u0026#34;ll\u0026#34;, 3); // return s.npos #fastring::rfind size_t rfind(char c) const; size_t rfind(const char* s) const; The first version searches for a single character in reverse. It is based on strrchr() and is not applicable to fastring containing \u0026lsquo;\\0\u0026rsquo;.\nThe second version searches for a substring in reverse.\nThis method returns the position of the character or substring when the search succeeds, otherwise it returns fastring::npos.\nExample\nfastring s(\u0026#34;hello\u0026#34;); s.rfind(\u0026#39;l\u0026#39;); // return 3 s.rfind(\u0026#34;ll\u0026#34;); // return 2 s.rfind(\u0026#34;le\u0026#34;); // return s.npos #fastring::find_first_of size_t find_first_of(const char* s) const; size_t find_first_of(const char* s, size_t pos) const; Find the first occurrence of a character in the specified character set.\nThe first version is searched from position 0.\nThe second version is searched from position pos.\nThis method is implemented based on strcspn() and is not suitable for fastring that contains \u0026lsquo;\\0\u0026rsquo;.\nThis method searches from the beginning, and when it encounters any character in s, it returns the position of the character, otherwise it returns fastring::npos.\nExample\nfastring s(\u0026#34;hello\u0026#34;); s.find_first_of(\u0026#34;def\u0026#34;); // return 1 s.find_first_of(\u0026#34;ol\u0026#34;, 3); // return 3 #fastring::find_first_not_of size_t find_first_not_of(const char* s) const; size_t find_first_not_of(const char* s, size_t pos) const; size_t find_first_not_of(char s, size_t pos=0); Find the first occurrence of a character not in the specified character set.\nThe first version is searched from position 0.\nThe second version is searched from position pos.\nThe third version of the character set is a single character, and s cannot be \u0026lsquo;\\0\u0026rsquo;.\nThis method is implemented based on strspn and is not suitable for fastring containing \u0026lsquo;\\0\u0026rsquo;.\nThis method searches from the beginning. When it encounters any character not in s, it returns the position of the character, otherwise it returns fastring::npos.\nExample\nfastring s(\u0026#34;hello\u0026#34;); s.find_first_not_of(\u0026#34;he\u0026#34;); // return 2 s.find_first_not_of(\u0026#34;he\u0026#34;, 3); // return 3 s.find_first_not_of(\u0026#39;x\u0026#39;); // return 0 #fastring::find_last_of size_t find_last_of(const char* s, size_t pos=npos) const; Find the last occurrence of a character in the specified character set.\nThe parameter pos in this method defaults to npos, which means searching from the end of fastring.\nThis method starts a reverse search from pos, and when it encounters any character in s, it returns the position of the character, otherwise it returns fastring::npos.\nExample\nfastring s(\u0026#34;hello\u0026#34;); s.find_last_of(\u0026#34;le\u0026#34;); // return 3 s.find_last_of(\u0026#34;le\u0026#34;, 1); // return 1 #fastring::find_last_not_of size_t find_last_not_of(const char* s, size_t pos=npos) const; size_t find_last_not_of(char s, size_t pos=npos) const; Find the last occurrence of a character not in the specified character set.\nThe parameter pos in this method defaults to npos, which means searching from the end of fastring.\nIn the second version, s is a single character, and s cannot be \u0026lsquo;\\0\u0026rsquo;.\nThis method starts a reverse search from pos, and when it encounters any character not in s, it returns the position of the character, otherwise it returns fastring::npos.\nExample\nfastring s(\u0026#34;hello\u0026#34;); s.find_last_not_of(\u0026#34;le\u0026#34;); // return 4 s.find_last_not_of(\u0026#34;le\u0026#34;, 3); // return 0 s.find_last_not_of(\u0026#39;o\u0026#39;); // return 3 #fastring::npos static const size_t npos = (size_t)-1; npos is the maximum value of the size_t type.\nWhen npos is used as the length, it means until the end of the string.\nWhen npos is used as the return value, it means not found.\nExample\nfastring s(\u0026#34;hello\u0026#34;); size_t r = s.find(\u0026#39;x\u0026#39;); r == s.npos; // true #——————————— #fastring::replace fastring\u0026amp; replace(const char* sub, const char* to, size_t maxreplace=0); This method replaces the substring sub in fastring with to. The parameter maxreplace specifies the maximum number of replacements, and 0 means unlimited.\nThis method returns the fastring reference, and multiple replace operations can be written in one line.\nExample\nfastring s(\u0026#34;hello\u0026#34;); s.replace(\u0026#34;ll\u0026#34;, \u0026#34;rr\u0026#34;); // s -\u0026gt; \u0026#34;herro\u0026#34; s.replace(\u0026#34;err\u0026#34;, \u0026#34;ok\u0026#34;).replace(\u0026#34;k\u0026#34;, \u0026#34;o\u0026#34;); // s -\u0026gt; \u0026#34;hooo\u0026#34; #fastring::strip fastring\u0026amp; strip(const char* s=\u0026#34; \\t\\r\\n\u0026#34;, char d=\u0026#39;b\u0026#39;); fastring\u0026amp; strip(char s, char d=\u0026#39;b\u0026#39;); Trim a string, removes specified characters on the left, right or both sides of fastring.\nThe parameter s is the characters to be trimmed, the parameter d represents the direction, \u0026rsquo;l\u0026rsquo; or \u0026lsquo;L\u0026rsquo; for left, \u0026lsquo;r\u0026rsquo; or \u0026lsquo;R\u0026rsquo; for right, and the default is \u0026lsquo;b\u0026rsquo; for both sides.\nThe first version removes blank characters on both sides of fastring by default.\nIn the second version, s is a single character, and s cannot be \u0026lsquo;\\0\u0026rsquo;.\nExample\nfastring s = \u0026#34;sos\\r\\n\u0026#34;; s.strip(); // s -\u0026gt; \u0026#34;sos\u0026#34; s.strip(\u0026#39;s\u0026#39;,\u0026#39;l\u0026#39;); // s -\u0026gt; \u0026#34;os\u0026#34; s.strip(\u0026#39;s\u0026#39;,\u0026#39;r\u0026#39;); // s -\u0026gt; \u0026#34;o\u0026#34; #fastring::tolower fastring\u0026amp; tolower(); This method converts fastring to lowercase and returns a reference to fastring. #fastring::toupper fastring\u0026amp; toupper(); This method converts fastring to uppercase and returns a reference to fastring. #fastring::lower fastring lower() const; This method returns the lowercase form of fastring. #fastring::upper fastring upper() const; This method returns the uppercase form of fastring.\nExample\nfastring s(\u0026#34;Hello\u0026#34;); fastring x = s.lower(); // x = \u0026#34;hello\u0026#34;, s remains unchanged fastring y = s.upper(); // x = \u0026#34;HELLO\u0026#34;, s remains unchanged s.tolower(); // s -\u0026gt; \u0026#34;hello\u0026#34; s.toupper(); // s -\u0026gt; \u0026#34;HELLO\u0026#34; #——————————— #fastring::clear void clear(); This method only sets the size of fastring to 0, and the capacity remains unchanged. #fastring::ensure void ensure(size_t n); This method ensures that the remaining memory of fastring can hold at least n characters. #fastring::reserve void reserve(size_t n); This method ensures that the capacity of fastring is at least n. When n is less than the original capacity, the capacity remains unchanged. #fastring::reset void reset(); Added in v2.0.3. Clear fastring and free the memory. #fastring::resize void resize(size_t n); This method sets the size of fastring to n.\nWhen n is greater than the original size, this operation will expand size to n, but will not fill the expanded part with \u0026lsquo;\\0\u0026rsquo;.\nExample\nfastring s(\u0026#34;hello\u0026#34;); s.resize(3); // s -\u0026gt; \u0026#34;hel\u0026#34; s.resize(6); char c = s[5]; // c is an uncertain random value #fastring::safe_clear void safe_clear(); Like the clear(), but it will fill in the internal memory with zeros. #fastring::swap void swap(fastring\u0026amp; s) noexcept; void swap(fastring\u0026amp;\u0026amp; s) noexcept; This method exchanges the contents of two fastrings, only the data pointer, capacity, and size are exchanged internally.\nExample\nfastring s(\u0026#34;hello\u0026#34;); fastring x(\u0026#34;world\u0026#34;); s.swap(x); // s -\u0026gt; \u0026#34;world\u0026#34;, x -\u0026gt; \u0026#34;hello\u0026#34; #——————————— #fastring::starts_with bool starts_with(char s) const; bool starts_with(const char* s, size_t n) const; bool starts_with(const char* s) const; bool starts_with(const fastring\u0026amp; s) const; bool starts_with(const std::string\u0026amp; s) const; This method determines whether fastring starts with s, and s is a single character or a string. When s is an empty string, this method always returns true. #fastring::ends_with bool ends_with(char s) const; bool ends_with(const char* s, size_t n) const; bool ends_with(const char* s) const; bool ends_with(const fastring\u0026amp; s) const; bool ends_with(const std::string\u0026amp; s) const; This method determines whether fastring ends with s, and s is a single character or a string. When s is an empty string, this method always returns true. #fastring::match bool match(const char* pattern) const; Check whether fastring matches the pattern, * matches any string, and ? matches a single character.\nExample\nfastring s(\u0026#34;hello\u0026#34;); s.match(\u0026#34;he??o\u0026#34;); // true s.match(\u0026#34;h*o\u0026#34;); // true s.match(\u0026#34;he?o\u0026#34;); // false s.match(\u0026#34;*o\u0026#34;); // true s.match(\u0026#34;h*l?\u0026#34;); // true #fastring::lshift fastring\u0026amp; lshift(size_t n); This method shifts fastring to the left by n characters, which means removing the first n characters.\nExample\nfastring s(\u0026#34;hello\u0026#34;); s.lshift(2); // s -\u0026gt; \u0026#34;llo\u0026#34; s.lshift(8); // s -\u0026gt; \u0026#34;\u0026#34; #fastring::remove_tail fastring\u0026amp; remove_tail(const char* s, size_t n); fastring\u0026amp; remove_tail(const char* s); fastring\u0026amp; remove_tail(const fastring\u0026amp; s); fastring\u0026amp; remove_tail(const std::string\u0026amp; s); This method deletes the string s at the end of fastring if the fastring ends with s.\nExample\nfastring s(\u0026#34;hello.log\u0026#34;); s.remove_tail(\u0026#34;.log\u0026#34;); // s -\u0026gt; \u0026#34;hello\u0026#34; #fastring::shrink void shrink(); This method releases the extra memory in fastring.\nExample\nfastring s(\u0026#34;hello\u0026#34;); s.reserve(32); // capacity -\u0026gt; 32 s.shrink(); // capacity -\u0026gt; 6 #global functions #operator+ fastring operator+(const fastring\u0026amp; a, char b); fastring operator+(char a, const fastring\u0026amp; b); fastring operator+(const fastring\u0026amp; a, const fastring\u0026amp; b); fastring operator+(const fastring\u0026amp; a, const char* b); fastring operator+(const char* a, const fastring\u0026amp; b); fastring operator+(const fastring\u0026amp; a, const std::string\u0026amp; b); fastring operator+(const std::string\u0026amp; a, const fastring\u0026amp; b); At least one parameter of this method is fastring.\nExample\nfastring s; s = s + \u0026#39;^\u0026#39;; // s -\u0026gt; \u0026#34;^\u0026#34; s = \u0026#34;o\u0026#34; + s + \u0026#34;o\u0026#34;; // s -\u0026gt; \u0026#34;o^o\u0026#34; #operator== bool operator==(const fastring\u0026amp; a, const fastring\u0026amp; b); bool operator==(const fastring\u0026amp; a, const char* b); bool operator==(const char* a, const fastring\u0026amp; b); bool operator==(const fastring\u0026amp; a, const std::string\u0026amp; b); bool operator==(const std::string\u0026amp; a, const fastring\u0026amp; b); This method determines whether two strings are equal, at least one parameter is fastring. #operator!= bool operator!=(const fastring\u0026amp; a, const fastring\u0026amp; b); bool operator!=(const fastring\u0026amp; a, const char* b); bool operator!=(const char* a, const fastring\u0026amp; b); bool operator!=(const fastring\u0026amp; a, const std::string\u0026amp; b); bool operator!=(const std::string\u0026amp; a, const fastring\u0026amp; b); This method determines whether two strings are not equal, at least one parameter is fastring. #operator\u0026lt; bool operator\u0026lt;(const fastring\u0026amp; a, const fastring\u0026amp; b); bool operator\u0026lt;(const fastring\u0026amp; a, const char* b); bool operator\u0026lt;(const char* a, const fastring\u0026amp; b); bool operator\u0026lt;(const fastring\u0026amp; a, const std::string\u0026amp; b); bool operator\u0026lt;(const std::string\u0026amp; a, const fastring\u0026amp; b); This method determines whether the string a is less than b, and at least one parameter is fastring. #operator\u0026gt; bool operator\u0026gt;(const fastring\u0026amp; a, const fastring\u0026amp; b); bool operator\u0026gt;(const fastring\u0026amp; a, const char* b); bool operator\u0026gt;(const char* a, const fastring\u0026amp; b); bool operator\u0026gt;(const fastring\u0026amp; a, const std::string\u0026amp; b); bool operator\u0026gt;(const std::string\u0026amp; a, const fastring\u0026amp; b); This method determines whether the string a is greater than b, and at least one parameter is fastring. #operator\u0026lt;= bool operator\u0026lt;=(const fastring\u0026amp; a, const fastring\u0026amp; b); bool operator\u0026lt;=(const fastring\u0026amp; a, const char* b); bool operator\u0026lt;=(const char* a, const fastring\u0026amp; b); bool operator\u0026lt;=(const fastring\u0026amp; a, const std::string\u0026amp; b); bool operator\u0026lt;=(const std::string\u0026amp; a, const fastring\u0026amp; b); This method determines whether the string a is less than or equal to b. At least one parameter is fastring. #operator\u0026gt;= bool operator\u0026gt;=(const fastring\u0026amp; a, const fastring\u0026amp; b); bool operator\u0026gt;=(const fastring\u0026amp; a, const char* b); bool operator\u0026gt;=(const char* a, const fastring\u0026amp; b); bool operator\u0026gt;=(const fastring\u0026amp; a, const std::string\u0026amp; b); bool operator\u0026gt;=(const std::string\u0026amp; a, const fastring\u0026amp; b); This method determines whether the string a is greater than or equal to b, and at least one parameter is fastring.\nExample\nfastring s(\u0026#34;hello\u0026#34;); s == \u0026#34;hello\u0026#34;; // true s != \u0026#34;hello\u0026#34;; // false s \u0026gt; \u0026#34;aa\u0026#34;; // true s \u0026lt; \u0026#34;xx\u0026#34;; // true s \u0026gt;= \u0026#34;he\u0026#34;; // true s \u0026lt;= \u0026#34;he\u0026#34;; // false #operator\u0026laquo; std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const fastring\u0026amp; s); Example fastring s(\u0026#34;xx\u0026#34;); std::cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; std::endl; "},{"id":6,"href":"/en/co/fastream/","title":"fastream","section":"Documents for CO","content":"include: co/fastream.h.\n#fastream fastream is used to replace std::ostringstream in the C++ standard library. The performance of std::ostringstream is poor which may be several times slower than snprintf, and fastream is about 10~30 times faster than snprintf on different platforms.\n#fastream::fastream fastream() noexcept; explicit fastream(size_t cap); fastream(fastream\u0026amp;\u0026amp; s) noexcept; The first one is the default constructor, which creates an empty fastream object without any memory allocation.\nThe second constructor uses the parameter cap to specify the initial capacity of fastream.\nThe third is the move constructor.\nExample\nfastream s; // fastream with empty status, no memory allocated fastream s(1024); // Pre-allocate 1k memory fastream x(std::move(s); // move constructor, s becomes an empty object #fastream::operator= fastream\u0026amp; operator=(fastream\u0026amp;\u0026amp; s) noexcept; Move assignment, the content of s is transferred to fastream, and s itself becomes an empty object.\nExample\nfastream s(32); fastream x; x = std::move(s); // x capacity -\u0026gt; 32, s -\u0026gt; empty #——————————— #fastream::back char\u0026amp; back() const; This method returns a reference to the last character in fastream.\nIf fastream is empty, calling this method will cause undefined behavior.\nExample\nfastream s; s.append(\u0026#34;hello\u0026#34;); char c = s.back(); // c =\u0026#39;o\u0026#39; s.back() =\u0026#39;x\u0026#39;; // s -\u0026gt; \u0026#34;hellx\u0026#34; #fastream::front char\u0026amp; front() const; This method returns a reference to the first character in fastream.\nIf fastream is empty, calling this method will cause undefined behavior.\nExample\nfastream s; s.append(\u0026#34;hello\u0026#34;); char c = s.front(); // c =\u0026#39;h\u0026#39; s.front() =\u0026#39;x\u0026#39;; // s -\u0026gt; \u0026#34;xello\u0026#34; #fastream::operator[] char\u0026amp; operator[](size_t n) const; This method returns the reference of the nth character in fastream.\nIf n is out of a reasonable range, calling this method will cause undefined behavior.\nExample\nfastream s; s.append(\u0026#34;hello\u0026#34;); char c = s[1]; // c =\u0026#39;e\u0026#39; s[1] =\u0026#39;x\u0026#39;; // s -\u0026gt; \u0026#34;hxllo\u0026#34; #——————————— #fastream::capacity size_t capacity() const; This method returns the capacity of fastream. #fastream::c_str const char* c_str() const; This method gets the equivalent C string. This method adds a \u0026lsquo;\\0\u0026rsquo; to the end of fastream, it will not change the size and content of fastream, but may cause internal reallocation of memory. #fastream::data const char* data() const; This method is similar to c_str(), but it does not guarantee that the string ends with \u0026lsquo;\\0\u0026rsquo;. #fastream::empty bool empty() const; This method determines whether fastream is empty. #fastream::size size_t size() const; This method returns the length of data in fastream. #fastream::str fastring str() const; This method returns a copy of fastream\u0026rsquo;s internal data in the form of fastring.\nExample\nfastream s; s.append(\u0026#34;hello\u0026#34;); fastring x = s.str(); // x = \u0026#34;hello\u0026#34; #——————————— #fastream::append 1. fastream\u0026amp; append(const void* s, size_t n); 2. fastream\u0026amp; append(const char* s); 3. fastream\u0026amp; append(const fastring\u0026amp; s); 4. fastream\u0026amp; append(const std::string\u0026amp; s); 5. fastream\u0026amp; append(const fastream\u0026amp; s); 6. fastream\u0026amp; append(size_t n, char c); 7. fastream\u0026amp; append(char c, size_t n); 8. fastream\u0026amp; append(char c); 9. fastream\u0026amp; append(signed char v) 10. fastream\u0026amp; append(unsigned char c); 11. fastream\u0026amp; append(short v); 12. fastream\u0026amp; append(unsigned short v); 13. fastream\u0026amp; append(int v); 14. fastream\u0026amp; append(unsigned int v); 15. fastream\u0026amp; append(long v); 16. fastream\u0026amp; append(unsigned long v); 17. fastream\u0026amp; append(long long v); 18. fastream\u0026amp; append(unsigned long long v); The first version appends a byte sequence of length n.\nThe second version appends a C string. Unlike fastring, fastream does not check whether the memory overlaps, and s cannot be part of the fastream performing the append operation.\nThe 3rd and 4th versions appends fastring and std::string respectively.\nThe 5th version appends fastream, s can be the fastream performing the append operation.\nThe 6th and 7th versions appends n characters c.\nThe 8th to 10th versions appends a single character c.\nThe 11th to 18th versions appends 8 built-in integer types in binary form, which is equivalent to append(\u0026amp;v, sizeof(v)).\nExample\nfastream s; int32 i = 7; char buf[8]; s.append(\u0026#34;xx\u0026#34;); // Append C string s.append(s); // append itself, s -\u0026gt; \u0026#34;xxxx\u0026#34; s.append(buf, 8); // Append 8 bytes s.append(\u0026#39;c\u0026#39;); // Append a single character s.append(100,\u0026#39;c\u0026#39;); // Append 100\u0026#39;c\u0026#39; s.append(\u0026#39;c\u0026#39;, 100); // append 100\u0026#39;c\u0026#39; s.append(\u0026amp;i, 4); // Append 4 bytes s.append(i); // Append 4 bytes, same as above s.append((int16)23); // Append 2 bytes // The following usage is wrong and unsafe s.append(s.c_str() + 1); #fastream::cat template\u0026lt;typename X, typename ...V\u0026gt; fastream\u0026amp; cat(X\u0026amp;\u0026amp; x, V\u0026amp;\u0026amp; ... v); Added in v2.0.3. Concatenate any number of elements to fastream.\nThis method appends elements in the parameters to fastream one by one through operator\u0026lt;\u0026lt;.\nExample\nfastream s; s \u0026lt;\u0026lt; \u0026#34;hello\u0026#34;; s.cat(\u0026#39;\u0026#39;, 23, \u0026#34;xx\u0026#34;, false); // s -\u0026gt; \u0026#34;hello 23xxfalse\u0026#34; #fastream::operator\u0026laquo; fastream\u0026amp; operator\u0026lt;\u0026lt;(const signed char* s); fastream\u0026amp; operator\u0026lt;\u0026lt;(const unsigned char* s); template\u0026lt;typename T\u0026gt; fastream\u0026amp; operator\u0026lt;\u0026lt;(T\u0026amp;\u0026amp; t); The first two versions are added in v2.0.3, which are equivalent to fastream\u0026amp; operator\u0026lt;\u0026lt;(const char* s).\nIn the third version, T can be any basic type (bool, char, int, double, void*, etc.), string type (const char*, fastring, std::string) or fastream.\nUnlike fastring, fastream does not perform memory security checks, operations like s \u0026lt;\u0026lt; s.c_str() + 3; are not safe.\nExample\nfastream s; s \u0026lt;\u0026lt; false; // s -\u0026gt; \u0026#34;false\u0026#34; s.clear(); s \u0026lt;\u0026lt; \u0026#34;hello \u0026#34;\u0026lt;\u0026lt; 23; // s -\u0026gt; \u0026#34;hello 23\u0026#34; s \u0026lt;\u0026lt; \u0026#39;\u0026#39;; // s -\u0026gt; \u0026#34;hello 23 \u0026#34; s \u0026lt;\u0026lt; s; // s -\u0026gt; \u0026#34;hello 23 hello 23 \u0026#34; #——————————— #fastream::clear void clear(); This method only sets the size of fastream to 0, and the capacity remains unchanged. #fastream::ensure void ensure(size_t n); This method ensures that the remaining memory of fastream can hold at least n characters. #fastream::reset void reset(); Added in v2.0.3. Clear fastream and free the memory. #fastream::reserve void reserve(size_t n); This method adjusts the capacity of fastream to ensure that the capacity is at least n. #fastream::resize void resize(size_t n); This method sets the size of fastream to n.\nWhen n is greater than the original size, this operation will expand size to n, but will not fill the expanded part with \u0026lsquo;\\0\u0026rsquo;.\nExample\nfastream s; s.append(\u0026#34;hello\u0026#34;); s.resize(3); // s -\u0026gt; \u0026#34;hel\u0026#34; s.resize(6); char c = s[5]; // c is an uncertain random value #fastream::safe_clear void safe_clear(); Like the clear(), but will fill the internal memory with zeros. #fastream::swap void swap(fastream\u0026amp; s) noexcept; void swap(fastream\u0026amp;\u0026amp; s) noexcept; This method exchanges the contents of two fastreams, only the internal pointer, capacity, and size are exchanged.\nExample\nfastream s(32); fastring x(64); s.swap(x); // s: cap -\u0026gt; 64, x: cap -\u0026gt; 32 #——————————— #Interoperability with fastring fastream and fastring are both inherited from fast::stream, the memory structure of them is exactly the same, so they can be easily converted to each other:\nfastream s; s.append(\u0026#34;Hello\u0026#34;); ((fastring\u0026amp;)s).tolower(); // s -\u0026gt; \u0026#34;hello\u0026#34; fastring x; void f(fastream\u0026amp;); f((fastream\u0026amp;)x); As mentioned earlier, the append operation of fastream will not check memory overlap. If necessary, it can be converted to fastring to perform the operation safely:\nfastream s; s.append(\u0026#34;hello\u0026#34;); ((fastring\u0026amp;)s).append(s.c_str() + 1); #Precision control of floating point numbers For floating-point numbers, the operator\u0026lt;\u0026lt; operators of fastream and fastring retain up to 6 decimal places by default. You can set the maximum number of decimal places through the maxdp() method or the co::maxdp operator:\nfastream s; s \u0026lt;\u0026lt; 3.14159; // \u0026#34;3.14159\u0026#34; s.clear(); s.maxdp(3) \u0026lt;\u0026lt; 3.14159; // \u0026#34;3.141\u0026#34; s.clear(); s \u0026lt;\u0026lt; co::maxdp(2) \u0026lt;\u0026lt; 3.14159; // \u0026#34;3.14\u0026#34; Since co/log is implemented based on fastream, the above method can also be used in logging:\ndouble x = 3.14159; LOG \u0026lt;\u0026lt; co::maxdp(3) \u0026lt;\u0026lt; x \u0026lt;\u0026lt; co::maxdp(2) \u0026lt;\u0026lt; x; maxdp is only valid in the current statement, and expires after the statement ends.\n"},{"id":7,"href":"/en/about/sponsor/","title":"Sponsor💕","section":"About","content":"#Sponsor CO is a personal project. If you are interested in sponsoring CO, you can contact with Alvin (idealvin@qq.com), we\u0026rsquo;ll display your logo, website and other information here, and also provide you with better technical services. Thank you very much🙏\nGithub Sponsor\n#Special sponsors CO is specially sponsored by the following companies, thank you very much!\n#Coffee If you like CO, you may also buy the author a cup of coffee, thanks🙏\nPaypal\nidealvin@qq.com\nWechat\nAlipay\n"},{"id":8,"href":"/en/co/str/","title":"String utilities","section":"Documents for CO","content":"include: co/str.h.\n#split, strip, replace, #str::split co::vector\u0026lt;fastring\u0026gt; split(const char* s, char c, uint32 n=0); co::vector\u0026lt;fastring\u0026gt; split(const fastring\u0026amp; s, char c, uint32 n=0); co::vector\u0026lt;fastring\u0026gt; split(const char* s, const char* c, uint32 n=0); co::vector\u0026lt;fastring\u0026gt; split(const fastring\u0026amp; s, const char* c, uint32 n=0); This function splits the string into several substrings, the original string remains unchanged, and returns the split result.\nParameter s is a C string or fastring, parameter c is the separator, parameter n is the maximum number of splits, 0 or -1 means unlimited.\nIn the fourth version, s cannot contain \u0026lsquo;\\0\u0026rsquo;, because the internal implementation uses strstr() to search for substrings.\nExample\nstr::split(\u0026#34;x y z\u0026#34;, \u0026#39;\u0026#39;); // -\u0026gt; [\u0026#34;x\u0026#34;, \u0026#34;y\u0026#34;, \u0026#34;z\u0026#34;] str::split(\u0026#34;|x|y|\u0026#34;,\u0026#39;|\u0026#39;); // -\u0026gt; [\u0026#34;\u0026#34;, \u0026#34;x\u0026#34;, \u0026#34;y\u0026#34;] str::split(\u0026#34;xooy\u0026#34;, \u0026#34;oo\u0026#34;); // -\u0026gt; [\u0026#34;x\u0026#34;, \u0026#34;y\u0026#34;] str::split(\u0026#34;xooy\u0026#34;,\u0026#39;o\u0026#39;); // -\u0026gt; [\u0026#34;x\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;y\u0026#34;] str::split(\u0026#34;xooy\u0026#34;,\u0026#39;o\u0026#39;, 1); // -\u0026gt; [\u0026#34;x\u0026#34;, \u0026#34;oy\u0026#34;] #str::strip fastring strip(const char* s, const char* c=\u0026#34; \\t\\r\\n\u0026#34;, char d=\u0026#39;b\u0026#39;); fastring strip(const fastring\u0026amp; s, const char* c=\u0026#34; \\t\\r\\n\u0026#34;, char d=\u0026#39;b\u0026#39;); fastring strip(const char* s, char c, char d =\u0026#39;b\u0026#39;); fastring strip(const fastring\u0026amp; s, char c, char d=\u0026#39;b\u0026#39;); fastring strip(const fastring\u0026amp; s, const fastring\u0026amp; c, char d=\u0026#39;b\u0026#39;); This function removes the specified characters on the left or right sides of the string, the original string remains unchanged, and the result after strip is returned.\nThe parameter s is a C string or fastring, the parameter c is the character set to be removed, the parameter d is the direction, \u0026rsquo;l\u0026rsquo; or \u0026lsquo;L\u0026rsquo; for left side, \u0026lsquo;r\u0026rsquo; or \u0026lsquo;R\u0026rsquo; for right side, and the default is \u0026lsquo;b\u0026rsquo; means both sides.\nThe first and second versions remove the blank characters on both sides of the string by default.\nIn the 3rd and 4th versions, c is a single character.\nExample\nstr::strip(\u0026#34; xx\\r\\n\u0026#34;); // -\u0026gt; \u0026#34;xx\u0026#34; str::strip(\u0026#34;abxxa\u0026#34;, \u0026#34;ab\u0026#34;); // -\u0026gt; \u0026#34;xx\u0026#34; str::strip(\u0026#34;abxxa\u0026#34;, \u0026#34;ab\u0026#34;,\u0026#39;l\u0026#39;); // -\u0026gt; \u0026#34;xxa\u0026#34; str::strip(\u0026#34;abxxa\u0026#34;, \u0026#34;ab\u0026#34;,\u0026#39;r\u0026#39;); // -\u0026gt; \u0026#34;abxx\u0026#34; #str::replace fastring replace(const char* s, const char* sub, const char* to, uint32 n=0); fastring replace(const fastring\u0026amp; s, const char* sub, const char* to, uint32 n=0); This function is used to replace substrings in the string, the original string remains unchanged, and the replaced result is returned.\nParameter s is a C string or fastring, substring sub in s will be replaced with to. Parameter n is the maximum number of replacements, 0 or -1 means unlimited.\nIn the second version, s cannot contain \u0026lsquo;\\0\u0026rsquo;, because the internal implementation uses strstr() to search for substrings.\nExample\nstr::replace(\u0026#34;xooxoox\u0026#34;, \u0026#34;oo\u0026#34;, \u0026#34;ee\u0026#34;); // -\u0026gt; \u0026#34;xeexeex\u0026#34; str::replace(\u0026#34;xooxoox\u0026#34;, \u0026#34;oo\u0026#34;, \u0026#34;ee\u0026#34;, 1); // -\u0026gt; \u0026#34;xeexoox\u0026#34; #str::cat template \u0026lt;typename ...X\u0026gt; inline fastring cat(X\u0026amp;\u0026amp; ... x); Added in v2.0.3. Concatenate any number of elements to make a string.\nThis function concatenates elements in the parameters to the string one by one through operator\u0026lt;\u0026lt;.\n示例\n// s -\u0026gt; \u0026#34;hello 23true\u0026#34; fastring s = str::cat(\u0026#34;hello\u0026#34;, \u0026#39; \u0026#39;, 23, true); #Convert string to built-in type #str::to_bool bool to_bool(const char* s); bool to_bool(const fastring\u0026amp; s); bool to_bool(const std::string\u0026amp; s); This function converts a string to bool type.\nWhen s is equal to \u0026ldquo;0\u0026rdquo; or \u0026ldquo;false\u0026rdquo;, false is returned; when s is equal to \u0026ldquo;1\u0026rdquo; or \u0026ldquo;true\u0026rdquo;, true is returned.\nIf the conversion is successful, the error code is 0. Otherwise, the error code is set to EINVAL, and false is returned. Call co::error() to get the error code\nExample\nbool b = str::to_bool(\u0026#34;true\u0026#34;); // x = true bool x = str::to_bool(\u0026#34;false\u0026#34;); // x = false #str::to_double double to_double(const char* s); double to_double(const fastring\u0026amp; s); double to_double(const std::string\u0026amp; s); This function converts a string to double type.\nIf the conversion is successful, the error code is 0. Otherwise, the error code is set to ERANGE or EINVAL, and 0 is returned. Call co::error() to get the error code.\nExample\ndouble x = str::to_double(\u0026#34;3.14\u0026#34;); // x = 3.14 #str::to_int int32 to_int32(const char* s); int32 to_int32(const fastring\u0026amp; s); int32 to_int32(const std::string\u0026amp; s); int64 to_int64(const char* s); int64 to_int64(const fastring\u0026amp; s); int64 to_int64(const std::string\u0026amp; s); uint32 to_uint32(const char* s); uint32 to_uint32(const fastring\u0026amp; s); uint32 to_uint32(const std::string\u0026amp; s); uint64 to_uint64(const char* s); uint64 to_uint64(const fastring\u0026amp; s); uint64 to_uint64(const std::string\u0026amp; s); These functions convert a string to integer types.\nThe parameter s can take an unit k, m, g, t, p at the end, which is not case sensitive.\nIf the conversion is successful, the error code is 0. Otherwise, the error code is set to ERANGE or EINVAL, and 0 is returned. Call co::error() to get the error code.\nExample\nint32 i32; int64 i64; uint32 u32; uint64 u64; i32 = str::to_int32(\u0026#34;-23\u0026#34;); // -23 u32 = str::to_uint32(\u0026#34;4k\u0026#34;); // 4096 i64 = str::to_int32(\u0026#34;8M\u0026#34;); // 8 \u0026lt;\u0026lt; 20 i64 = str::to_int64(\u0026#34;8T\u0026#34;); // 8ULL \u0026lt;\u0026lt; 40 u64 = str::to_int64(\u0026#34;1P\u0026#34;); // 1ULL \u0026lt;\u0026lt; 50 i32 = str::to_int32(\u0026#34;8g\u0026#34;); LOG \u0026lt;\u0026lt; (i32 == 0); LOG \u0026lt;\u0026lt; (errno == ERANGE); i32 = str::to_int32(\u0026#34;abx\u0026#34;); LOG \u0026lt;\u0026lt; (i32 == 0); LOG \u0026lt;\u0026lt; (errno == EINVAL); #Convert built-in types to string #str::from template\u0026lt;typename T\u0026gt; inline fastring from(T t); This function converts built-in types to a string.\nT can be any built-in type, such as bool, int, double, void*, etc.\nExample\nfastring s; s = str::from(true); // -\u0026gt; \u0026#34;true\u0026#34; s = str::from(23); // -\u0026gt; \u0026#34;23\u0026#34; s = str::from(3.14); // -\u0026gt; \u0026#34;3.14\u0026#34; #Convert STL container to debug string #str::dbg template\u0026lt;typename T\u0026gt; fastring dbg(const co::vector\u0026lt;T\u0026gt;\u0026amp; v); template\u0026lt;typename T\u0026gt; fastring dbg(const std::vector\u0026lt;T\u0026gt;\u0026amp; v); template\u0026lt;typename T\u0026gt; fastring dbg(const co::set\u0026lt;T\u0026gt;\u0026amp; v); template\u0026lt;typename T\u0026gt; fastring dbg(const std::set\u0026lt;T\u0026gt;\u0026amp; v); template\u0026lt;typename T\u0026gt; fastring dbg(const co::unordered_set\u0026lt;T\u0026gt;\u0026amp; v); template\u0026lt;typename T\u0026gt; fastring dbg(const std::unordered_set\u0026lt;T\u0026gt;\u0026amp; v); template\u0026lt;typename K, typename V\u0026gt; fastring dbg(const co::map\u0026lt;K, V\u0026gt;\u0026amp; v); template\u0026lt;typename K, typename V\u0026gt; fastring dbg(const std::map\u0026lt;K, V\u0026gt;\u0026amp; v); template\u0026lt;typename K, typename V\u0026gt; fastring dbg(const co::unordered_map\u0026lt;K, V\u0026gt;\u0026amp; v); template\u0026lt;typename K, typename V\u0026gt; fastring dbg(const std::unordered_map\u0026lt;K, V\u0026gt;\u0026amp; v); This function converts a container to a debug string, which is generally for printing logs.\nExample\nstd::vector\u0026lt;int\u0026gt; v {1, 2, 3 }; std::set\u0026lt;int\u0026gt; s {1, 2, 3 }; std::map\u0026lt;int, int\u0026gt; m {{1, 1}, {2, 2} }; str::dbg(v); // -\u0026gt; \u0026#34;[1,2,3]\u0026#34; str::dbg(s); // -\u0026gt; \u0026#34;{1,2,3}\u0026#34; str::dbg(m); // -\u0026gt; \u0026#34;{1:1,2:2} "},{"id":9,"href":"/en/co/flag/","title":"co/flag","section":"Documents for CO","content":"include: co/flag.h.\n#Basic concepts co/flag is a command line and config file parsing library similar to google gflags. Its principle is very simple, define global variables in code, then parse the command line parameters or config file when the program starts, and update the value of these global variables.\n#flag variable The global variable defined by macros in co/flag are called flag variable. For example, the following code defines a flag variable, the variable name is FLG_x.\nDEF_bool(x, false, \u0026#34;xxx\u0026#34;); // bool FLG_x = false; co/flag supports 7 types of flag variable:\nbool, int32, int64, uint32, uint64, double, string Every flag variable has a default value, and a new value can be passed to it from command-line or config file. Take the previously FLG_x as an example, we can use -x=true in command line, or x = true in the config file, to set a new value for it.\n#command line flag Command line parameters appear in the form of -x=y, where x is called a command line flag (hereinafter referred to as flag). The flag x in command line corresponds to the global variable FLG_x in the code, and -x=y in command line is equivalent to setting the value of FLG_x to y.\nco/flag is designed to be very flexible:\n-x=y can omit the preceding -, abbreviated as x=y.\n-x=y can also be written as -x y.\nx=y can be preceded by any number of -.\nFor bool type flags, -b=true can be abbreviated as -b.\nExample\n# b, i, s are all flags, xx is not a flag ./exe -b -i=32 -s=hello xx #APIs #flag::init co::vector\u0026lt;fastring\u0026gt; init(int argc, const char** argv); co::vector\u0026lt;fastring\u0026gt; init(int argc, char** argv); void init(const fastring\u0026amp; path); The first 2 init functions, parse the command line parameters and config file, and update value of the flag variables. It usually needs to be called once at the beginning of the main function. Generally speaking, it does the following steps:\nPreprocess the command line parameters, the value of FLG_config may be updated then. If FLG_config is not empty, parse the config file specified by it, and update value of the flag variables. Parse other command line parameters and update value of the flag variables. If FLG_mkconf is true, generate a config file and terminate the program. If FLG_daemon is true, run the program as a daemon (for Linux only). When any error occurs, print the error message and terminate the program immediately. If no error occurs, return the non-flag list. For example, when executing ./exe x y, this function will return [\u0026quot;x\u0026quot;, \u0026quot;y\u0026quot;]. The third init function, parses the config file and updates value of the flag variables. The parameter path is the path of the config file. When any error occurs, print the error message and terminate the program.\nExample\n#include \u0026#34;co/flag.h\u0026#34; int main(int argc, char** argv) { flag::init(argc, argv); } #flag::set_value fastring set_value(const fastring\u0026amp; name, const fastring\u0026amp; value) Added in v3.0. Set value of a flag variable, name is the flag name.\nThis function is not thread-safe and usually needs to be called at the beginning of the main function.\nExample\nDEF_bool(b, false, \u0026#34;\u0026#34;); DEF_int32(i, 0, \u0026#34;\u0026#34;); DEF_string(s, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;); flag::set_value(\u0026#34;b\u0026#34;, \u0026#34;true\u0026#34;); // FLG_b -\u0026gt; true flag::set_value(\u0026#34;i\u0026#34;, \u0026#34;23\u0026#34;); // FLG_i -\u0026gt; 23 flag::set_value(\u0026#34;s\u0026#34;, \u0026#34;xx\u0026#34;); // FLG_s -\u0026gt; \u0026#34;xx\u0026#34; #flag::alias bool alias(const char* name, const char* new_name); Added in v3.0. Add an alias to a flag, in command line or config file you can replace the original name with the alias.\nThis function is not thread safe and needs to be called before flag::init().\nExample\nDEF_bool(all, false, \u0026#34;\u0026#34;); int main(int argc, char** argv) { flag::alias(\u0026#34;all\u0026#34;, \u0026#34;a\u0026#34;); flag::init(argc, argv); } #Use flag variable in the code #Define a flag variable DEF_bool(name, value, help, ...) DEF_int32(name, value, help, ...) DEF_int64(name, value, help, ...) DEF_uint32(name, value, help, ...) DEF_uint64(name, value, help, ...) DEF_double(name, value, help, ...) DEF_string(name, value, help, ...) The above 7 macros are used to define 7 different types of flag variables.\nThe parameter name is the flag name, the corresponding global variable name is FLG_name, the parameter value is the default value, and the parameter help is comment for the flag.\nA flag variable is a global variable and generally should not be defined in the header file.\nThe name of the flag variable is unique, and we cannot define two flag variables with the same name.\nThe flag variable is generally defined outside the namespace, otherwise it may be not possible to use FLG_name to access the flag variable.\nExample\nDEF_bool(b, false, \u0026#34;comments\u0026#34;); // bool FLG_b = false; DEF_int32(i32, 32, \u0026#34;comments\u0026#34;); // int32 FLG_i32 = 32; DEF_int64(i64, 64, \u0026#34;comments\u0026#34;); // int64 FLG_i64 = 64; DEF_uint32(u32, 0, \u0026#34;comments\u0026#34;); // uint32 FLG_u32 = 0; DEF_uint64(u64, 0, \u0026#34;comments\u0026#34;); // uint64 FLG_u64 = 0; DEF_double(d, 2.0, \u0026#34;comments\u0026#34;); // double FLG_d = 2.0; DEF_string(s, \u0026#34;x\u0026#34;, \u0026#34;comments\u0026#34;); // fastring FLG_s = \u0026#34;x\u0026#34;; #Add alias for a flag Added in v3.0, when defining a flag variable, you can add any number of aliases to the flag.\nIn command line or config file, alias can be used instead of the original name.\nExample\nDEF_bool(debug, false, \u0026#34;\u0026#34;); // no alias DEF_bool(debug, false, \u0026#34;\u0026#34;, d); // d is an alias of debug DEF_bool(debug, false, \u0026#34;\u0026#34;, d, dbg); // 2 aliases #Declare the flag variable DEC_bool(name) DEC_int32(name) DEC_int64(name) DEC_uint32(name) DEC_uint64(name) DEC_double(name) DEC_string(name) The 7 macros above are used to declare 7 different types of flag variables.\nThe parameter name is the flag name, and the corresponding global variable name is FLG_name.\nA flag variable can be defined only once, but it can be declared multiple times, which can be declared wherever needed.\nThe flag variable is generally declared outside the namespace, otherwise it may be not possible to use FLG_name to access the flag variable.\nExample\nDEC_bool(b); // extern bool FLG_b; DEC_int32(i32); // extern int32 FLG_i32; DEC_int64(i64); // extern int64 FLG_i64; DEC_uint32(u32); // extern uint32 FLG_u32; DEC_uint64(u64); // extern uint64 FLG_u64; DEC_double(d); // extern double FLG_d; DEC_string(s); // extern fastring FLG_s; #Use the flag variable Once a flag variable is defined or declared, we can use it the same as an ordinary variable.\n#include \u0026#34;co/flag.h\u0026#34; DEC_bool(b); DEF_string(s, \u0026#34;hello\u0026#34;, \u0026#34;xxx\u0026#34;); int main(int argc, char** argv) { flag::init(argc, argv); if (!FLG_b) std::cout \u0026lt;\u0026lt; \u0026#34;b is false\u0026#34; \u0026lt;\u0026lt; std::endl; FLG_s += \u0026#34; world\u0026#34;; std::cout \u0026lt;\u0026lt; FLG_s \u0026lt;\u0026lt; std::endl; return 0; } #Use flag in the command line #Set value of flags Suppose the following flags are defined in the program:\nDEF_bool(x, false, \u0026#34;bool x\u0026#34;); DEF_bool(y, false, \u0026#34;bool y\u0026#34;); DEF_int32(i, -32, \u0026#34;int32\u0026#34;); DEF_uint64(u, 64, \u0026#34;uint64\u0026#34;); DEF_string(s, \u0026#34;nice\u0026#34;, \u0026#34;string\u0026#34;); When the program starts, we can modify value of the flag variables through command line parameters:\n# -x=y, x=y, -x y, the three are equivalent ./xx -i=8 u=88 -s=xxx ./xx -i 8 -u 88 -s \u0026#34;hello world\u0026#34; ./xx -i8 # -i=8, only for single-letter named integer flags # When a bool type is set to true, the value can be omitted ./xx -x # -x=true # Multiple single-letter named bool flags can be combined and set to true ./xx -xy # -x=true -y=true # Integer type flags can have units k, m, g, t, p, not case sensitive ./xx -i -4k # i=-4096 # Integer type flags can pass octal or hexadecimal numbers ./xx i=032 # i=26 octal ./xx u=0xff # u=255 hexadecimal #Show Help Information co/flag supports using --help command to print the help information of the program:\n$ ./xx --help usage: $exe [-flag] [value] $exe -x -i 8k -s ok # x=true, i=8192, s=\u0026#34;ok\u0026#34; $exe -- # print all flags $exe -mkconf # generate config file $exe -conf xx.conf # run with config file flags: -n int32 type: int32 default: 0 from: test/flag.cc -s string type: string default: \u0026#34;hello world\u0026#34; from: test/flag.cc #List all flags co/flag provides -- command to list all the flags defined in the program:\n$ ./xx -- flags: -boo bool flag type: bool default: false from: test/flag.cc -co_debug_log enable debug log for coroutine library type: bool default: false from: src/co/scheduler.cc -co_sched_num number of coroutine schedulers, default: os::cpunum() type: uint32 default: os::cpunum() from: src/co/scheduler.cc #Show version of the program version is a flag defined inside co/flag. You can use the --version command to print version information.\nversion is empty by default, its value should be set before calling flag::init().\nExample\n#include \u0026#34;co/flag.h\u0026#34; int main(int argc, char** argv) { FLG_version = \u0026#34;v3.0.0\u0026#34;; flag::init(argc, argv); return 0; } $ ./xx --version v3.0.0 #config file #config file format The config file format of co/flag is flexible:\nOne config item per line, each config item corresponds to a flag, and the form is unified as x = y, which looks clear at a glance.\n# or // are for comments.\n# or // in quotation marks are not comments.\nIgnore the blank characters at the beginning or end of the line.\nBlank characters can be added before or after the = sign.\n\\ can be used to continue a line to avoid too long a line.\nThe string does not support escaping to avoid ambiguity.\nThe string can be enclosed in double quotes, single quotes or 3 back quotes.\nSample config file\n# config file: xx.conf boo = true # bool type s = # empty string s = hello \\ world # s = \u0026#34;helloworld\u0026#34; s = \u0026#34;http://github.com\u0026#34; # # or // in quotation marks are not comments s = \u0026#34;I\u0026#39;m ok\u0026#34; # enclose the string in double quotes s =\u0026#39;how are \u0026#34;U\u0026#34;\u0026#39; # enclose the string in single quotes s = ```I\u0026#39;m \u0026#34;ok\u0026#34;``` # enclose the string in 3 back quotes i32 = 4k # 4096, integers can have units k, m, g, t, p, not case sensitive i32 = 032 # octal, i32 = 26 i32 = 0xff # hexadecimal, i32 = 255 pi = 3.14159 # double type #Generate config file mkconf is a flag defined internally in co/flag, which is a switch for automatically generating config file. You can use -mkconf to generate a config file in command line. ./xx -mkconf # Generate xx.conf ./xx -mkconf -x u=88 # Custom config item value #Adjust the order of config items in config file In the automatically generated config file, the config items are sorted by flag level, file name, and code line number. If the user wants some config items to be ranked higher, the flag level can be set to a smaller value, otherwise, the flag level can be set to a larger value.\nWhen defining a flag, you can use #n at the beginning of the comment to specify the flag level, n must be an integer between 0 and 9. If the comment is not empty, there must be a space after n. When not specified, the default flag level is 5.\nDEF_bool(x, false, \u0026#34;comments\u0026#34;); // The default level is 5 DEF_bool(y, false, \u0026#34;#3\u0026#34;); // The level is 3, and the comment is empty DEF_bool(z, false, \u0026#34;#3 comments\u0026#34;); // The level is 3 #Prohibit config items from being generated in the config file Flags beginning with ., are hidden flags, which will not be present in the config file, but can be found with the -- command in command line. A flag with an empty comment is completely invisible and will neither be generated in the config file nor be found with the -- command.\nDEF_bool(x, false, \u0026#34;.say something here\u0026#34;); DEF_string(s, \u0026#34;good\u0026#34;, \u0026#34;\u0026#34;); #Specify the config file when the program starts config is a flag defined internally in co/flag, which is the path of the config file. It has an alias conf. You can use -config to specify the config file in command line. Another way, you can modify the value of FLG_config to specify the config file, before calling flag::init(). ./xx -config xx.conf ./xx -conf xx.conf # If the config file name ends with .conf or config, # and it is the first non-flag parameter in command line, # -config can be omitted. ./xx xx.conf ./xx xx.conf -x #Custom help information help is a flag defined in co/flag, which stores the help information of the program. This information can be seen with the command --help in command line.\nFLG_help is empty by default, and the default help information provided by co/flag is used.\nYou can modify the value of FLG_help before calling flag::init() to customize the help information.\nExample\n#include \u0026#34;co/flag.h\u0026#34; int main(int argc, char** argv) { FLG_help \u0026lt;\u0026lt; \u0026#34;usage:\\n\u0026#34; \u0026lt;\u0026lt; \u0026#34;\\t./xx -ip 127.0.0.1 -port 7777\\n\u0026#34;; flag::init(argc, argv); return 0; } #Run program as a daemon DEF_bool(daemon, false, \u0026#34;#0 run program as a daemon\u0026#34;); daemon is a flag defined in co/flag. If it is true, the program will run as a daemon. It only works on Linux platform.\nYou can use -daemon in command line to make the program run in the background as a daemon.\nExample\n./xx -daemon "},{"id":10,"href":"/en/co/log/","title":"co/log","section":"Documents for CO","content":"include: co/log.h.\n#Introduction co/log is a C++ streaming log library similar to google glog, which prints logs like this:\nLOG \u0026lt;\u0026lt; \u0026#34;hello world\u0026#34; \u0026lt;\u0026lt; 23; // level log TLOG(\u0026#34;topic\u0026#34;) \u0026lt;\u0026lt; \u0026#34;hello\u0026#34; \u0026lt;\u0026lt; 23; // topic log co/log supports two types of logs, level log and topic log (TLOG).\n#Level Log Level log is divided into 5 levels: debug, info, warning, error, fatal, and provides a series of macros to print logs of different levels.\nA fatal log will terminate the program, and co/log will also print the stack information before the program exits.\nDifferent levels of logs are written to the same file. It is usually used to print debugging information.\n#Topic Log Topic log (TLOG) has no level, but is categorized by topic.\nTopic logs are written into different files according to the topic, and is generally used to print business logs.\n#Performance co/log uses an asynchronous implementation. The log is first written to the cache, and after a certain amount or more than a certain period of time, the background thread writes all data in the cache to the file at a time. The performance has improved by about 20 to 150 times compared with glog on different platforms. The following table shows the test results of printing 1 million info logs (about 50 bytes each) by a single-thread on different platforms:\nplatform google glog co/log win2012 HHD 1.6MB/s 180MB/s win10 SSD 3.7MB/s 560MB/s mac SSD 17MB/s 450MB/s linux SSD 54MB/s 1023MB/s #APIs #log::exit void exit(); Write logs in the cache to the file and exit the log thread. This function is automatically called by co/log when the program exits normally. It is safe to call this function multiple times. When co/log captures SIGINT, SIGTERM, SIGQUIT and other signals, this function will be called before the program exits. #log::set_write_cb void set_write_cb( const std::function\u0026lt;void(const void*, size_t)\u0026gt;\u0026amp; cb, int flags=0 ); void set_write_cb( const std::function\u0026lt;void(const char*, const void*, size_t)\u0026gt;\u0026amp; cb, int flags=0 ); By default, co/log writes logs to a local file. Users can set a callback to write logs to different destinations through this API. The parameter cb is the callback. In the first version (for level log), cb has 2 parameters, a pointer to the log buffer and its length. In the second version (for TLOG), cb has 3 parameters, the first is the topic, the last two parameters are the same as in the 1st version. The buffer may contain multiple logs. The parameter flags is new in v3.0, the default is 0, it can be a combination of the following options: log::log2local, also write logs to local file. #APIs removed in v3.0 log::init, removed in v3.0, starting from co 3.0, we only need to call flag::init(argc, argv) at the beginning of the main function.\nlog::set_single_write_cb, removed in v3.0.\nlog::close, removed in v3.0, use log::exit() instead.\n#Level Log #Basic usages DLOG LOG WLOG ELOG FLOG The above 5 macros are used to print 5 levels of logs respectively, they are thread safe.\nThese macros are actually references to fastream, so any type supported by fastream::operator\u0026lt;\u0026lt; can be printed.\nThese macros will automatically add a \u0026lsquo;\\n\u0026rsquo; at the end of each log, and users do not need to manually enter a newline character.\nThe first 4 types will only print the log when the FLG_min_log_level is not greater than the current log level. The user can set FLG_min_log_level to a larger value to disable low-level logs.\nPrint a fatal level log, which means that the program has a fatal error. co/log will print the stack information of the current thread and terminate the program.\nExample\nDLOG \u0026lt;\u0026lt; \u0026#34;this is DEBUG log \u0026#34;\u0026lt;\u0026lt; 23; LOG \u0026lt;\u0026lt; \u0026#34;this is INFO log \u0026#34;\u0026lt;\u0026lt; 23; WLOG \u0026lt;\u0026lt; \u0026#34;this is WARNING log \u0026#34;\u0026lt;\u0026lt; 23; ELOG \u0026lt;\u0026lt; \u0026#34;this is ERROR log \u0026#34;\u0026lt;\u0026lt; 23; FLOG \u0026lt;\u0026lt; \u0026#34;this is FATAL log \u0026#34;\u0026lt;\u0026lt; 23; #Condition Log #define DLOG_IF(cond) if (cond) DLOG #define LOG_IF(cond) if (cond) LOG #define WLOG_IF(cond) if (cond) WLOG #define ELOG_IF(cond) if (cond) ELOG #define FLOG_IF(cond) if (cond) FLOG The above 5 macros accept a conditional parameter cond, and only print the log when cond is true.\nThe parameter cond can be any expression whose value is of type bool.\nSince the condition is judged in the first place, even if the log of the corresponding level is disabled, these macros will ensure that the cond expression is executed.\nExample\nint s = socket(); DLOG_IF(s != -1) \u0026lt;\u0026lt; \u0026#34;create socket ok: \u0026#34;\u0026lt;\u0026lt; s; LOG_IF(s != -1) \u0026lt;\u0026lt; \u0026#34;create socket ok: \u0026#34;\u0026lt;\u0026lt; s; WLOG_IF(s == -1) \u0026lt;\u0026lt; \u0026#34;create socket ko: \u0026#34;\u0026lt;\u0026lt; s; ELOG_IF(s == -1) \u0026lt;\u0026lt; \u0026#34;create socket ko: \u0026#34;\u0026lt;\u0026lt; s; FLOG_IF(s == -1) \u0026lt;\u0026lt; \u0026#34;create socket ko: \u0026#34;\u0026lt;\u0026lt; s; #Print log every N entries #define DLOG_EVERY_N(n) _LOG_EVERY_N(n, DLOG) #define LOG_EVERY_N(n) _LOG_EVERY_N(n, LOG) #define WLOG_EVERY_N(n) _LOG_EVERY_N(n, WLOG) #define ELOG_EVERY_N(n) _LOG_EVERY_N(n, ELOG) The above macro prints the log once every n entries, internally counted by atomic operation, which is thread safe.\nThe parameter n must be an integer greater than 0, and generally should not exceed the maximum value of the int type.\nWhen the parameter n is a power of 2, the log will be printed exactly once every n entries, otherwise there may be very few cases when it is not printed once every n entries.\nThe first log will always be printed.\nThe program will terminate as soon as the fatal log is printed, so FLOG_EVERY_N is not provided.\nExample\n// Print every 32 items (1,33,65...) DLOG_EVERY_N(32) \u0026lt;\u0026lt; \u0026#34;this is DEBUG log \u0026#34;\u0026lt;\u0026lt; 23; LOG_EVERY_N(32) \u0026lt;\u0026lt; \u0026#34;this is INFO log \u0026#34;\u0026lt;\u0026lt; 23; WLOG_EVERY_N(32) \u0026lt;\u0026lt; \u0026#34;this is WARNING log \u0026#34;\u0026lt;\u0026lt; 23; ELOG_EVERY_N(32) \u0026lt;\u0026lt; \u0026#34;this is ERROR log \u0026#34;\u0026lt;\u0026lt; 23; #Print the first N logs #define DLOG_FIRST_N(n) _LOG_FIRST_N(n, DLOG) #define LOG_FIRST_N(n) _LOG_FIRST_N(n, LOG) #define WLOG_FIRST_N(n) _LOG_FIRST_N(n, WLOG) #define ELOG_FIRST_N(n) _LOG_FIRST_N(n, ELOG) The above macro prints the first n logs, internally counted by atomic operation, which is thread safe.\nThe parameter n is an integer not less than 0 (no log will be printed when it is equal to 0). Generally, it should not exceed the maximum value of the int type.\nIn general, do not use complex expressions for the parameter n.\nThe program will terminate as soon as the fatal log is printed, so FLOG_FIRST_N is not provided.\nExample\n// print the first 10 logs DLOG_FIRST_N(10) \u0026lt;\u0026lt; \u0026#34;this is DEBUG log \u0026#34;\u0026lt;\u0026lt; 23; LOG_FIRST_N(10) \u0026lt;\u0026lt; \u0026#34;this is INFO log \u0026#34;\u0026lt;\u0026lt; 23; WLOG_FIRST_N(10) \u0026lt;\u0026lt; \u0026#34;this is WARNING log \u0026#34;\u0026lt;\u0026lt; 23; ELOG_FIRST_N(10) \u0026lt;\u0026lt; \u0026#34;this is ERROR log \u0026#34;\u0026lt;\u0026lt; 23; #TLOG #define TLOG(topic) #define TLOG_IF(topic, cond) if (cond) TLOG(topic) The TLOG macro takes a parameter topic, which is a C-style string, and must have a static lifetime.\nThe TLOG_IF macro prints the log only when cond is true.\nExample\nTLOG(\u0026#34;xx\u0026#34;) \u0026lt;\u0026lt; \u0026#34;hello \u0026#34; \u0026lt;\u0026lt; 23; TLOG_IF(\u0026#34;xx\u0026#34;, true) \u0026lt;\u0026lt; \u0026#34;hello \u0026#34; \u0026lt;\u0026lt; 23; #CHECK Assertion #define CHECK(cond) \\ if (!(cond)) _FLOG_STREAM \u0026lt;\u0026lt; \u0026#34;check failed: \u0026#34;#cond \u0026#34;!\u0026#34; #define CHECK_NOTNULL(p) \\ if ((p) == 0) _FLOG_STREAM \u0026lt;\u0026lt; \u0026#34;check failed: \u0026#34;#p\u0026#34; mustn\u0026#39;t be NULL! \u0026#34; #define CHECK_EQ(a, b) _CHECK_OP(a, b, ==) #define CHECK_NE(a, b) _CHECK_OP(a, b, !=) #define CHECK_GE(a, b) _CHECK_OP(a, b, \u0026gt;=) #define CHECK_LE(a, b) _CHECK_OP(a, b, \u0026lt;=) #define CHECK_GT(a, b) _CHECK_OP(a, b, \u0026gt;) #define CHECK_LT(a, b) _CHECK_OP(a, b, \u0026lt;) The above macros can be regarded as an enhanced version of assert, and they will not be cleared in DEBUG mode.\nThese macros are similar to FLOG and can print fatal level logs.\nCHECK asserts that the condition cond is true, and cond can be any expression with a value of type bool.\nCHECK_NOTNULL asserts that the pointer is not NULL.\nCHECK_EQ asserts a == b.\nCHECK_NE asserts a != b.\nCHECK_GE asserts a \u0026gt;= b.\nCHECK_LE asserts a \u0026lt;= b.\nCHECK_GT asserts a \u0026gt; b.\nCHECK_LT asserts a \u0026lt; b.\nIt is generally recommended to use CHECK_XX(a, b) first, they provide more information than CHECK(cond), and will print out the values of parameters a and b.\nTypes not supported by fastream::operator\u0026lt;\u0026lt;, such as iterator type of STL containers, cannot use the CHECK_XX(a, b) macros.\nWhen the assertion fails, the log library first calls log::close(), then prints the function call stack information of the current thread, and then exits the program.\nExample\nint s = socket(); CHECK(s != -1); CHECK(s != -1) \u0026lt;\u0026lt; \u0026#34;create socket failed\u0026#34;; CHECK_NE(s, -1) \u0026lt;\u0026lt; \u0026#34;create socket failed\u0026#34;; // s != -1 CHECK_GE(s, 0) \u0026lt;\u0026lt; \u0026#34;create socket failed\u0026#34;; // s \u0026gt;= 0 CHECK_GT(s, -1) \u0026lt;\u0026lt; \u0026#34;create socket failed\u0026#34;; // s \u0026gt; -1 std::map\u0026lt;int, int\u0026gt; m; auto it = m.find(3); CHECK(it != m.end()); // Cannot use CHECK_NE(it, m.end()), the compiler will report an error #Stack trace co/log will print the function call stack when CHECK assertion failed, or an abnormal signal like SIGSEGV was caught. See details below:\n(https://asciinema.org/a/435894)\nTo get the stack trace, you should compile with debug symbols (compile with -g for gcc, etc). And on linux and macosx, libbacktrace is required, make sure you have installed it on your system. On linux, libbacktrace may have been installed within a newer version of gcc. You may find it in a directory like /usr/lib/gcc/x86_64-linux-gnu/9. Otherwise, you can install it by yourself as follow:\ngit clone https://github.com/ianlancetaylor/libbacktrace.git cd libbacktrace-master ./configure make -j8 sudo make install #Configuration co/log uses co/flag to define config items. The flags defined inside co/log are listed below. These config items are valid for both level log and TLOG unless otherwise specified.\n#log_dir DEF_string(log_dir, \u0026#34;logs\u0026#34;, \u0026#34;#0 log dir, will be created if not exists\u0026#34;); Specify the log directory. The default is the logs directory under the current directory. If it does not exist, it will be created automatically. log_dir can be an absolute path or a relative path, and the path separator can be either \u0026lsquo;/\u0026rsquo; or \u0026lsquo;'. It is generally recommended to use \u0026lsquo;/\u0026rsquo;. When the program starts, make sure that the current user has sufficient permissions, otherwise the creation of the log directory may fail. #log_file_name DEF_string(log_file_name, \u0026#34;\u0026#34;, \u0026#34;#0 name of log file, using exename if empty\u0026#34;); Specify the log file name (without path), the default is empty, use the program name (.exe at the end will be removed), for example, the log file name corresponding to program xx or xx.exe is xx.log. If the log file name does not end with .log, co/log automatically adds .log to the end of it. #min_log_level DEF_int32(min_log_level, 0, \u0026#34;#0 write logs at or above this level, 0-4 (debug|info|warning|error|fatal)\u0026#34;); For level log only. Specify the minimum level of logs to be printed, which can be used to disable low-level logs, the default is 0, and all levels of logs are printed. #max_log_size DEF_int32(max_log_size, 4096, \u0026#34;#0 max size of a single log\u0026#34;); Specify the maximum size of a single log, the default is 4k. A log will be truncated if its size is larger than this value. This value cannot exceed half of max_log_buffer_size. #max_log_file_size DEF_int64(max_log_file_size, 256 \u0026lt;\u0026lt; 20, \u0026#34;#0 max size of log file, default: 256MB\u0026#34;); Specify the maximum size of a log file. The default is 256M. If this size is exceeded, a new log file will be generated, and the old log file will be renamed. #max_log_file_num DEF_uint32(max_log_file_num, 8, \u0026#34;#0 max number of log files\u0026#34;); Specify the maximum number of log files. The default is 8. If this value is exceeded, old log files will be deleted. #max_log_buffer_size DEF_uint32(max_log_buffer_size, 32 \u0026lt;\u0026lt; 20, \u0026#34;#0 max size of log buffer, default: 32MB\u0026#34;); Specify the maximum size of the log cache. The default is 32M. If this value is exceeded, about half of the logs will be lost. #log_flush_ms DEF_uint32(log_flush_ms, 128, \u0026#34;#0 flush the log buffer every n ms\u0026#34;); The time interval for the background thread to flush the log cache to the file, in milliseconds. #log_daily DEF_bool(log_daily, false, \u0026#34;\u0026gt;\u0026gt;#0 if true, enable daily log rotation\u0026#34;); Generate log files by day, the default is false. #cout DEF_bool(cout, false, \u0026#34;#0 also logging to terminal\u0026#34;); Terminal log switch, the default is false. If true, logs will also be printed to the terminal. #Log file #Log Organization co/log will record all levels of logs in the same file. By default, the program name is used as the log file name. For example, the log file of process xx is xx.log. When the log file reaches the maximum size (FLG_max_log_file_size), co/log will rename the log file and generate a new file. The log directory may contain the following files:\nxx.log xx_0523_16_12_54.970.log xx_0523_16_13_12.921.log xx_0523_16_15_05.264.log xx.log is always the latest log file. When the number of files exceeds FLG_max_log_file_num, co/log will remove the oldest log file.\nfatal logs will be additionally recorded in the xx.fatal file, co/log will not rename or delete the fatal log file.\n#Log format I0514 11:15:30.123 1045 test/xx.cc:11] hello world D0514 11:15:30.123 1045 test/xx.cc:12] hello world W0514 11:15:30.123 1045 test/xx.cc:13] hello world E0514 11:15:30.123 1045 test/xx.cc:14] hello world F0514 11:15:30.123 1045 test/xx.cc:15] hello world In the above example, each line corresponds to one log. The first letter of each log is the log level, I means info, D means debug, W means warning, E means error, and F means fatal. After the level is the time, from month to milliseconds. The year is not printed. The time of the log is not the time when it is generated, but the time when it is written to the cache, as we must ensure that the logs in the log file are strictly sorted by time. After the time is the thread id, 1045 above is the thread id. The thread id is followed by the file and line number of the log code. After the line number is ] , that is, a space after ]. following the ] ，is the log content by the user. #View logs On linux or mac, grep, tail and other commands can be used to view the logs.\ngrep ^E xx.log tail -F xx.log tail -F xx.log | grep ^E The first line uses grep to filter out the error logs in the file, ^E means starts with the letter E. The second line uses the tail -F command to dynamically track the log file, here we should use the uppercase F, because xx.log may be renamed, and then generate a new xx.log file, -F make sure to follow the latest file by the name. In line 3, use tail -F in conjunction with grep to dynamically track the error logs in the log file. #Build and run the test program xmake -b log # build log or log.exe xmake r log # run log or log.exe xmake r log -cout # also log to terminal xmake r log -min_log_level=1 # 0-4: debug,info,warning,error,fatal xmake r log -perf # performance test Run xmake -b log in the co root directory to compile test/log.cc, and a binary program named log or log.exe will be generated. "},{"id":11,"href":"/en/co/unitest/","title":"Unitest","section":"Documents for CO","content":"include: co/unitest.h.\n#Basic concepts co/unitest is a unit testing framework, similar to google gtest, but easier to use.\n#Test Units and Test Cases A test program can be divided into multiple test units according to functions or modules, and there can be multiple test cases under each test unit. For example, a test unit can be defined for a class (or module) in C++, and a test case can be defined for each method in the class (or module).\nIn co/unitest, when a test unit is defined, a class is generated, and there is a run() method in the class, and code of all test cases are in the run() method. co/unitest almost hides all the details. Users can\u0026rsquo;t see the class, or even the run() method, so they can concentrate on writing test code:\nDEF_test(test_name) { DEF_case(a) { // write test code here } DEF_case(b) { // write test code here } } The above DEF_test actually implements the run() method in the class, while DEF_case defines a test case. A test case is actually a code block in the run() method, not even a function.\n#DEF_test #define DEF_test(_name_) \\ DEF_bool(_name_, false, \u0026#34;enable this test if true.\u0026#34;); \\ ... \\ void _UTest_##_name_::run() The DEF_test macro is used to define a test unit, and the parameter _name_ is the name of the test unit. The first line of the macro defines a bool type flag variable, which is the switch of the test unit. For example, DEF_test(os) defines a test unit os, and we can use -os in the command line to enable test cases in this unit. The codes omitted in the middle of the macro actually defines a class, and the last line defines the method run() in the class, which requires the user to complete the function body. #DEF_case #define DEF_case(name) _current_case.reset(new unitest::Case(#name)); The DEF_case macro is used to define a test case in the test unit. The parameter name is the name of the test case. It must be used inside the run() method defined by DEF_test. The name of a test unit must be albe to use as part of the class name or variable name. The test case name does not have this restriction. For example, DEF_case(sched.Copool) is also reasonable. The code after DEF_case is all test code of this test case until the next DEF_case appears. The code of the test case is generally enclosed by a pair of curly braces to isolate it from other test cases. DEF_test may not contain any DEF_case. In this case, co/unitest will create a default test case. #EXPECT assertion #define EXPECT(x) ... #define EXPECT_EQ(x, y) EXPECT_OP(x, y, ==, \u0026#34;EQ\u0026#34;) #define EXPECT_NE(x, y) EXPECT_OP(x, y, !=, \u0026#34;NE\u0026#34;) #define EXPECT_GE(x, y) EXPECT_OP(x, y, \u0026gt;=, \u0026#34;GE\u0026#34;) #define EXPECT_LE(x, y) EXPECT_OP(x, y, \u0026lt;=, \u0026#34;LE\u0026#34;) #define EXPECT_GT(x, y) EXPECT_OP(x, y, \u0026gt;, \u0026#34;GT\u0026#34;) #define EXPECT_LT(x, y) EXPECT_OP(x, y, \u0026lt;, \u0026#34;LT\u0026#34;) EXPECT asserts that x is true, and x can be any expression with a value of type bool. EXPECT_EQ asserts x == y. EXPECT_NE asserts x != y. EXPECT_GE asserts that x \u0026gt;= y. EXPECT_LE asserts that x \u0026lt;= y. EXPECT_GT asserts that x \u0026gt; y. EXPECT_LT asserts that x \u0026lt; y. When defining a test case with DEF_case, you can use these macro assertions. If an assertion fails, it means that the test case fails. The terminal will print related error messages in red color. #Write test code #Test code example // os.cc #include \u0026#34;co/unitest.h\u0026#34; #include \u0026#34;co/os.h\u0026#34; namespace test { DEF_test(os) { DEF_case(homedir) { EXPECT_NE(os::homedir(), \u0026#34;\u0026#34;); } DEF_case(pid) { EXPECT_GE(os::pid(), 0); } DEF_case(cpunum) { EXPECT_GT(os::cpunum(), 0); } } } // namespace test The above code defines a test unit named os, and os has 3 test cases. When running the test program, you can use -os in the command line to enable this unit test. The code of different test units are generally put in different .cc source files. The user can put test code in a namespace, if necessary. #Default test case DEF_test(os) { EXPECT_NE(os::homedir(), \u0026#34;\u0026#34;); EXPECT_GE(os::pid(), 0); EXPECT_GT(os::cpunum(), 0); } The above code does not contain any DEF_case, co/unitest will create a default test case named \u0026ldquo;default\u0026rdquo;. For more complex test codes, it is generally not recommended to use the default test cases. It is better to divide them into different cases so that the code looks clearer. #main() function #include \u0026#34;co/unitest.h\u0026#34; int main(int argc, char** argv) { flag::init(argc, argv); unitest::run_all_tests(); return 0; } Call the run_all_tests() method provided by co/unitest in the main function to start running the test code. Before calling run_all_tests(), the flag::init() method must be called to parse the command line parameters. #Build and run the test program #Build the unitest code xmake -b unitest Execute the above command in the co root directory to compile the unit test code in the co/unitest directory and generate the unitest binary program . #Run all test cases # Run all test cases xmake r unitest #Run test cases in specified test units # Run only test cases in the os test unit xmake r unitest -os # Run test cases in the os or json test units xmake r unitest -os -json By default, all test units are disabled, you need to enable the test code with the corresponding switch. #Test result example All tests passed Test case failed "},{"id":12,"href":"/en/co/json/","title":"JSON","section":"Documents for CO","content":"include: co/json.h.\nco/json is a JSON library similar to rapidjson. Compared with rapidjson, it has better performance and is easier to use.\n#Basic concepts JSON is a simple data format that supports two data structures:\nA collection consisting of a series of key/value pairs. This type of structure is called object, which corresponds to struct, map, etc, in programming languages. A list composed of a series of value, this kind of structure is called array, which corresponds to vector, list, etc, in programming languages. In the above, the key is a string, and the value is generally called JSON value, which can be any of object, array, number, string, bool(false, true), or null. number is an integer or a floating-point number, and most implementations will distinguish integers from floating-point numbers.\nObject is enclosed by a pair of braces, array is enclosed by a pair of square brackets, they look like this:\n{\u0026#34;a\u0026#34;:1, \u0026#34;b\u0026#34;:false, \u0026#34;s\u0026#34;:\u0026#34;xxx\u0026#34;} [1, 2, 3] By definition, object and array can be nested, which can represent complex data structures such as trees.\n#Json #Json::Json 1. Json() noexcept; 2. Json(decltype(nullptr)) noexcept; 3. Json(Json\u0026amp;\u0026amp; v) noexcept; 4. Json(Json\u0026amp; v) noexcept; Json(const Json\u0026amp; v) = delete; 5. Json(bool v); 6. Json(double v); 7. Json(int64 v); 8. Json(int32 v); 9. Json(uint32 v); 10. Json(uint64 v); 11. Json(const void* p, size_t n); 12. Json(const char* s); 13. Json(const fastring\u0026amp; s); 14. Json(const std::string\u0026amp; s); 15. Json(std::initializer_list\u0026lt;Json\u0026gt; v); 1-2, construct a null object.\n3-4, move constructor and copy constructor, both implement a move semantic, the parameter v will become a null object after the construction.\n5, construct a JSON object of bool type.\n6, construct a JSON object of double type.\n7-10, construct a JSON object of integer type.\n11-14, construct a JSON object of string type.\n15, construct a JSON object of object or array type from a initialization list.\nExample\nJson a; // null Json b(nullptr); // null Json c = false; // bool Json d = 3.14; // double Json e = 23; // integer Json f = \u0026#34;xx\u0026#34;; // string Json g = {1, 2, 3}; // g -\u0026gt; [1, 2, 3] Json h = {\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;}; // h -\u0026gt; [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;] Json i = { // i -\u0026gt; { \u0026#34;a\u0026#34;: \u0026#34;b\u0026#34; } {\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;} }; Json j = { // j -\u0026gt; {\u0026#34;a\u0026#34;: 1, \u0026#34;b\u0026#34;: [1,2,3]} {\u0026#34;a\u0026#34;, 1}, {\u0026#34;b\u0026#34;, {1, 2, 3}}, }; Json x(i); // i -\u0026gt; null Json y(std::move(j)); // j -\u0026gt; null #json::array Json array(); This function is in namespace json, it returns an empty array. #json::object Json object(); This function is in namespace json, it returns an empty object. #Json::operator= Json\u0026amp; operator=(Json\u0026amp;\u0026amp; v); Json\u0026amp; operator=(Json\u0026amp; v); void operator=(const Json\u0026amp;) = delete; Assignment, the 2 methods above are equal, v is moved to the calling Json object, and becomes a null object after the operation. #Json::dup Json dup() const; Return a deep copy of a JSON object.\n示例\nJson x = {1, 2, 3}; // x -\u0026gt; [1,2,3] Json y, z; y = x; // x -\u0026gt; null, y -\u0026gt; [1,2,3] z = y.dup(); // y:[1,2,3], z -\u0026gt; [1,2,3] #——————————— #Json::is_null bool is_null() const; Determine whether the Json is null. #Json::is_bool bool is_bool() const; Determine whether the Json is bool type. #Json::is_int bool is_int() const; Determine whether the Json is integer type. #Json::is_double bool is_double() const; Determine whether the Json is double type. #Json::is_string bool is_string() const; Determine whether the Json is string type. #Json::is_array bool is_array() const; Determine whether the Json is array type. #Json::is_object bool is_object() const; Determine whether the Json is object type. #——————————— #Json::as_bool bool as_bool() const; Get value of bool type. For int or double types, returns false if the value is 0, otherwise returns true. For string type, returns true if the value is \u0026quot;true\u0026quot; or \u0026quot;1\u0026quot;, otherwise returns false. For other non-bool types, return false. #Json::as_int int as_int() const; int32 as_int32() const; int64 as_int64() const; Get value of integer type. For bool, double or string types, the result is automatically converted to an integer. For other non-integer types, 0 is returned. #Json::as_double double as_double() const; Get value of double type. Return 0 if the Json object calling this method is not double type. Get value of double type. For bool, int or string types, the result is automatically converted to double type. For other non-double types, 0 is returned. #Json::as_string const char* as_string() const; This method returns a C-style string ending with '\\0', and the user can also call the string_size() method to get the length of the string. Get value of string type, return fastring. For non-string types, this method is equal to Json::str(), and the result will be automatically converted to string type. #Json::as_c_str const char* as_c_str() const; Returns a null-terminated C-style string, string_size() can be called to get its length. For non-string types, return an empty string. #Json::get 1. Json\u0026amp; get(uint32 i) const; 2. Json\u0026amp; get(int i) const; 3. Json\u0026amp; get(const char* key) const; 4. template \u0026lt;class T, class ...X\u0026gt; inline Json\u0026amp; get(T\u0026amp;\u0026amp; v, X\u0026amp;\u0026amp; ... x) const; Get JSON object according to index or key. This method is a read-only operation and will not modify the JSON object that calls this method. 1-2, get the i-th element of the array object. If the JSON object that calls this method is not of type array, or i exceeds the range of the array, the returned result will refer to a null object. 3, get the JSON value corresponding to key, if the JSON object called this method is not of type object, or key does not exist, the returned result will refer to a null object. 4, can take any number of parameters, each parameter is an index or a key. When it encounters the first invalid index or non-existing key, it returns immediately, and the return result will refer to a null object. #Json::set template \u0026lt;class T\u0026gt; inline Json\u0026amp; set(T\u0026amp;\u0026amp; v) { return *this = Json(std::forward\u0026lt;T\u0026gt;(v)); } template \u0026lt;class A, class B, class ...X\u0026gt; inline Json\u0026amp; set(A\u0026amp;\u0026amp; a, B\u0026amp;\u0026amp; b, X\u0026amp;\u0026amp; ... x); Set the value of the JSON object. The last parameter of set is the value to be set, other parameters are index or key. #Example Json r = { { \u0026#34;a\u0026#34;, 7 }, { \u0026#34;b\u0026#34;, false }, { \u0026#34;c\u0026#34;, { 1, 2, 3 } }, { \u0026#34;s\u0026#34;, \u0026#34;23\u0026#34; }, }; r.get(\u0026#34;a\u0026#34;).as_int(); // 7 r.get(\u0026#34;b\u0026#34;).as_bool(); // false r.get(\u0026#34;s\u0026#34;).as_string(); // \u0026#34;23\u0026#34; r.get(\u0026#34;s\u0026#34;).as_int(); // 23 r.get(\u0026#34;c\u0026#34;, 0).as_int(); // 1 r.get(\u0026#34;c\u0026#34;, 1).as_int(); // 2 // x -\u0026gt; {\u0026#34;a\u0026#34;:1,\u0026#34;b\u0026#34;:[0,1,2],\u0026#34;c\u0026#34;:{\u0026#34;d\u0026#34;:[\u0026#34;oo\u0026#34;]}} Json x; x.set(\u0026#34;a\u0026#34;, 1); x.set(\u0026#34;b\u0026#34;, Json({0,1,2})); x.set(\u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;, 0, \u0026#34;oo\u0026#34;); #——————————— #Json::operator== bool operator==(bool v) const; bool operator==(double v) const; bool operator==(int64 v) const; bool operator==(int v) const; bool operator==(uint32 v) const; bool operator==(uint64 v) const; bool operator==(const char* v) const; bool operator==(const fastring\u0026amp; v) const; bool operator==(const std::string\u0026amp; v) const; Check if the value of the Json object is equal to v. If the type of the Json object is different from v, return false directly. #Json::operator!= bool operator!=(bool v) const; bool operator!=(double v) const; bool operator!=(int64 v) const; bool operator!=(int v) const; bool operator!=(uint32 v) const; bool operator!=(uint64 v) const; bool operator!=(const char* v) const; bool operator!=(const fastring\u0026amp; v) const; bool operator!=(const std::string\u0026amp; v) const; Check if the value of the Json object is not equal to v. If the type of the Json object is different from v, return true directly. #Example Json x = { {\u0026#34;a\u0026#34;, 3}, {\u0026#34;b\u0026#34;, false}, {\u0026#34;s\u0026#34;, \u0026#34;xx\u0026#34;}, }; x == 7; // false x[\u0026#34;a\u0026#34;] == 3; // true x[\u0026#34;b\u0026#34;] == false; // true x[\u0026#34;s\u0026#34;] == \u0026#34;xx\u0026#34;; // true #——————————— #Json::add_member Json\u0026amp; add_member(const char* key, Json\u0026amp;\u0026amp; v); Json\u0026amp; add_member(const char* key, Json\u0026amp; v); Add a key-value pair to a Json of object type (non-object Json automatically becomes object after calling this method).\nThis method will reserve the order in which keys were added, and keys may appear repeatedly.\nThe parameter key is a C string ending in '\\0', and the parameter v is the value.\nv is moved and becomes null after this operation.\nNOTE: for performance reasons, it is required that the key cannot contain double quotes.\nExample\nJson r; r.add_member(\u0026#34;a\u0026#34;, 1); // r -\u0026gt; {\u0026#34;a\u0026#34;:1} r.add_member(\u0026#34;d\u0026#34;, 3.3); // r -\u0026gt; {\u0026#34;a\u0026#34;:1, \u0026#34;d\u0026#34;:3.3} r.add_member(\u0026#34;s\u0026#34;, \u0026#34;xx\u0026#34;); // r -\u0026gt; {\u0026#34;a\u0026#34;:1, \u0026#34;d\u0026#34;:3.3, \u0026#34;s\u0026#34;:\u0026#34;xx\u0026#34;} Json x; x.add_member(\u0026#34;xx\u0026#34;, r); // r -\u0026gt; null r.add_member(\u0026#34;o\u0026#34;, Json().add_member(\u0026#34;x\u0026#34;, 3)); // r -\u0026gt; {\u0026#34;o\u0026#34;:{\u0026#34;x\u0026#34;:3}} Json().add_member(\u0026#34;o\u0026#34;, 1).add_member(\u0026#34;k\u0026#34;, 2); // -\u0026gt; {\u0026#34;o\u0026#34;:1,\u0026#34;k\u0026#34;:2} #Json::erase void erase(uint32 i); void erase(int i); void erase(const char* key); The first two, erase the ith element from an array. The third, erase the element by key from an object. #Json::push_back Json\u0026amp; push_back(Json\u0026amp;\u0026amp; v); Json\u0026amp; push_back(Json\u0026amp; v); Add elements to an array (non-array Json automatically becomes an array after calling this method).\nv is moved and becomes null after this operation.\nExample\nJson r; r.push_back(1); // r -\u0026gt; [1] r.push_back(3.3); // r -\u0026gt; [1, 3.3] r.push_back(\u0026#34;xx\u0026#34;); // r -\u0026gt; [1, 3.3, \u0026#34;xx\u0026#34;] Json x; x.push_back(r); // r -\u0026gt; null, x -\u0026gt; [[1, 3.3, \u0026#34;xx\u0026#34;]] r.push_back(Json().push_back(1).push_back(2)); // r -\u0026gt; [[1,2]] #Json::remove void remove(uint32 i); void remove(int i); void remove(const char* key); The first two, remove the ith element from an array. The third, remove the element by key from an object. The last element will be moved to the position where the element was removed. #Json::reset void reset(); Reset the Json object to null. #Json::swap void swap(Json\u0026amp; v) noexcept; void swap(Json\u0026amp;\u0026amp; v) noexcept; Swap the contents of two Json objects. #——————————— #Json::operator[] Json\u0026amp; operator[](uint32 i) const; Json\u0026amp; operator[](int i) const; Json\u0026amp; operator[](const char* key) const; Overload operator[], get the elements in the Json by index or key.\n1-2, for array type, get the i-th element of the array object, i must be within the size range of the array.\n3, for object type, when the key does not exist, a null object will be inserted into the Json.\nIn general, it is recommended to replace this operation with the read-only get() method whenever possible.\nExample\nJson r = { { \u0026#34;a\u0026#34;, 7 }, { \u0026#34;x\u0026#34;, { 1, 2, 3 } }, }; r[\u0026#34;a\u0026#34;].as_int(); // 7 r[\u0026#34;x\u0026#34;][0].as_int(); // 1 #Json::has_member bool has_member(const char* key) const; Determine whether there is an element corresponding to key in Json.\nReturn false if the Json calling this method is not object type.\nExample\nJson r = {{\u0026#34;a\u0026#34;, 1}}; r.has_member(\u0026#34;a\u0026#34;); // true r.has_member(\u0026#34;x\u0026#34;); // false #Json::size uint32 size() const; If Json is object or array, this method returns the number of elements.\nIf Json is string type, this method returns the length of the string.\nFor all other types, this method returns 0.\nExample\nJson r = { {\u0026#34;x\u0026#34;, 1}, {\u0026#34;s\u0026#34;, \u0026#34;hello\u0026#34;}, {\u0026#34;a\u0026#34;, {1, 2, 3}}, }; r.size(); // 3 r[\u0026#34;x\u0026#34;].size(); // 0 r[\u0026#34;s\u0026#34;].size(); // 5 r[\u0026#34;a\u0026#34;].size(); // 3 #Json::empty bool empty() const; Check whether the Json is empty, which is equal to size() == 0. #Json::string_size uint32 string_size() const; Return the length of the string type. Return 0 if the Json calling this method is not string type. #Json::array_size uint32 array_size() const; Return the number of elements of array type. Return 0 if the Json calling this method is not array type. #Json::object_size uint32 object_size() const; Return the number of elements of object type. Return 0 if the Json calling this method is not object type. #——————————— #Json::str fastream\u0026amp; str(fastream\u0026amp; s, int mdp=16) const; fastring\u0026amp; str(fastring\u0026amp; s, int mdp=16) const; fastring str(int mdp=16) const; Convert Json to a string. The 1st version appends the JSON string to a fastream, and the return value is the same as the parameter s. The 2nd version appends the JSON string to a fastring, and the return value is the same as the parameter s. The 3rd version returns a JSON string. The parameter mdp is short for max decimal places, which means the maximum number of decimal places for float point numbers. #Json::pretty fastream\u0026amp; pretty(fastream\u0026amp; s, int mdp=16) const; fastring\u0026amp; pretty(fastring\u0026amp; s, int mdp=16) const; fastring pretty(int mdp=16) const; Like the str(), but convert Json to a more beautiful JSON string. #Json::dbg fastream\u0026amp; dbg(fastream\u0026amp; s, int mdp=16) const; fastring\u0026amp; dbg(fastring\u0026amp; s, int mdp=16) const; fastring dbg(int mdp=16) const; Convert Json to a debug string, like Json::str(), but will truncate string type to the first 32 bytes if its length exceeds 512 bytes. This method is generally used to print logs. In some cases, the Json object may contain a long string, such as the base64 encoding of a picture. At such cases, use Json::dbg() instead of Json::str() to avoid printing too many significant logs. #Json::parse_from bool parse_from(const char* s, size_t n); bool parse_from(const char* s); bool parse_from(const fastring\u0026amp; s); bool parse_from(const std::string\u0026amp; s); Parse Json from a JSON string. In the first version, s is not required to end with '\\0'. When the parsing is successful, it returns true, otherwise it returns false. When the parsing fails, the calling Json becomes null. #json::parse Json parse(const char* s, size_t n); Json parse(const char* s); Json parse(const fastring\u0026amp; s); Json parse(const std::string\u0026amp; s); Parse Json from a JSON string. This function is not a method in the Json class, but a function defined in namespace json. This function returns a Json object, when the parsing failed, it returns null. #Example Json r = { { \u0026#34;a\u0026#34;, {1,2,3} } }; fastring s = r.str(); // s -\u0026gt; {\u0026#34;a\u0026#34;:[1,2,3]} fastring p = r.pretty(); LOG \u0026lt;\u0026lt; r.dbg(); // print json debug string LOG \u0026lt;\u0026lt; r; // the same as above, but is more efficient Json x; x.parse_from(s); x.parse_from(p); Json v = json::parse(s); #——————————— #Json::begin iterator begin() const; Returns the beginning iterator. The Json calling this method must be array, object or null. When the Json is empty, the return value is equal to Json::end(). If the Json calling this method is not array or object type, the return value is equal to Json::end(). #Json::end const iterator::End\u0026amp; end() const; Returns a fake end iterator. The return value is actually not an iterator object, but a iterator can be compared with it. If an iterator is equal to Json::end(), it means that there is no more element. #Json::iterator #iterator::operator== bool operator==(const End\u0026amp;) const; Determine whether a iterator is equal to End, End is the fake end iterator. #iterator::operator!= bool operator!=(const End\u0026amp;) const; Determine if a iterator is not equal to End, End is the fake end iterator. #iterator::operator++ iterator\u0026amp; operator++(); The prefix operator++. #iterator::operator* Json\u0026amp; operator*() const; Overload operator*, this method only applies to iterator of array type. When Json is an array, the iterator points to the elements in the array. #iterator::key const char* key() const; This method only applies to iterator of object type. When Json is an object, the iterator points to the key-value pair in the object, and this method returns the key. #iterator::value Json\u0026amp; value() const; This method only applies to iterator of object type. When Json is an object, the iterator points to the key-value pair in the object, and this method returns the value. #Traversing the Json co/json supports traversing a Json of type array or object by iterator:\n// {\u0026#34;i\u0026#34;:7, \u0026#34;s\u0026#34;:\u0026#34;xx\u0026#34;, \u0026#34;a\u0026#34;:[123, true, \u0026#34;nice\u0026#34;]} Json r = { {\u0026#34;i\u0026#34;, 7}, {\u0026#34;s\u0026#34;, \u0026#34;xx\u0026#34;}, {\u0026#34;a\u0026#34;, {1, 2, 3}}, } // object for (auto it = r.begin(); it != r.end(); ++it) { LOG \u0026lt;\u0026lt; it.key() \u0026lt;\u0026lt; \u0026#34;: \u0026#34; \u0026lt;\u0026lt; it.value(); } // array Json\u0026amp; a = r[\u0026#34;a\u0026#34;]; for (auto it = a.begin(); it != a.end(); ++it) { LOG \u0026lt;\u0026lt; (*it); } #Performance tips Some users may add members in the following way:\nJson r; r[\u0026#34;a\u0026#34;] = 1; r[\u0026#34;s\u0026#34;] = \u0026#34;hello world\u0026#34;; Although the above code works, the efficiency may be not so good. The operator[] will first look up the key, which may be slow. It is generally recommended to use add_member() instead:\nJson r; r.add_member(\u0026#34;a\u0026#34;, 1); r.add_member(\u0026#34;s\u0026#34;, \u0026#34;hello world\u0026#34;); Or construct a Json like this:\nJson r = { {\u0026#34;a\u0026#34;, 1}, {\u0026#34;s\u0026#34;, \u0026#34;hello world\u0026#34;}, }; For read-only operations, it is recommended to replace operator[] with get(), which has no side effects.\nJson r = {{\u0026#34;a\u0026#34;, 1}}; r.get(\u0026#34;a\u0026#34;).as_int(); // 1 "},{"id":13,"href":"/en/co/time/","title":"Time","section":"Documents for CO","content":"include: co/time.h.\n#epoch time The EPOCH is a specific time 1970-01-01 00:00:00 UTC, and the epoch time is the time since the EPOCH.\n#epoch::ms int64 ms(); Return milliseconds since EPOCH. #epoch::us int64 us(); Return microseconds since EPOCH. #monotonic time Monotonic time is a monotonic increasing time, it is implemented as the time since last reboot of system on most platforms . It is generally used for timing and is more stable than system time.\n#now::ms int64 ms(); Returns a monotonically increasing timestamp in milliseconds. On mac platform, if the system does not support CLOCK_MONOTONIC, use epoch::ms(). #now::us int64 us(); Returns a monotonically increasing timestamp in microseconds.\nOn mac platform, if the system does not support CLOCK_MONOTONIC, use epoch::us().\nExample\nint64 beg = now::us(); int64 end = now::us(); LOG \u0026lt;\u0026lt; \u0026#34;time used: \u0026#34;\u0026lt;\u0026lt; (end-beg) \u0026lt;\u0026lt;\u0026#34; us\u0026#34;; #Time string (now::str) // fm: time output format fastring str(const char* fm=\u0026#34;%Y-%m-%d %H:%M:%S\u0026#34;); This function returns the string form of the current system time in the specified format. It is implemented based on strftime.\nExample\nfastring s = now::str(); // \u0026#34;2021-07-07 17:07:07\u0026#34; fastring s = now::str(\u0026#34;%Y\u0026#34;); // \u0026#34;2021\u0026#34; #sleep #sleep::ms void ms(uint32 n); Sleep for n milliseconds. #sleep::sec void sec(uint32 n); Sleep for n seconds.\nExample\nsleep::ms(10); // sleep for 10 milliseconds sleep::sec(1); // sleep for 1 second #Timer (Timer) The Timer class is a simple timer based on monotonic time.\n#Timer::Timer Timer(); Constructor, set the start time of the timer, and start timing when the object is created. #Timer::ms int64 ms() const; Return milliseconds since start of the timing. #Timer::us int64 us() const; Return microseconds since start of the timing. #Timer::restart void restart(); Restart the timer.\nExample\nTimer t; sleep::ms(10); int64 us = t.us(); t.restart(); sleep::ms(20); int64 ms = t.ms(); "},{"id":14,"href":"/en/co/thread/","title":"Thread","section":"Documents for CO","content":"include: co/thread.h.\n#Thread The Thread class is an encapsulation of the thread. When a Thread object is created, the thread will be started. Once the thread is started, it will run until the thread function exits. The Thread class does not provide a method for forcing terminating the thread (something like pthread_cancel). This type of method is usually unsafe and may cause damage to user data.\n#Thread::Thread explicit Thread(co::Closure* cb); template\u0026lt;typename F\u0026gt; explicit Thread(F\u0026amp;\u0026amp; f); template\u0026lt;typename F, typename P\u0026gt; Thread(F\u0026amp;\u0026amp; f, P\u0026amp;\u0026amp; p); template\u0026lt;typename F, typename T, typename P\u0026gt; Thread(F\u0026amp;\u0026amp; f, T* t, P\u0026amp;\u0026amp; p); Constructor, the thread will start after the Thread object is created.\nIn the first version, the parameter cb is a pointer of Closure type. Generally, users are not recommended to use this version directly.\nFor the 2-4th version, a Closure object is constructed according to the passed in parameters, and then the first version is called.\nIn the second version, the parameter f is any runnable object, as long as we can call f() or (*f)().\nIn the third version, the parameter f is any runnable object, as long as we can call f(p), (*f)(p) or (p-\u0026gt;*f)().\nIn the fourth version, the parameter f is a method with one parameter in class T, the parameter t is a pointer of type T, and p is the parameter of f.\nExample\nThread x([](){}); // lambda Thread x(f); // void f(); Thread x(f, p); // void f(void*); void* p; Thread x(f, 7); // void f(int v); Thread x(\u0026amp;T::f, \u0026amp;t); // void T::f(); T t; Thread x(\u0026amp;T::f, \u0026amp;t, 7); // void T::f(int v); T t; Thread x(std::bind(\u0026amp;T::f, \u0026amp;t, 7)); // void T::f(int v); T t; #Thread::~Thread Thread::~Thread(); Destructor, call the join() method, wait for the thread to exit, and release system resources. #Thread::detach void detach(); Let the thread run independently of the Thread object. Once this method is called, the Thread object is useless. When the thread function exits, the system resources are automatically released.\nExample\nvoid f(); Thread(f).detach(); // run f() in a thread #Thread::join void join(); Calling this method will block until the thread function exits, and then release system resources. If the detach() method has been called before, nothing will happen when calling this method. #co::thread_id uint32 thread_id(); This function returns the id of the current thread. In the internal implementation, TLS is used to save the thread id, and each thread only needs one system call. #current_thread_id uint32 current_thread_id(); Deprecated since v2.0.2, use co::thread_id() instead. #Mutex (Mutex) Mutex is a kind of mutual exclusion lock commonly used in multithreaded programming. At the same time, at most one thread holds the lock, and other threads must wait for the lock to be released.\n#Mutex::Mutex Mutex(); Constructor, allocate system resources and initialize. #Mutex::~Mutex Mutex::~Mutex(); Destructor, release system resources. #Mutex::lock void lock(); Acquire the lock, the method will block until the lock is successfully acquired. #Mutex::try_lock bool try_lock(); Acquire the lock, will not block. If the lock is successfully acquired, it returns true, otherwise it returns false. #Mutex::unlock void unlock(); Release the lock, this method is generally called by the thread that held the lock. #MutexGuard The MutexGuard class is used to automatically acquire and release the lock in Mutex to prevent users from forgetting to release the lock.\n#MutexGuard::MutexGuard explicit MutexGuard(Mutex\u0026amp; m); explicit MutexGuard(Mutex* m); The constructor, the parameter m is a reference or pointer of the Mutex. When it is a pointer, m MUST NOT be NULL. Internally, m\u0026rsquo;s lock() method is called to acquire the lock. #MutexGuard::~MutexGuard MutexGuard::~MutexGuard(); Destructor, release the lock acquired in the constructor.\nExample\nMutex m; MutexGuard g(m); #SyncEvent SyncEvent is a synchronization mechanism between multiple threads, suitable for the producer-consumer model. The consumer calls the wait() method to wait for the synchronization signal, and the producer calls the signal() method to generate the synchronization signal. SyncEvent supports multiple producers and multiple consumers, but in actual applications, there is usually a single consumer.\n#SyncEvent::SyncEvent explicit SyncEvent(bool manual_reset = false, bool signaled = false); Constructor, the parameter manual_reset indicates whether to manually set the synchronization state to unsynchronized, and the parameter signaled indicates whether the initial state is synchronized. #SyncEvent::~SyncEvent SyncEvent::~SyncEvent(); Destructor, release system resources. #SyncEvent::reset void reset(); This method sets SyncEvent to unsynchronized state. When manual_reset is true in the constructor, the user needs to manually call this method after wait() returns, otherwise the SyncEvent may remain in a synchronized state forever. #SyncEvent::signal void signal(); This method generates a synchronization signal and sets SyncEvent to a synchronized state. #SyncEvent::wait void wait(); bool wait(uint32 ms); The first version will wait until SyncEvent becomes synchronized. The second version will wait until SyncEvent becomes synchronized or timed out. The parameter ms specifies the timeout period in milliseconds. The second version returns true when the SyncEvent becomes synchronized, and returns false when it timed out. When manual_reset is false in the constructor, SyncEvent will be automatically set to unsynchronized when wait() ends. #Code example bool manual_reset = false; SyncEvent ev(manual_reset); void f1() { if (!ev.wait(1000)) { LOG \u0026lt;\u0026lt; \u0026#34;f1: timedout..\u0026#34;; } else { LOG \u0026lt;\u0026lt; \u0026#34;f1: event signaled..\u0026#34;; if (manual_reset) ev.reset(); } } void f2() { LOG \u0026lt;\u0026lt; \u0026#34;f2: send a signal..\u0026#34;; ev.signal(); } Thread(f1).detach(); Thread(f2).detach(); #TLS-based thread_ptr template \u0026lt;typename T, typename D=std::default_delete\u0026lt;T\u0026gt;\u0026gt; class thread_ptr; The thread_ptr class is similar to std::unique_ptr, but uses the TLS mechanism internally, and each thread sets and owns its own ptr.\n#thread_ptr::thread_ptr thread_ptr(); Constructor, allocate system resources and initialize. #thread_ptr::~thread_ptr thread_ptr::~thread_ptr(); Destructor, delete the private ptr of each thread, and release TLS related system resources. #thread_ptr::get T* get() const; Return the ptr of the current thread. If the thread has not set a ptr before, this method returns NULL. #thread_ptr::operator= void operator=(T* p); Assignment, set the current thread\u0026rsquo;s ptr to p, which is equivalent to reset(p). #thread_ptr::operator-\u0026gt; T* operator-\u0026gt;() const; Overload operator-\u0026gt;, returns the ptr of the current thread. #thread_ptr::operator* T\u0026amp; operator*() const; Overload operator*, returns the reference of the object pointed to by the ptr of the current thread. #thread_ptr::operator== bool operator==(T* p) const; Determine whether the current thread\u0026rsquo;s ptr is equal to p. #thread_ptr::operator!= bool operator!=(T* p) const; Determine whether the current thread\u0026rsquo;s ptr is not equal to p. #thread_ptr::operator! bool operator!() const; Determine whether the ptr of the current thread is NULL, return true if it is NULL, otherwise return false. #thread_ptr::operator bool explicit operator bool() const; Convert thread_ptr to bool type. If the internal pointer is not NULL, return true, otherwise return false. #thread_ptr::release T* release(); Release the ptr of the current thread. This method sets the ptr of the current thread to NULL and returns the previous ptr. #thread_ptr::reset void reset(T* p = 0); Reset the ptr of the current thread to p, p is 0 by default, and the previous ptr will be deleted by D()(x). #Code example struct T { T(int v): _v(v) {} void run() { LOG \u0026lt;\u0026lt; current_thread_id() \u0026lt;\u0026lt; \u0026#34;v:\u0026#34; \u0026lt;\u0026lt; _v; } int _v; }; thread_ptr\u0026lt;T\u0026gt; pt; // Each thread will set its own pointer, and different threads will not affect each other void f(int v) { if (pt == NULL) { LOG \u0026lt;\u0026lt; \u0026#34;new T(\u0026#34; \u0026lt;\u0026lt; v \u0026lt;\u0026lt; \u0026#34;)\u0026#34;; pt.reset(new T(v)); } pt-\u0026gt;run(); } Thread(f, 1).detach(); // start thread 1 Thread(f, 2).detach(); // start thread 2 "},{"id":15,"href":"/en/co/coroutine/","title":"Coroutine","section":"Documents for CO","content":"include: co/co.h.\n#Basic concepts Coroutines are lightweight scheduling units that run in threads. Coroutines are to threads, similar to threads to processes. There can be multiple threads in a process and multiple coroutines in a thread. The thread where the coroutine runs in is generally called the scheduling thread. The scheduling thread will suspend a coroutine, if it blocks on an I/O operation or sleep was called in the coroutine. When a coroutine is suspended, the scheduling thread will switch to other coroutines waiting to be executed. Switching of coroutines is done in user mode, which is faster than switching between threads. Coroutines are very suitable for network programming, and can achieve synchronous programming without asynchronous callbacks, which greatly reduces the programmer\u0026rsquo;s mental burden.\nco implements a golang style coroutine with the following features:\nSupport multi-thread scheduling, the default number of threads is the number of system CPU cores. Coroutines in the same thread share several stacks (the default size is 1MB), and the memory usage is low. Test on Linux shows that 10 millions of coroutines only take 2.8G of memory (for reference only). Once a coroutine is created, it always runs in the same thread. There is a flat relationship between coroutines, and new coroutines can be created from anywhere (including in coroutines). The coroutine library is based on epoll, kqueue, iocp.\nThe relevant code for context switching is taken from tbox by ruki, and tbox refers to the implementation of boost, thanks here!\n#Coroutine API #APIs removed in v3.0 co::init, removed in v3.0, starting from co 3.0, we only need to call flag::init(argc, argv) at the beginning of the main function.\nco::exit, removed in v3.0.\nco::stop, removed in v3.0.\nco::all_schedulers, renamed to co::schedulers in v3.0.\n#go void go(Closure* cb); template\u0026lt;typename F\u0026gt; void go(F\u0026amp;\u0026amp; f); template\u0026lt;typename F, typename P\u0026gt; void go(F\u0026amp;\u0026amp; f, P\u0026amp;\u0026amp; p); template\u0026lt;typename F, typename T, typename P\u0026gt; void go(F\u0026amp;\u0026amp; f, T* t, P\u0026amp;\u0026amp; p); This function is used to create a coroutine, similar to creating a thread, a coroutine function must be specified.\nIn the first version, the parameter cb points to a Closure object. When the coroutine is started, the run() method of Closure will be called.\nThe 2-4th version, pack the incoming parameters into a Closure, and then call the first version.\nIn the second version, the parameter f is any runnable object, as long as we can call f() or (*f)().\nIn the third version, the parameter f is any runnable object, as long as we can call f(p), (*f)(p) or (p-\u0026gt;*f)().\nIn the fourth version, the parameter f is a method with one parameter in the class T, the parameter t is a pointer to class T, and p is the parameter of f.\nCreating object of std::function is expensive and should be used as little as possible.\nStrictly speaking, the go() function just assigns a Closure to a scheduling thread, and the actual creation of the coroutine is done by the scheduling thread. But from the user\u0026rsquo;s point of view, logically it can be considered that go() creates a coroutine.\nExample\ngo(f); // void f(); go(f, 7); // void f(int); go(\u0026amp;T::f, \u0026amp;o); // void T::f(); T o; go(\u0026amp;T::f, \u0026amp;o, 3); // void T::f(int); T o; // lambda go([](){ LOG \u0026lt;\u0026lt; \u0026#34;hello co\u0026#34;; }); // std::function std::function\u0026lt;void()\u0026gt; x(std::bind(f, 7)); go(x); go(\u0026amp;x); // Ensure that x is alive when the coroutine is running. #DEF_main This macro is used to define the main function and make code in the main function also run in coroutine. DEF_main has already called co::init(argc, argv) for initialization, and users do not need to call it again.\nExample DEF_main(argc, argv) { go([](){ LOG \u0026lt;\u0026lt; \u0026#34;hello world\u0026#34;; }); co::sleep(100); } #co::coroutine void* coroutine(); Get the current coroutine pointer. If it is not called in coroutine, the return value is NULL. The return value of this function can be passed to co::resume() to wake up the coroutine. #co::resume void resume(void* p); Wake up the specified coroutine, the parameter p is the return value of co::coroutine(). This function is thread-safe and can be called anywhere. #co::yield void yield(); Suspend the current coroutine, must be called in a coroutine. This function can be used with co::coroutine() and co::resume() to manually control the scheduling of coroutines. See test/yield.cc for details. #co::scheduler Scheduler* scheduler(); Return the scheduler pointer of the current thread. If the current thread is not a scheduling thread, the return value is NULL. This function is generally called in a coroutine to get the scheduler where it runs in. #co::schedulers const co::vector\u0026lt;Scheduler*\u0026gt;\u0026amp; schedulers(); Return a reference to the Scheduler list, one Scheduler corresponds to one scheduling thread. #co::next_scheduler Scheduler* next_scheduler(); This function returns the next Scheduler pointer.\ngo(...) is actually equivalent to co::next_scheduler()-\u0026gt;go(...).\nExample\n// create coroutines in the same thread auto s = co::next_scheduler(); s-\u0026gt;go(f1); s-\u0026gt;go(f2); #co::scheduler_num int scheduler_num(); Returns the number of schedulers. This function is usually used to implement some coroutine-safe data structures.\nExample\nco::vector\u0026lt;T\u0026gt; v(co::scheduler_num()); void f() { // get object for the current scheduler auto\u0026amp; t = v[co::scheduler_id()]; } go(f); #co::scheduler_id int scheduler_id(); Returns the scheduler id of the current thread. This value is between 0 and co::scheduler_num()-1. If the current thread is not a scheduling thread, the return value is -1. This function is generally called in the coroutine to obtain the id of the scheduler where it runs in. #co::coroutine_id int coroutine_id(); This function returns the id of the current coroutine. Different coroutines have different ids. This function is generally called in a coroutine. When called in a non-coroutine, the return value is -1. There is a simple linear correspondence between the coroutine id and the scheduler id. Assuming there are 4 schedulers, the ids are 0, 1, 2, 3, and the coroutine ids in these schedulers are: 4k (0, 4, 8, ...) 4k + 1 (1, 5, 9, ...) 4k + 2 (2, 6, 10, ...) 4k + 3 (3, 7, 11, ...) #co::sleep void sleep(uint32 ms); Let the current coroutine sleep for a while, the parameter ms is time in milliseconds. This function is generally called in a coroutine, calling in a non-coroutine is equivalent to sleep::ms(ms). #co::timeout bool timeout(); This function checks whether the previous IO operation has timed out. After users call an function like co::recv() with a timeout, they can call this function to determine whether it has timed out. This function must be called in the coroutine. #Code example // print scheduler id and coroutine id every 3 seconds void f() { while (true) { LOG \u0026lt;\u0026lt; \u0026#34;s: \u0026#34;\u0026lt;\u0026lt; co::scheduler_id() \u0026lt;\u0026lt;\u0026#34; c: \u0026#34;\u0026lt;\u0026lt; co::coroutine_id(); co::sleep(3000); } } int main(int argc, char** argv) { flag::init(argc, argv); FLG_cout = true; // also log to terminal for (int i = 0; i \u0026lt;32; ++i) go(f); while (true) sleep::sec(1024); return 0; } #Coroutineized socket API co provides commonly used coroutineized socket APIs to support coroutine-based network programming.\nMost of the APIs are consistent in form with the native socket APIs, which can reduce the user\u0026rsquo;s learning burden, and users who are familiar with socket programming can easily get started.\nMost of these APIs need to be used in coroutines. When they are blocked on I/O or sleep, the scheduling thread will suspend the current coroutine and switch to other waiting coroutines, and the scheduling thread itself will not block. With these APIs, users can easily implement high-concurrency and high-performance network programs.\n#Terminology convention Blocking\nWhen describing some socket APIs in co, the term blocking is used, such as accept, recv. The document says that they will block, which means that the current coroutine will block, but the scheduling thread will not (it can switch to other coroutines to run). From the user\u0026rsquo;s point of view, they saw the coroutines which may block. In fact, these APIs use non-blocking socket internally, which does not really block, but when there is no data to read on the socket or data cannot be written immediately, the scheduling thread will suspend the current coroutine. When the socket becomes readable or writable, the scheduling thread will awaken the coroutine again and continue the I/O operation.\nnon-blocking socket\nThe socket API in co must use non-blocking socket. On windows, socket must also support overlapped I/O, which is supported by default for sockets created with win32 API, users generally no need to worry about it. For narrative convenience, when non-blocking socket is mentioned in the document, it also means that it supports overlapped I/O on windows.\n#co::socket sock_t socket(int domain, int type, int proto); sock_t tcp_socket(int domain=AF_INET); sock_t udp_socket(int domain=AF_INET); Create a socket. The form of the first function is exactly the same as the native API. You can use man socket to see the parameter details on linux. The second function creates a TCP socket. The third function creates a UDP socket. The parameter domain is usually AF_INET or AF_INET6, the former means ipv4 and the latter means ipv6. These functions return a non-blocking socket. When an error occurs, the return value is -1, and co::error(), co::strerror() can be called to get the error message. #co::accept sock_t accept(sock_t fd, void* addr, int* addrlen); Receive the client connection on the specified socket, the parameter fd is a non-blocking socket, and the parameters addr and addrlen are used to receive the client\u0026rsquo;s address information. The initial value of *addrlen is the length of the buffer pointed to by addr. If the user does not need the client address information, addr and addrlen should be set to NULL. This function must be called in the coroutine. This function will block until a new connection comes in or an error occurs. This function returns a non-blocking socket on success, and returns -1 when an error occurs, and co::error(), co::strerror() can be called to get the error message. #co::bind int bind(sock_t fd, const void* addr, int addrlen); Bind the ip address to the socket, the parameters addr and addrlen are the address information, which is the same as the native API. This function returns 0 on success, otherwise returns -1, and co::error(), co::strerror() can be called to get the error message. #co::close int close(sock_t fd, int ms=0); Close the socket. In CO v2.0.0 or before, a socket MUST be closed in the same thread that performed the I/O operation. Since v2.0.1, a socket can be closed anywhere. When the parameter ms \u0026gt; 0, first call co::sleep(ms) to suspend the current coroutine for a period of time, and then close the socket. The EINTR signal has been processed internally in this function, and the user does not need to consider it. This function returns 0 on success, otherwise it returns -1, and co::error(), co::strerror() can be called to get the error message. #co::connect int connect(sock_t fd, const void* addr, int addrlen, int ms=-1); Create a connection to the specified address on the specified socket, the parameter fd must be non-blocking, the parameter ms is the timeout period in milliseconds, the default is -1, which will never time out. This function must be called in the coroutine. This function will block until the connection is completed, or timeout or an error occurs. This function returns 0 on success, and returns -1 on timeout or an error occurs. The user can call co::timeout() to check whether it has timed out, and co::error(), co::strerror() can be called to get the error message. #co::listen int listen(sock_t fd, int backlog=1024); Listenning on the specified socket. This function returns 0 on success, otherwise it returns -1, and co::error(), co::strerror() can be called to get the error message. #co::recv int recv(sock_t fd, void* buf, int n, int ms=-1); Receive data on the specified socket, the parameter fd must be non-blocking, the parameter buf is the buffer to receive the data, the parameter n is the buffer length, and the parameter ms is the timeout period in milliseconds, the default is -1, never time out. This function must be called in the coroutine. On Windows, this function only works with TCP-like stream socket. This function will block until any data comes in, or timeout or any error occurs. This function returns length of the data received (may be less than n) on success, returns 0 when the peer closes the connection, returns -1 when timeout or an error occurs, and users can call co::timeout() to check whether it has timed out, and co::error(), co::strerror() can be called to get the error message. #co::recvn int recvn(sock_t fd, void* buf, int n, int ms=-1); Receive data of the specified length on the specified socket, the parameter fd must be non-blocking, the parameter ms is the timeout period in milliseconds, the default is -1, never timeout. This function must be called in the coroutine. This function will block until all n bytes of data are received, or timeout or an error occurs. This function returns n on success, returns 0 when the peer closes the connection, and returns -1 when timeout or an error occurs. The user can call co::timeout() to check whether it has timed out, and co::error(), co::strerror() can be called to get the error message. #co::recvfrom int recvfrom(sock_t fd, void* buf, int n, void* src_addr, int* addrlen, int ms=-1); Similar to recv(), except that the parameters src_addr and addrlen can be used to receive the source address information. The initial value of *addrlen is the length of the buffer pointed to by src_addr. If the user does not need the source address information, addr and addrlen should be set to NULL . Generally it is recommended to use this function to receive UDP data only, for TCP data, use recv() or recvn() instead. #co::send int send(sock_t fd, const void* buf, int n, int ms=-1); Send data to the specified socket, the parameter fd must be non-blocking, the parameter ms is the timeout period in milliseconds, the default is -1, which will never time out. This function must be called in the coroutine. On Windows, this function only works with TCP-like stream socket. This function will block until all n bytes of data are sent, or timeout or an error occurs. This function returns n on success, and returns -1 on timeout or an error occurs. The user can call co::timeout() to check whether it has timed out, and co::error(), co::strerror() can be called to get the error message. #co::sendto int sendto(sock_t fd, const void* buf, int n, const void* dst_addr, int addrlen, int ms=-1); Send data to the specified address. When dst_addr is NULL and addrlen is 0, it is equivalent to send(). Generally it is recommended to use this function to send UDP data only, for TCP data, use send() instead. When fd is a UDP socket, the maximum n is 65507. #co::shutdown int shutdown(sock_t fd, char c=\u0026#39;b\u0026#39;); This function is generally used to half-close the socket. The parameter c is a hint, 'r' for read, 'w' for write, the default is 'b', which means both reading and writing are closed. It is better to call this function in the same thread that performed the I/O operation. This function returns 0 on success, otherwise it returns -1, and co::error(), co::strerror() can be called to get the error message. #co::error int\u0026amp; error(); Return the current error code. When the socket API in CO returns -1, the user can call this function to get the error code. #co::strerror const char* strerror(int err); const char* strerror(); Get the error string corresponding to the error code. It is thread safe. The second version gets the description information of the current error, which is equivalent to strerror(co::error()). #——————————— #co::getsockopt int getsockopt(sock_t fd, int lv, int opt, void* optval, int* optlen); Get socket option information, which is exactly the same as native API, man getsockopt for details. #co::setsockopt int setsockopt(sock_t fd, int lv, int opt, const void* optval, int optlen); Set the socket option information, which is exactly the same as the native API, man setsockopt for details. #co::set_nonblock void set_nonblock(sock_t fd); Set O_NONBLOCK option for the socket. #co::set_reuseaddr void set_reuseaddr(sock_t fd); Set SO_REUSEADDR option for the socket. Generally, the listening socket of a server needs to set this option, or the bind() may fail when the server restarts. #co::set_recv_buffer_size void set_recv_buffer_size(sock_t fd, int n); Set the receiving buffer size of the socket. This function must be called before the socket is connected. #co::set_send_buffer_size void set_send_buffer_size(sock_t fd, int n); Set the size of the sending buffer of the socket. This function must be called before the socket is connected. #co::set_tcp_keepalive void set_tcp_keepalive(sock_t fd); Set SO_KEEPALIVE option for the socket. #co::set_tcp_nodelay void set_tcp_nodelay(sock_t fd); Set TCP_NODELAY option for the socket. #co::reset_tcp_socket int reset_tcp_socket(sock_t fd, int ms=0); Reset a TCP connection, similar to co::close(), but the caller will not enter the TIME_WAIT state. Generally, only the server side will call this function to close a client connection without entering the TIME_WAIT state. #——————————— #co::init_ip_addr bool init_ip_addr(struct sockaddr_in* addr, const char* ip, int port); bool init_ip_addr(struct sockaddr_in6* addr, const char* ip, int port); Initialize the sockaddr structure with ip and port.\nThe first version is used for ipv4 addresses, and the second version is used for ipv6 addresses.\nExample\nunion { struct sockaddr_in v4; struct sockaddr_in6 v6; } addr; co::init_ip_addr(\u0026amp;addr.v4, \u0026#34;127.0.0.1\u0026#34;, 7777); co::init_ip_addr(\u0026amp;addr.v6, \u0026#34;::\u0026#34;, 7777); #co::ip_str fastring ip_str(const struct sockaddr_in* addr); fastring ip_str(const struct sockaddr_in6* addr); Get the ip string from the sockaddr structure.\nThe first version is used for ipv4 addresses, and the second version is used for ipv6 addresses.\nExample\nstruct sockaddr_in addr; co::init_ip_addr(\u0026amp;addr, \u0026#34;127.0.0.1\u0026#34;, 7777); auto s = co::ip_str(\u0026amp;addr); // s -\u0026gt; \u0026#34;127.0.0.1\u0026#34; #co::to_string fastring to_string(const struct sockaddr_in* addr); fastring to_string(const struct sockaddr_in6* addr); fastring to_string(const void* addr, int addrlen); Convert the sockaddr address into a string in the form of \u0026quot;ip:port\u0026quot;.\nThe first version is used for ipv4 addresses, and the second version is used for ipv6 addresses.\nThe third version calls version 1 or version 2 according to addrlen.\nExample\nstruct sockaddr_in addr; co::init_ip_addr(\u0026amp;addr, \u0026#34;127.0.0.1\u0026#34;, 7777); auto s = co::to_string(\u0026amp;addr); // s -\u0026gt; \u0026#34;127.0.0.1:7777\u0026#34; #co::peer fastring peer(sock_t fd); Get the address information of the peer. The return value is a string in the form of \u0026quot;ip:port\u0026quot;. #co::Chan co::Chan is a template class, it is similar to channel in golang, which is used to share data between coroutines.\ntemplate \u0026lt;typename T\u0026gt; class Chan; co::Chan is implemented based on memory copy. The template parameter T can be built-in type, pointer type, or structure with simple memory copy semantics for the copy operation. In short, T must meet the following condition: for two variables or objects a and b of type T, a = b is equivalent to memcpy(\u0026amp;a, \u0026amp;b, sizeof(T)). For type like std::string or STL containers, the copy operation is not a simple memory copy, so it cannot be transferred directly in the channel. #Chan::Chan explicit Chan(uint32 cap=1, uint32 ms=(uint32)-1); Chan(Chan\u0026amp;\u0026amp; c); Chan(const Chan\u0026amp; c); In the first constructor, the parameter cap is the maximum capacity of the internal queue, the default is 1, and the parameter ms is the timeout for read and write operations in milliseconds, and the default is -1, which will never time out. The second is the move constructor, and we can put co::Chan into STL containers. The third is the copy constructor, which only increases the internal reference count by 1. #operator\u0026laquo; template \u0026lt;typename T\u0026gt; void operator\u0026lt;\u0026lt;(const T\u0026amp; x) const; Write operation, it must be performed in coroutine. This method will block until the write operation is completed or timed out. co::timeout() can be called to check whether it has timed out. #operator\u0026raquo; template \u0026lt;typename T\u0026gt; void operator\u0026gt;\u0026gt;(T\u0026amp; x) const; Read operation, it must be performed in coroutine. This method will block until the read operation is completed or timed out. co::timeout() can be called to check whether it has timed out. #Code example #include \u0026#34;co/co.h\u0026#34; void f() { co::Chan\u0026lt;int\u0026gt; ch; go([ch]() {ch \u0026lt;\u0026lt; 7; }); int v = 0; ch \u0026gt;\u0026gt; v; LOG \u0026lt;\u0026lt; \u0026#34;v: \u0026#34;\u0026lt;\u0026lt; v; } void g() { co::Chan\u0026lt;int\u0026gt; ch(32, 500); go([ch]() { ch \u0026lt;\u0026lt; 7; if (co::timeout()) LOG \u0026lt;\u0026lt; \u0026#34;write to channel timeout..\u0026#34;; }); int v = 0; ch \u0026gt;\u0026gt; v; if (!co::timeout()) LOG \u0026lt;\u0026lt; \u0026#34;v: \u0026#34;\u0026lt;\u0026lt; v; } DEF_main(argc, argv) { f(); g(); return 0; } In the above code, the channel object is on the stack, so we capture by value in the lambda and copy the channel to the coroutine.\n#co::Event co::Event is a synchronization mechanism between coroutines. It is similar to SyncEvent in threads. Since co 2.0.1, co::Event can be used in both coroutines and non-coroutines.\n#Event::Event Event(); Event(Event\u0026amp;\u0026amp; e); Event(const Event\u0026amp; e); The first is the default constructor. The second is the move constructor, which supports putting co::Event into the STL container. The third is the copy constructor, which only increases the internal reference count by one. #Event::signal void signal() const; Generate a signal, and co::Event turns to synchronized state, all waiting coroutines will be awaken. If co::Event currently has no waiting coroutine, the next coroutine that calls the wait() method will return immediately. This method can be called anywhere. #Event::wait void wait() const; bool wait(unsigned int ms) const; Wait for the synchronization signal. If co::Event is currently unsynchronized, the calling coroutine will enter a waiting state. In co 2.0.0 or before, it must be called in coroutine. Since 2.0.1, it can be called anywhere. The first version will block until co::Event becomes synchronized. The second version will block until co::Event becomes synchronized or timed out. The parameter ms is the timeout period in milliseconds. It returns false when timeout, otherwise returns true. #Code example co::Event ev; // capture by value, as data on stack may be overwritten by other coroutines. go([ev](){ ev.signal(); }); ev.wait(100); // wait for 100 ms #co::WaitGroup co::WaitGroup is similar to sync.WaitGroup in golang, which can be used to wait for coroutines or threads to exit.\n#WaitGroup::WaitGroup explicit WaitGroup(uint32 n); WaitGroup(); WaitGroup(WaitGroup\u0026amp;\u0026amp; wg); WaitGroup(const WaitGroup\u0026amp; wg); In the first constructor, the internal counter is initialized as n. The second is the default constructor, the internal counter is initialized as 0. The third is the move constructor, which supports putting co::WaitGroup into STL containers. The fourth is the copy constructor, which only increases the internal reference count by one. #WaitGroup::add void add(uint32 n=1) const; Increase the internal counter by n, the default value of n is 1. It is thread-safe and can be called anywhere. #WaitGroup::done void done() const; Decrement the internal counter by 1. It is thread-safe and can be called anywhere. It is usually called at the end of coroutine or thread function. #WaitGroup::wait void wait() const; Wait until the value of the internal counter becomes 0. #Code example #include \u0026#34;co/co.h\u0026#34; DEF_main(argc, argv) { co::WaitGroup wg; wg.add(8); for (int i = 0; i \u0026lt; 8; ++i) { go([wg]() { LOG \u0026lt;\u0026lt; \u0026#34;co: \u0026#34; \u0026lt;\u0026lt; co::coroutine_id(); wg.done(); }); } wg.wait(); return 0; } #co::Mutex co::Mutex is a mutex lock for coroutines, similar to Mutex for threads, but needs to be used in coroutine environments.\n#Mutex::Mutex Mutex(); Mutex(Mutex\u0026amp;\u0026amp; m); Mutex(const Mutex\u0026amp; m); The first is the default constructor. The second is the move constructor. You can put co::Mutex into STL containers. The third is the copy constructor, which only increases the internal reference count by one. #Mutex::lock void lock() const; Acquire the lock, must be called in coroutine. It blocks until the lock is acquired. #Mutex::try_lock bool try_lock() const; Acquire the lock, will not block. It returns true when the lock is successfully acquired, otherwise it returns false. This method can be called anywhere, but it is usually called in coroutine. #Mutex::unlock void unlock() const; Release the lock, which can be called from anywhere. It is usually called in the coroutine that held the lock in a well-designed program. #co::MutexGuard #MutexGuard::MutexGuard explicit MutexGuard(co::Mutex\u0026amp; m); explicit MutexGuard(co::Mutex* m); Constructor, call m.lock() to acquire the lock, the parameter m is a reference or pointer of the co::Mutex. #MutexGuard::~MutexGuard ~MutexGuard(); Destructor, release the lock acquired in the constructor. #Code example co::Mutex mtx; int v = 0; void f1() { co::MutexGuard g(mtx); ++v; } void f2() { co::MutexGuard g(mtx); --v; } go(f1); go(f2); #co::Pool co::Pool is a general coroutine pool, which is coroutine safe. It stores pointers of type void* internally, which can be used as connection pool, memory pool or cache for other purposes.\n#Pool::Pool Pool(); Pool(Pool\u0026amp;\u0026amp; p); Pool(const Pool\u0026amp; p); Pool(std::function\u0026lt;void*()\u0026gt;\u0026amp;\u0026amp; ccb, std::function\u0026lt;void(void*)\u0026gt;\u0026amp;\u0026amp; dcb, size_t cap=(size_t)-1); The first is the default constructor. Compared with the 4th version, ccb and dcb are NULL.\nThe second is the move constructor.\nThe third is the copy constructor, which only increases the internal reference count by one.\nIn the 4th version, the parameter ccb is used to create an element, and dcb is used to destroy an element. The parameter cap specifies the maximum capacity of the pool, and the default is -1 for unlimited.\nNote that the parameter cap is not the total capacity, but for a single thread. If cap is set to 1024 and there are 8 scheduling threads, the total capacity is 8192. In addition, when dcb is NULL, cap will be ignored. This is because when the number of elements exceeds the maximum capacity, co::Pool needs to call dcb to destroy the extra elements.\nExample\nclass T; co::Pool p( []() {return (void*) new T; }, // ccb [](void* p) {delete (T*) p;} // dcb ); #Pool::clear void clear() const; Clear all pools in co::Pool, it can be called anywhere. If dcb is set, it will be used to destroy the elements in co::Pool. #Pool::pop void* pop() const; Pop an element from co::Pool, it must be called in coroutine. When co::Pool is empty, if ccb is not NULL, call ccb() to create an element, otherwise it will return NULL. This method is coroutine safe, and we do not need a lock here. #Pool::push void push(void* e) const; Push an element to co::Pool, it must be called in coroutine.\nIf e is NULL, it will be ignored.\nAs each thread has its own pool, push() should be called in the same thread that calls pop().\nIf co::Pool has reached the maximum capacity, and dcb is not NULL, dcb(e) will be called to destroy the element.\nThis method is coroutine safe, and we do not need a lock here.\nExample\nclass Redis; // assume class Redis is a connection to the redis server co::Pool p; void f { Redis* rds = (Redis*) p.pop(); // pop a redis connection if (rds == NULL) rds = new Redis; rds-\u0026gt;get(\u0026#34;xx\u0026#34;); // call get() method of redis p.push(rds); // push rds back to co::Pool } go(f); #Pool::size size_t size() const; Returns size of the pool for the current thread. It must be called in coroutine. #co::PoolGuard co::PoolGuard pops an element from co::Pool during construction, and puts it back during destruction. At the same time, it also overloads operator-\u0026gt;, so we can use it like a smart pointer.\ntemplate\u0026lt;typename T, typename D=std::default_delete\u0026lt;T\u0026gt;\u0026gt; class PoolGuard; The parameter T is the actual type pointed to by pointers in co::Pool, and the parameter D is the deleter, which is used to delete a pointer of type T*. #PoolGuard::PoolGuard explicit PoolGuard(co::Pool\u0026amp; p); explicit PoolGuard(co::Pool* p); Constructor, pop an element from co::Pool. #PoolGuard::~PoolGuard ~PoolGuard(); Destructor, push the element back into co::Pool. #PoolGuard::get T* get() const; Get the pointer popped from co::Pool in the constructor. #PoolGuard::operator-\u0026gt; T* operator-\u0026gt;() const; Overload operator-\u0026gt;, returns the pointer popped from co::Pool in the constructor. #PoolGuard::operator* T\u0026amp; operator*() const; Overload operator*, returns a reference of object of type T. #PoolGuard::operator bool explicit operator bool() const; Convert co::PoolGuard to bool type, if the internal pointer is not NULL, returns true, otherwise returns false. #PoolGuard::operator! bool operator!() const; Check whether the internal pointer is NULL, return true if it is NULL, otherwise returns false. #PoolGuard::operator== bool operator==(T* p) const; Check whether the internal pointer is equal to p. #PoolGuard::operator!= bool operator!=(T* p) const; Check whether the internal pointer is not equal to p. #PoolGuard::operator= void operator=(T* p); Assignment, equivalent to reset(p). #PoolGuard::reset void reset(T* p = 0); Reset the internal pointer, and call D()(x) to delete the original pointer. #Code example class Redis; // assume class Redis is a connection to the redis server co::Pool p( []() {return (void*) new Redis; }, // ccb [](void* p) {delete (Redis*) p;} // dcb ); void f() { co::PoolGuard\u0026lt;Redis\u0026gt; rds(p); // now rds can be used like a Redis* pointer. rds-\u0026gt;get(\u0026#34;xx\u0026#34;); } go(f); #co::IoEvent co::IoEvent is used to convert non-blocking I/O to synchronous mode. When users perform an I/O operation on a non-blocking socket in coroutine, and the socket is unreadable or unwritable, users call the wait() method of co::IoEvent wait for I/O events on the socket, and the coroutine is suspended. When the socket becomes readable or writable, the scheduling thread will resume the coroutine again and continue the I/O operation.\nco 1.x does not expose the co::IoEvent, as it is only used internally. This class is public in co 2.0, which is convenient for users to coroutineize third-party network libraries.\n#co::io_event_t enum io_event_t { ev_read = 1, ev_write = 2, }; enum type, which means I/O event type, co::ev_read for read, and co::ev_write for write. #IoEvent::IoEvent IoEvent(sock_t fd, io_event_t ev); IoEvent(sock_t fd, int n=0); // for windows only Constructor, linux and mac platforms only provide the first version, windows platform also provides the second version. In the first version, the parameter fd is a non-blocking socket, and the parameter ev is an I/O event, which is one of co::ev_read or co::ev_write. Calling the wait() method will wait for the I/O event specified by ev on the socket. When wait() returns successfully, users need to call recv, send or other I/O functions to complete the I/O operation. On windows, fd must be a TCP socket(For UDP, it is difficult to simulate the behavior of epoll or kqueue with IOCP). The second version is only applicable to windows. Unlike the first version, fd can be a UDP socket, but users must manually call WSARecvFrom, WSASendTo or other functions to post an overlapped I/O operation to IOCP, and then call the wait() method. When wait() returns successfully, it means that IOCP has completed the I/O operation. See details in source code of co::IoEvent, and implementation of co::accept, co::connect, co::recvfrom, co::sendto on windows. #IoEvent::~IoEvent ~IoEvent(); Destructor, remove previously registered I/O events from epoll or kqueue. #IoEvent::wait bool wait(int ms=-1); This method waits for I/O events on the socket. The parameter ms is the timeout in milliseconds, the default is -1, which will never time out. This method blocks until the I/O event arrives, or timeout or an error occurs. This method returns true on success, and returns false when timeout or an error occurs. co::timeout() can be called to check whether it has timed out. #Code example int recv(sock_t fd, void* buf, int n, int ms) { CHECK(gSched) \u0026lt;\u0026lt; \u0026#34;must be called in coroutine..\u0026#34;; co::IoEvent ev(fd, co::ev_read); do { int r = (int) CO_RAW_API(recv)(fd, buf, n, 0); if (r != -1) return r; if (errno == EWOULDBLOCK || errno == EAGAIN) { if (!ev.wait(ms)) return -1; } else if (errno != EINTR) { return -1; } } while (true); } The above example is the implementation of co::recv. When the native recv() generates an EWOULDBLOCK or EAGAIN error, use co::IoEvent to wait for the read event. When wait() returns normally, the socket is readable, continue to call the native recv() to complete the read operation .\n#Use third-party network libraries in coroutine When a third-party network library is used directly in coroutine, it may block the scheduling thread and the scheduling thread will not work normally. There are two ways to solve this problem. The first is to coroutineize third-party libraries, and the second is to hook the system socket APIs.\n#Coroutineization Coroutineization requires third-party libraries to provide non-blocking APIs.\nint recv(SSL* s, void* buf, int n, int ms) { CHECK(co::scheduler()) \u0026lt;\u0026lt; \u0026#34;must be called in coroutine..\u0026#34;; int r, e; int fd = SSL_get_fd(s); if (fd \u0026lt;0) return -1; do { ERR_clear_error(); r = SSL_read(s, buf, n); if (r \u0026gt; 0) return r; // success if (r == 0) { DLOG \u0026lt;\u0026lt; \u0026#34;SSL_read return 0, error: \u0026#34;\u0026lt;\u0026lt; SSL_get_error(s, 0); return 0; } e = SSL_get_error(s, r); if (e == SSL_ERROR_WANT_READ) { co::IoEvent ev(fd, co::ev_read); if (!ev.wait(ms)) return -1; } else if (e == SSL_ERROR_WANT_WRITE) { co::IoEvent ev(fd, co::ev_write); if (!ev.wait(ms)) return -1; } else { DLOG \u0026lt;\u0026lt; \u0026#34;SSL_read return \u0026#34;\u0026lt;\u0026lt; r \u0026lt;\u0026lt; \u0026#34;, error:\u0026#34; \u0026lt;\u0026lt; e; return r; } } while (true); } The above is an example of coroutineizing SSL_read in openssl. The whole process is relatively simple. The underlying socket must be non-blocking. When SSL_read generates a SSL_ERROR_WANT_READ error, use co::IoEvent to wait for the read event, and when an SSL_ERROR_WANT_WRITE error occurs, use co::IoEvent to wait for the write event. When wait() returns normally, it means that the socket is readable or writable, continue to call SSL_read to complete the I/O operation.\nAt present, CO has successfully coroutineized openssl and libcurl. In theory, all third-party network libraries that provide non-blocking APIs can be coroutineized in a similar way to the above.\n#System API hook API hook is simply to intercept the system API call. If an API is called in coroutine and a blocking socket is used, the socket is modified to non-blocking mode, and then co::IoEvent or the lower-level interface of CO is used to wait for the I/O event on the socket. When an I/O event arrives, wake up the coroutine to continue the I/O operation.\nSince CO 2.0.1, hook has been supported on Linux, Mac and Windows.\nThe advantage of API hook is that, we only need to hook a small number of system socket APIs, and we can use all third-party libraries that provide blocking APIs in coroutine.\nHowever, coroutineization needs to provide a set of coroutineized APIs for each third-party library, but it has better performance and is safer, and can avoid some problems caused by the complexity of the third-party library.\n#Network programming model based on coroutine It is easy to write high-concurrency and high-performance network programs with coroutine. Although a coroutine may block, the scheduling thread can quickly switch between a large number of coroutines. Therefore, to achieve high concurrency, we just need to create more coroutines.\n#Network model for TCP server // recv or send data on the connection void on_connection(int fd) { while (true) { co::recv(fd, ...); // recv request from client process(...); // process the request co::send(fd, ...); // send response to client } } void server_fun() { while (true) { int fd = co::accept(...); if (fd != -1) go(on_connection, fd); } } go(server_fun); One coroutine for each connection. In one coroutine, call co::accept() to accept client connections. When a connection is accepted, create a new coroutine to handle the connection. on_connection() is the coroutine function for handling connections, receiving, processing and sending data are performed in a synchronous manner in the coroutine, and we do not need any asynchronous callback. For complete implementation, please refer to Test code in CO. #Network model for TCP client void client_fun() { while true { if (!connected) co::connect(...); // connect to the server co::send(...); // send request to the server co::recv(...); // recv response from the server process(...); // process the response if (over) co::close(...); // close the connection } } go(client_fun); Connecting, sending, recving and processing data are performed in a synchronous manner in the coroutine.\nFor complete implementation, please refer to Test code in CO.\nIn actual applications, co::Pool is generally used as a connection pool to avoid creating too many connections:\nco::Pool pool; void client_fun() { while true { co::PoolGuard\u0026lt;Connection\u0026gt; conn(pool); // get a idle connection from the pool conn-\u0026gt;send(...); // send request to the server conn-\u0026gt;recv(...); // recv response from the server process(...); // process the response if (over) conn-\u0026gt;close(...); // close the connection } } go(client_fun); co::PoolGuard pops an idle connection from co::Pool during construction, and push it back during destruction. #Configuration #co_debug_log DEF_bool(co_debug_log, false, \u0026#34;#1 enable debug log for coroutine library\u0026#34;); Print debug logs for coroutine, the default is false. #co_sched_num DEF_uint32(co_sched_num, os::cpunum(), \u0026#34;#1 number of coroutine schedulers, default: os::cpunum()\u0026#34;); The number of scheduling threads, the default is the number of system CPU cores. In the current implementation, the largest value is also the number of system CPU cores. #co_stack_size DEF_uint32(co_stack_size, 1024 * 1024, \u0026#34;#1 size of the stack shared by coroutines, default: 1M\u0026#34;); The size of the coroutine stack, the default is 1M. #disable_hook_sleep DEF_bool(disable_hook_sleep, false, \u0026#34;#1 disable hook sleep if true\u0026#34;); Disable hook for sleep related APIs, the default is false. #hook_log DEF_bool(hook_log, false, \u0026#34;#1 enable log for hook if true\u0026#34;); Print logs for hook, the default is false. "},{"id":16,"href":"/en/co/net/byte_order/","title":"Byte order","section":"Network Programming","content":"include: co/byte_order.h.\nData in the computer is stored in bytes (8 bit). Big-endian computers use big-endian byte order, that is, the high-order byte is at the lower address, and the low-order byte is at the higher address. The little-endian machine uses little-endian byte order, that is, the low-order byte is at the lower address, and the high-order byte is at the higher address.\nA single byte is exactly the same on big endian and little endian machines, while the basic data types of multiple bytes have are different. The basic data types mentioned here refer to built-in types like int, double. String is not included here, as it is a sequence of single byte and have the same storage format on big or little endian machines.\nThe data transmitted on network is in big-endian byte order, which is also called network byte order. When sending data to the network, the basic multi-byte type needs to be converted into network byte order, and when receiving data from the network, it needs to be converted into the byte order of the host.\nbyte_order.h defines the following methods:\nntoh16 ntoh32 ntoh64 hton16 hton32 hton64 These methods are applicable to integers with lengths of 2, 4, and 8 bytes. The ntoh series converts network byte order to host byte order, and the hton series converts host byte order to network byte order. .\nCode example uint32 h = 777; uint32 n = hton32(h); "},{"id":17,"href":"/en/co/net/tcp/","title":"TCP","section":"Network Programming","content":"include: co/tcp.h.\n#tcp::Connection tcp::Connection is a simple encapsulation of TCP connection, it is designed for TCP server. When SSL is enabled in a TCP server, tcp::Connection will transfer data by SSL.\n#Connection::Connection Connection(int sock); Connection(void* ssl); Connection(Connection\u0026amp;\u0026amp; c); The constructor, Connection is created by tcp::Server, users do not need to create it manually. The first version constructs a normal TCP connection, the second version constructs a TCP connection that support SSL, and the third is a move constructor. #Connection::~Connection Connection::~Connection(); Destructor, call close() to close the connection. #Connection::close int close(int ms = 0); Close the connection. When the parameter ms \u0026gt; 0, close the connection after a certain delay. Since v2.0.1, this method can be called anywhere(in coroutine or non-coroutine). #Connection::recv int recv(void* buf, int n, int ms=-1); Receive data, similar to co::recv. This method must be called in the coroutine. Return \u0026gt; 0 on success, \u0026lt; 0 on timeout or any error, and 0 will be returned if the peer closed the connection. #Connection::recvn int recvn(void* buf, int n, int ms=-1); Receive data of specified length, similar to co::recvn. Return n on success, \u0026lt; 0 on timeout or any error, and 0 will be returned if the peer closed the connection. #Connection::reset int reset(int ms = 0) Reset the TCP connection, unlike close(), it will not enter the TIME_WAIT state. When the parameter ms \u0026gt; 0, the connection will be reset after a certain delay. This method must be called in the I/O thread (usually a coroutine that performs the I/O operations). #Connection::send int send(const void* buf, int n, int ms=-1); Send data, similar to co::send(). return n on success, \u0026lt;= 0 on timeout or error. #Connection::socket int socket() const; Return the internal socket descriptor, -1 will be returned if the connection was closed. #Connection::strerror const char* strerror() const; When an error occurs in a method of Connection, the user can call this method to get the error message. #tcp::Server tcp::Server is a TCP server based on coroutine. It has the following features:\nSupport IPv4 and IPv6. Support SSL (openssl is required). One coroutine for each client connection. #Server::Server Server(); The constructor, initialization. #Server::conn_num uint32 conn_num() const; Returns number of client connections. #Server::on_connection Server\u0026amp; on_connection(std::function\u0026lt;void(Connection)\u0026gt;\u0026amp;\u0026amp; f); Server\u0026amp; on_connection(const std::function\u0026lt;void(Connection)\u0026gt;\u0026amp; f); template\u0026lt;typename T\u0026gt; Server\u0026amp; on_connection(void (T::*f)(Connection), T* o); Set a callback for handling connections.\nIn the first 2 versions, the parameter f is a function of type void f(Connection), or a function object of type std::function\u0026lt;void(Connection)\u0026gt;.\nIn the third version, the parameter f is a method in the class T, and the parameter o is a pointer to type T.\nSince v2.0.2, the parameter of f is an object of tcp::Connection, rather than a pointer, and users do not need to delete it any more.\nWhen the server receives a connection, it will create a new coroutine and call the callback set by this method in the coroutine to handle the connection.\nExample\nvoid f(tcp::Connection conn); tcp::Server s; s.on_connection(f); void f(tcp::Connection conn) { while (true) { conn.recv(...); process(...); conn.send(...); } conn.close(); } #Server::on_exit Server\u0026amp; on_exit(std::function\u0026lt;void()\u0026gt;\u0026amp;\u0026amp; cb); Set a callback which will be called when the server exits. #Server::start void start(const char* ip, int port, const char* key=0, const char* ca=0); Start the TCP server, this method will not block the current thread.\nThe parameter ip is the server ip, which can be an IPv4 or IPv6 address, and the parameter port is the server port.\nThe parameter key is path of a PEM file which stores the SSL private key, and the parameter ca is path of a PEM file which stores the SSL certificate. They are NULL by default, and SSL is disabled.\nStarting from v3.0, the server no longer depends on the tcp::Server object after it is started.\nExample\nvoid f(tcp::Connection conn); tcp::Server().on_connection(f).start(\u0026#34;0.0.0.0\u0026#34;, 7788); #Server::exit void exit(); Added since v2.0.2. Exit the TCP server, close the listening socket, and no longer receive new connections. This method will not close the connections that has been established before. If you need to close the previously established connections after the server exits, you can refer to test/tcp2.cc or implementations of http::Server and rpc::Server in co. #tcp::Client tcp::Client is a TCP client based on coroutine. It has following features:\nSupport IPv4 and IPv6. Support SSL (openssl is required). One client corresponds to one connection. It must be used in coroutine. It is not coroutine-safe, and it cannot be used by multiple coroutines at the same time. #Client::Client Client(const char* ip, int port, bool use_ssl=false); Client(const Client\u0026amp; c); Constructor. The parameter ip is the ip of the server, which can be a domain name, or an IPv4 or IPv6 address; the parameter port is the server port; the parameter use_ssl indicates whether to enable SSL transmission, the default is false, and SSL is not enabled. The second version is the copy constructor, value of ip, port and use_ssl will be copied from another client. The connection is not established in the constructor. It is generally recommended to check whether the connection has been established before calling recv, send. If not, call the connect() method to establish the connection. It is easy to support auto-reconnection in this way. #Client::~Client Client::~Client(); Destructor, call the disconnect() method to close the connection. #Client::close void close(); Close the connection, same as disconnect(). #Client::connect bool connect(int ms); Establish a connection, the parameter ms is the timeout period in milliseconds. This method must be called in the coroutine. This method returns true on success, otherwise it returns false. When it fails, the user can use the strerror() method to get the error message. #Client::connected bool connected() const; Determine whether the connection has been established. #Client::disconnect void disconnect(); Since v2.0.1, it can be called anywhere(in coroutine or non-coroutine). It is safe to call this method multiple times, and it will be called automatically in the destructor. #Client::recv int recv(void* buf, int n, int ms=-1); Receive data, similar to co::recv(). This method must be called in the coroutine. Return \u0026gt; 0 on success, \u0026lt; 0 on timeout or any error, and 0 will be returned if the peer closed the connection. #Client::recvn int recvn(void* buf, int n, int ms=-1); Receive data of specified length, similar to co::recvn(). This method must be called in the coroutine. Return n on success, \u0026lt; 0 on timeout or any error, and 0 will be returned if the peer closed the connection. #Client::send int send(const void* buf, int n, int ms=-1); Send data, similar to co::send(). This method must be called in the coroutine. return n on success, \u0026lt;= 0 on timeout or error. #Client::socket int socket() const; Return the internal socket descriptor. When the connection is not established or the connection has been closed, the return value is -1. #Client::strerror const char* strerror() const; When an error occurs in a method of tcp::Client, the user can call this method to get the error message. #TCP server example void on_connection(tcp::Connection conn) { char buf[8] = { 0 }; while (true) { int r = conn.recv(buf, 8); if (r == 0) { /* client close the connection */ conn.close(); break; } else if (r \u0026lt; 0) { /* error */ conn.reset(3000); break; } else { LOG \u0026lt;\u0026lt; \u0026#34;server recv \u0026#34; \u0026lt;\u0026lt; fastring(buf, r); LOG \u0026lt;\u0026lt; \u0026#34;server send pong\u0026#34;; r = conn.send(\u0026#34;pong\u0026#34;, 4); if (r \u0026lt;= 0) { LOG \u0026lt;\u0026lt; \u0026#34;server send error: \u0026#34; \u0026lt;\u0026lt; conn.strerror(); conn.reset(3000); break; } } } } tcp::Server s; s.on_connection(on_connection); s.start(\u0026#34;0.0.0.0\u0026#34;, 7788); // no ssl s.start(\u0026#34;0.0.0.0\u0026#34;, 7788, \u0026#34;privkey.pem\u0026#34;, \u0026#34;certificate.pem\u0026#34;); // use ssl The above example implements a simple ping-pong server, when it receives a ping sent by the client, it will reply with a pong. #TCP client code example bool use_ssl = false; std::unique_ptr\u0026lt;tcp::Client\u0026gt; proto; co::Pool pool( []() {return (void*) new tcp::Client(*proto); }, [](void* p) {delete (tcp::Client*) p;} ); void client_fun() { co::PoolGuard\u0026lt;tcp::Client\u0026gt; c(pool); if (!c-\u0026gt;connect(3000)) { LOG \u0026lt;\u0026lt; \u0026#34;connect failed: \u0026#34;\u0026lt;\u0026lt; c-\u0026gt;strerror(); return; } char buf[8] = {0 }; while (true) { LOG \u0026lt;\u0026lt; \u0026#34;client send ping\u0026#34;; int r = c-\u0026gt;send(\u0026#34;ping\u0026#34;, 4); if (r \u0026lt;= 0) { LOG \u0026lt;\u0026lt; \u0026#34;client send error: \u0026#34;\u0026lt;\u0026lt; c-\u0026gt;strerror(); break; } r = c-\u0026gt;recv(buf, 8); if (r \u0026lt; 0) { LOG \u0026lt;\u0026lt; \u0026#34;client recv error: \u0026#34;\u0026lt;\u0026lt; c-\u0026gt;strerror(); break; } else if (r == 0) { LOG \u0026lt;\u0026lt; \u0026#34;server close the connection\u0026#34;; break; } else { LOG \u0026lt;\u0026lt; \u0026#34;client recv \u0026#34;\u0026lt;\u0026lt; fastring(buf, r) \u0026lt;\u0026lt;\u0026#39;\\n\u0026#39;; co::sleep(3000); } } } proto.reset(new tcp::Client(\u0026#34;127.0.0.1\u0026#34;, 7788, use_ssl)); for (int i = 0; i \u0026lt;8; ++i) { go(client_fun); } In the above example, we use co::Pool to cache client connections, and different coroutines can share connections in co::Pool. co::PoolGuard automatically pop an idle connection from co::Pool during construction, and automatically puts the connection back into co::Pool during destruction. "},{"id":18,"href":"/en/co/net/http/","title":"HTTP","section":"Network Programming","content":"include: co/http.h.\n#http::Client http::Client is a coroutine-based http client, which is implemented based on libcurl.\n#Client::Client explicit Client(const char* serv_url); Constructor, the parameter serv_url is the url address of the server, and its form is protocol://host:port, the following server urls are all ok: \u0026ldquo;github.com\u0026rdquo; \u0026ldquo;https://github.com\u0026rdquo; \u0026ldquo;http://127.0.0.1:7788\u0026rdquo; \u0026ldquo;http://[::1]:8888\u0026rdquo; Like the tcp::Client, connection is not established in the constructor. #Client::~Client Client::~Client(); Destructor, close the connection, and release libcurl related resources. #Client::add_header void add_header(const char* key, const char* val); void add_header(const char* key, int val); Add a HTTP header. Users can use this method to add headers before performing HTTP requests, and the added headers will be present in all subsequent requests. In the second version, the parameter val is an integer, which is automatically converted into a string internally. #Client::body const fastring\u0026amp; body() const; Get the response body of the current HTTP request. #Client::close void close(); Close the HTTP connection, must be called in the coroutine. Once this method is called, the http::Client object can no longer be used until you reset the server url by calling reset(). #Client::del void del(const char* url, const char* s, size_t n); void del(const char* url, const char* s); void del(const char* url); HTTP DELETE request, must be called in the coroutine. The parameter url must be a string beginning with '/'. The first two versions are suitable for DELETE requests with a body, and parameter s is a pointer to the body data. The third version is for DELETE requests without body. #Client::easy_handle void* easy_handle() const; Return the easy handle of libcurl. #Client::get void get(const char* url); HTTP GET request, must be called in the coroutine. The parameter url must be a string beginning with '/'. #Client::head void head(const char* url); HTTP HEAD request, must be called in the coroutine. The parameter url must be a string beginning with '/'. #Client::header const char* header(const char* key); const fastring\u0026amp; header() const; The first version gets value of a HTTP header. If the header does not exist, an empty string is returned.\nThe second version gets the entire HTTP header part.\nExample\nhttp::Client c(\u0026#34;xx.com\u0026#34;); c.get(\u0026#34;/\u0026#34;); auto s = c.header(\u0026#34;Content-Length\u0026#34;); #Client::perform void perform(); Perform a HTTP request, get, post and other methods are actually implemented based on this method.\nUsers generally don\u0026rsquo;t need to call this method. Only when the get, post and other methods provided by http::Client can\u0026rsquo;t meet their needs, should they consider using this method to customize HTTP requests.\nExample\nvoid Client::post(const char* url, const char* data, size_t size) { curl_easy_setopt(_ctx-\u0026gt;easy, CURLOPT_POST, 1L); curl_easy_setopt(_ctx-\u0026gt;easy, CURLOPT_URL, make_url(url)); curl_easy_setopt(_ctx-\u0026gt;easy, CURLOPT_POSTFIELDS, data); curl_easy_setopt(_ctx-\u0026gt;easy, CURLOPT_POSTFIELDSIZE, (long)size); this-\u0026gt;perform(); } #Client::post void post(const char* url, const char* s, size_t n); void post(const char* url, const char* s); HTTP POST request, must be called in the coroutine. The parameter url must be a string beginning with '/'. #Client::put void put(const char* url, const char* path); HTTP PUT request, used to upload a file, must be called in the coroutine. The parameter url must be a string beginning with '/'. The parameter path is path of the file to be uploaded. #Client::remove_header void remove_header(const char* key); The headers added by add_header() method will apply to all subsequent HTTP requests. If the user does not want a header to appear in a subsequent request, this method can be used to remove the header. #Client::response_code int response_code() const; Get the response code of the current HTTP request. Normally, the return value is a value between 100 and 511. If the HTTP request is not sent due to network error or other reasons, or no response from the server was received within the timeout period, this method returns 0. #Client::status int status() const; Equal to response_code(). #Client::strerror const char* strerror() const; Get the error information of the current HTTP request. #Example void f() { http::Client c(\u0026#34;https://github.com\u0026#34;); int r; c.get(\u0026#34;/\u0026#34;); r = c.status(); LOG \u0026lt;\u0026lt; \u0026#34;staus: \u0026#34; \u0026lt;\u0026lt; r; LOG_IF(r == 0) \u0026lt;\u0026lt; \u0026#34;error: \u0026#34; \u0026lt;\u0026lt; c.strerror(); LOG \u0026lt;\u0026lt; \u0026#34;body size: \u0026#34; \u0026lt;\u0026lt; c.body().size(); LOG \u0026lt;\u0026lt; c.header(); c.get(\u0026#34;/idealvin/co\u0026#34;); LOG \u0026lt;\u0026lt; \u0026#34;body size: \u0026#34; \u0026lt;\u0026lt; c.body().size(); LOG \u0026lt;\u0026lt; \u0026#34;Content-Length: \u0026#34; \u0026lt;\u0026lt; c.header(\u0026#34;Content-Length\u0026#34;); LOG \u0026lt;\u0026lt; c.header(); c.close(); } go(f); #http::Req http::Req is an encapsulation of HTTP request, it is used in http::Server.\n#Req::Req Req() = default; Default constructor. #Req::body const char* body() const; Get the body data in the HTTP request. It returns a pointer, not null-terminated. Users need call body_size() to get its length. #Req::body_size size_t body_size() const; Returns the length of the HTTP request body. #Req::header const char* header(const char* key) const; Get value of a HTTP header. If the header does not exist, an empty string is returned. #Req::is_method_xxx bool is_method_get() const; bool is_method_head() const; bool is_method_post() const; bool is_method_put() const; bool is_method_delete() const; bool is_method_options() const; Determine the method type of the HTTP request. #Req::method Method method() const; Returns the HTTP request method, the return value is one of kGet, kHead, kPost, kPut, kDelete, kOptions. #Req::url const fastring\u0026amp; url() const; Returns a reference to the url in the HTTP request. This value is part of the start line of the HTTP request. #Req::version Version version() const; Returns the HTTP version in the HTTP request. The return value is one of http::kHTTP10 or http::kHTTP11. Currently, HTTP/2.0 is not supported. #http::Res http::Res class is the encapsulation of HTTP response, it is used in http::Server.\n#Res::Res Res(); Default constructor. #Res::add_header void add_header(const char* key, const char* val); void add_header(const char* key, int val); Add a HTTP header. #Res::set_body void set_body(const void* s, size_t n); void set_body(const char* s); void set_body(const fastring\u0026amp; s); Set the body part of the HTTP response. The parameter s is the body data, and the parameter n is the length of s. In the second version, s ends with '\\0'. #Res::set_status void set_status(int status); Set the HTTP response code, this value is generally between 100 and 511. #http::Server http::Server is a coroutine-based HTTP server. It supports HTTPS. To use HTTPS, you need to install openssl first.\n#Server::Server Server(); The default constructor, users don\u0026rsquo;t need to care. #Server::on_req Server\u0026amp; on_req(std::function\u0026lt;void(const Req\u0026amp;, Res\u0026amp;)\u0026gt;\u0026amp;\u0026amp; f); Server\u0026amp; on_req(const std::function\u0026lt;void(const Req\u0026amp;, Res\u0026amp;)\u0026gt;\u0026amp; f) template\u0026lt;typename T\u0026gt; Server\u0026amp; on_req(void (T::*f)(const Req\u0026amp;, Res\u0026amp;), T* o); Set a callback for processing a HTTP request. In the third version, the parameter f is a method in class T, and the parameter o is a pointer to type T. When the server receives an HTTP request, it will call the callback set by this method to process the request. #Server::start void start(const char* ip=\u0026#34;0.0.0.0\u0026#34;, int port=80); void start(const char* ip, int port, const char* key, const char* ca); Start the HTTP server, this method will not block the current thread. The parameter ip is the server ip, which can be an IPv4 or IPv6 address, and the parameter port is the server port. The parameter key is path of a PEM file which stores the SSL private key, and the parameter ca is path of a PEM file which stores the SSL certificate. If key or ca is NULL or empty string, SSL will be disabled. Starting from v3.0, the server no longer depends on the http::Server object after startup. #Server::exit void exit(); Added since v2.0.2. Exit the HTTP server, close the listening socket, and no longer receive new connections. Since v3.0, after the HTTP server exits, previously established connections will be reset in the future. #Example void cb(const http::Req\u0026amp; req, http::Res\u0026amp; res) { if (req.is_method_get()) { if (req.url() == \u0026#34;/hello\u0026#34;) { res.set_status(200); res.set_body(\u0026#34;hello world\u0026#34;); } else { res.set_status(404); } } else { res.set_status(405); // method not allowed } } // http http::Server().on_req(cb).start(\u0026#34;0.0.0.0\u0026#34;, 80); // https http::Server().on_req(cb).start( \u0026#34;0.0.0.0\u0026#34;, 443, \u0026#34;privkey.pem\u0026#34;, \u0026#34;certificate.pem\u0026#34; ); There is a simple http::Server demo in co/test, the user can build and run it like this:\nxmake -b http_serv xmake r http_serv After starting the http server, you can enter 127.0.0.1/hello in the address bar of the browser to see the result.\n#Static web server (so::easy) void easy(const char* root_dir=\u0026#34;.\u0026#34;, const char* ip=\u0026#34;0.0.0.0\u0026#34;, int port=80); void easy(const char* root_dir, const char* ip, int port, const char* key, const char* ca); Start a static web server, the parameter root_dir is the root directory of the web server.\nThe parameter ip can be an IPv4 or IPv6 address.\nThe second version supports HTTPS, the parameter key is the SSL private key, the parameter ca is the SSL certificate, and both key and ca are files in pem format.\nWhen key or ca is NULL or an empty string, HTTPS is not used.\nThis method will block the current thread.\nExample\n#include \u0026#34;co/flag.h\u0026#34; #include \u0026#34;co/http.h\u0026#34; DEF_string(d, \u0026#34;.\u0026#34;, \u0026#34;root dir\u0026#34;); // root dir of web server int main(int argc, char** argv) { flag::init(argc, argv); so::easy(FLG_d.c_str()); // mum never have to worry again return 0; } #Config items co/http uses co/flag to define config items. The flags defined in co/http are listed below.\n#http_conn_timeout DEF_uint32(http_conn_timeout, 3000, \u0026#34;#2 connect timeout in ms for http client\u0026#34;); Connect timeout in milliseconds for http::Client. #http_timeout DEF_uint32(http_timeout, 3000, \u0026#34;#2 send or recv timeout in ms for http client\u0026#34;); Receive and send timeout (libcurl does not distinguish between receive and send timeout) in milliseconds for http::Client. #http_recv_timeout DEF_uint32(http_recv_timeout, 3000, \u0026#34;#2 recv timeout in ms for http server\u0026#34;); Recv timeout in milliseconds for http::Server. #http_send_timeout DEF_uint32(http_send_timeout, 3000, \u0026#34;#2 send timeout in ms for http server\u0026#34;); Send timeout in milliseconds for http::Server. #http_conn_idle_sec DEF_uint32(http_conn_idle_sec, 180, \u0026#34;#2 http server may close the con...\u0026#34;); Timeout in seconds for http::Server to keep an idle connection. If the server does not receive data from the client within this time, it may close the connection. #http_log DEF_bool(http_log, true, \u0026#34;#2 enable http server log if true\u0026#34;); For http::Server, whether to print logs, the default is true. The log in http::Server will print the header part of HTTP request and response. #http_max_idle_conn DEF_uint32(http_max_idle_conn, 128, \u0026#34;#2 max idle connections for http server\u0026#34;); For http::Server, maximum number of idle connections. When this number is exceeded, some idle connections will be closed. #http_max_body_size DEF_uint32(http_max_body_size, 8 \u0026lt;\u0026lt; 20, \u0026#34;#2 max size of http body, default: 8M\u0026#34;); The maximum body length supported by http::Server, the default is 8M. #http_max_header_size DEF_uint32(http_max_header_size, 4096, \u0026#34;#2 max size of http header\u0026#34;); The maximum header (the entire HTTP header) length supported by http::Server, the default is 4k. "},{"id":19,"href":"/en/co/net/rpc/","title":"RPC","section":"Network Programming","content":"include: co/rpc.h.\nco/rpc is a high-performance RPC framework similar to grpc, it uses JSON as the data exchange format, which is different from binary protocols such as protobuf.\n#rpc::Service class Service { public: Service() = default; virtual ~Service() = default; typedef std::function\u0026lt;void(Json\u0026amp;, Json\u0026amp;)\u0026gt; Fun; virtual const char* name() const = 0; virtual const co::map\u0026lt;const char*, Fun\u0026gt;\u0026amp; methods() const = 0; }; This class is a pure interface, which represents a service. A RPC server may have multiple services. name() returns the service name, like \u0026ldquo;HelloWorld\u0026rdquo;. methods() returns all the RPC methods provided by the Service class. #rpc::Server #Server::Server Server(); The default constructor, users do not need to care. #Server::add_service Server\u0026amp; add_service(rpc::Service* s); Server\u0026amp; add_service(const std::shared_ptr\u0026lt;rpc::Service\u0026gt;\u0026amp; s); Add a service, the parameter s must be dynamically created with operator new. Users can call this method multiple times to add multiple services, and different services must have different names. #Server::start void start( const char* ip, int port, const char* url=\u0026#39;/\u0026#39;, const char* key=0, const char* ca=0 ); Start the RPC server, this method will not block the current thread. The parameter ip is the server ip, which can be an IPv4 or IPv6 address, and the parameter port is the server port. The parameter url is the url of the HTTP service, and must start with /. The parameter key is path of a PEMfile which stores the SSL private key, and the parameter ca is path of a PEM file which stores the SSL certificate. They are NULL by default, and SSL is disabled. Starting from v3.0, the server no longer depends on the rpc::Server object after startup. #Server::exit void exit(); Added since v2.0.2. Exit the RPC server, close the listening socket, and no longer receive new connections. Since v3.0, after the RPC server exits, previously established connections will be reset in the future. #RPC server example #Define a proto file // hello_world.proto package xx service HelloWorld { hello, world, } The above is a simple proto file, // is for comments. package xx specifies the package name. In C++, it means that the code is generated into a namespace. You can use package xx.yy.zz to generate nested namespaces. service HelloWorld defines a service class that inherits from rpc::Service, and its name is \u0026quot;HelloWorld\u0026quot;. The service class provides two RPC methods, hello and world. A proto file can define only one service. In the proto file, the contents after the service definition will be ignored. #Generate code for RPC service gen is the RPC code generator provided by co, which can be used to generate code for RPC service.\nxmake -b gen # build gen cp gen /usr/local/bin # put gen in the /usr/local/bin directory gen hello_world.proto # Generate code gen *.proto # Batch generation The file generated for hello_world.proto is hello_world.h:\n// Autogenerated. // DO NOT EDIT. All changes will be undone. #pragma once #include \u0026#34;co/rpc.h\u0026#34; namespace xx { class HelloWorld : public rpc::Service { public: typedef std::function\u0026lt;void(Json\u0026amp;, Json\u0026amp;)\u0026gt; Fun; HelloWorld() { using std::placeholders::_1; using std::placeholders::_2; _methods[\u0026#34;HelloWorld.hello\u0026#34;] = std::bind(\u0026amp;HelloWorld::hello, this, _1, _2); _methods[\u0026#34;HelloWorld.world\u0026#34;] = std::bind(\u0026amp;HelloWorld::world, this, _1, _2); } virtual ~HelloWorld() {} virtual const char* name() const { return \u0026#34;HelloWorld\u0026#34;; } virtual const co::map\u0026lt;const char*, Fun\u0026gt;\u0026amp; methods() const { return _methods; } virtual void hello(Json\u0026amp; req, Json\u0026amp; res) = 0; virtual void world(Json\u0026amp; req, Json\u0026amp; res) = 0; private: co::map\u0026lt;const char*, Fun\u0026gt; _methods; }; } // xx As you can see, the HelloWorld class inherits from rpc::Service, and it has already implemented name() and methods() in rpc::Service. Users only need to inherit the HelloWorld class and implement the hello and world methods. #Implement the RPC service #include \u0026#34;hello_world.h\u0026#34; namespace xx { class HelloWorldImpl : public HelloWorld { public: HelloWorldImpl() = default; virtual ~HelloWorldImpl() = default; virtual void hello(Json\u0026amp; req, Json\u0026amp; res) { res = { { \u0026#34;result\u0026#34;, { { \u0026#34;hello\u0026#34;, 23 } }} }; } virtual void world(Json\u0026amp; req, Json\u0026amp; res) { res = { { \u0026#34;error\u0026#34;, \u0026#34;not supported\u0026#34;} }; } }; } // xx The above is just a very simple example. In actual applications, it is generally necessary to perform corresponding business processing according to the parameters in req, and then fill in res. #Start RPC server int main(int argc, char** argv) { flag::init(argc, argv); rpc::Server() .add_service(new xx::HelloWorldImpl) .start(\u0026#34;127.0.0.1\u0026#34;, 7788, \u0026#34;/xx\u0026#34;); for (;;) sleep::sec(80000); return 0; } } Before starting the server, we must call add_service() to add the service. The start() method will not block the current thread, so we need to write a for loop to prevent the main function from exiting directly. #Call RPC service with curl In v3.0, co/rpc supports HTTP protocol, so RPC service can be called with the curl command:\ncurl http://127.0.0.1:7788/xx --request POST --data \u0026#39;{\u0026#34;api\u0026#34;:\u0026#34;ping\u0026#34;}\u0026#39; curl http://127.0.0.1:7788/xx --request POST --data \u0026#39;{\u0026#34;api\u0026#34;:\u0026#34;HelloWorld.hello\u0026#34;}\u0026#39; The above use curl to send a POST request to the RPC server, the parameter is a JSON string, and a \u0026quot;api\u0026quot; field must be provided to indicate the RPC method to be called.\n\u0026quot;ping\u0026quot; is a built-in method of the RPC framework, generally used for testing or sending heartbeats.\n/xx in the url should be consistent with the url specified when the RPC server is started.\n#rpc::Client #Client::Client Client(const char* ip, int port, bool use_ssl=false); Client(const Client\u0026amp; c); Constructor. The first one, the parameter ip is the ip of the server, which can be a domain name, IPv4 or IPv6 address; the parameter port is the server port; the parameter use_ssl indicates whether to enable SSL transmission, the default is false, and SSL is disabled. When rpc::Client was constructed, the connection is not established immediately. #Client::~Client Client::~Client(); Destructor, close the internal connection. #Client::call void call(const Json\u0026amp; req, Json\u0026amp; res); Perform a RPC request, it must be called in the coroutine. The parameter req must contain the \u0026quot;api\u0026quot; field, its value is generally in the form of \u0026quot;service.method\u0026quot;. The parameter res is the response result of the RPC request. If the RPC request is not sent, or no response from the server is received, res will not be filled. This method checks the connection status before sending the RPC request, and establishes the connection first if it is not connected. #Client::close void close(); Close the connection, it is safe to call this function multiple times. #Client::ping void ping(); Send a ping request to the server, generally used for testing or sending heartbeats. #RPC client example #Use the rpc::Client directly DEF_bool(use_ssl, false, \u0026#34;use ssl if true\u0026#34;); DEF_int32(n, 3, \u0026#34;request num\u0026#34;); void client_fun() { rpc::Client c(\u0026#34;127.0.0.1\u0026#34;, 7788, FLG_use_ssl); for (int i = 0; i \u0026lt; FLG_n; ++i) { Json req = { {\u0026#34;api\u0026#34;, \u0026#34;HelloWorld.hello\u0026#34;} }; Json res; c.call(req, res); co::sleep(1000); } c.close(); } go(client_fun); In the above example, the client sends an RPC request to the server every 1 second. #Use connection pool co::Pool When a client needs to establish a large number of connections, co::Pool can be used to manage these connections.\nstd::unique_ptr\u0026lt;rpc::Client\u0026gt; proto; co::Pool pool( []() { return (void*) new rpc::Client(*proto); }, [](void* p) { delete (rpc::Client*) p; } ); void client_fun() { co::PoolGuard\u0026lt;rpc::Client\u0026gt; c(pool); while (true) { c-\u0026gt;ping(); co::sleep(3000); } } proto.reset(new rpc::Client(\u0026#34;127.0.0.1\u0026#34;, 7788)); for (int i = 0; i \u0026lt; 8; ++i) { go(client_fun); } In the above example, co::Pool is used to store the clients, and multiple coroutines can share these clients. co::PoolGuard automatically pops an idle client from co::Pool when it is created, and automatically puts the client back into co::Pool when it is destructed. The ccb of co::Pool uses copy construction to copy a client from proto. #Config items co/rpc uses co/flag to define config items. The flags defined in co/rpc are listed below.\n#rpc_conn_idle_sec DEF_int32(rpc_conn_idle_sec, 180, \u0026#34;#2 connection may be closed if no data...\u0026#34;); Timeout in seconds for idle connections in rpc::Server. If a connection does not receive any data within this time, the server may close the connection. #rpc_conn_timeout DEF_int32(rpc_conn_timeout, 3000, \u0026#34;#2 connect timeout in ms\u0026#34;); Connect timeout in milliseconds for rpc::Client. #rpc_log DEF_bool(rpc_log, true, \u0026#34;#2 enable rpc log if true\u0026#34;); Whether to print RPC logs, the default is true, rpc::Server and rpc::Client will print RPC requests and responses. #rpc_max_idle_conn DEF_int32(rpc_max_idle_conn, 128, \u0026#34;#2 max idle connections\u0026#34;); Maximum number of idle connections for rpc::Server. The default is 128. When this number is exceeded, the server will close some idle connections. #rpc_max_msg_size DEF_int32(rpc_max_msg_size, 8 \u0026lt;\u0026lt; 20, \u0026#34;#2 max size of rpc message, default: 8M\u0026#34;); The maximum length of RPC messages, the default is 8M. #rpc_recv_timeout DEF_int32(rpc_recv_timeout, 3000, \u0026#34;#2 recv timeout in ms\u0026#34;); RPC recv timeout in milliseconds. #rpc_send_timeout DEF_int32(rpc_send_timeout, 3000, \u0026#34;#2 send timeout in ms\u0026#34;); RPC send timeout in milliseconds. "},{"id":20,"href":"/en/co/tasked/","title":"Timed task scheduler","section":"Documents for CO","content":"include: co/tasked.h.\n#Tasked The Tasked class is a simple timed task scheduler. All tasks are scheduled internally by a single thread, but tasks can be added from any thread. When a task is blocked, it will affect all subsequent tasks. Therefore, it is not recommended to use Tasked to schedule tasks that may block for a long time.\n#Tasked::Tasked Tasked(); Tasked(Tasked\u0026amp;\u0026amp; t); The first version is the default constructor. When the object is created, the scheduling thread will start. The second version is the move constructor. #Tasked::~Tasked ~Tasked(); Destructor, stop the task scheduling thread. #Tasked::F typedef std::function\u0026lt;void()\u0026gt; F; The task type. #Tasked::run_at void run_at(F\u0026amp;\u0026amp; f, int hour, int minute=0, int second=0); void run_at(const F\u0026amp; f, int hour, int minute=0, int second=0); Add a task to run at the specified time, f will run once at time of hour:minute:second. hour must be an integer between 0-23, minute and second must be an integer between 0-59, and the default is 0. #Tasked::run_daily void run_daily(F\u0026amp;\u0026amp; f, int hour=0, int minute=0, int second=0); void run_daily(const F\u0026amp; f, int hour=0, int minute=0, int second=0); Add a periodic task that runs at a specified time every day, f will run once every day at the time of hour:minute:second. hour must be an integer between 0-23, the default is 0, minute and second are integers between 0-59, and the default is 0. #Tasked::run_every void run_every(F\u0026amp;\u0026amp; f, int n); void run_every(const F\u0026amp; f, int n); Add a periodic task that run every n seconds. #Tasked::run_in void run_in(F\u0026amp;\u0026amp; f, int n); void run_in(const F\u0026amp; f, int n); Add a task that runs once in n seconds. #Tasked::stop void stop(); Stop the task scheduling thread, this method will be automatically called in the destructor. It is safe to call this method multiple times. #Code example Tasked s; // create and start the scheduler s.run_in(f, 3); // run f 3 seconds later s.run_every(std::bind(f, 0), 3); // run f every 3 seconds s.run_at(f, 23); // run f once at 23:00:00 s.run_daily(f); // run f at 00:00:00 every day s.run_daily(f, 23); // run f at 23:00:00 every day s.run_daily(f, 23, 30); // run f at 23:30:00 every day s.stop(); // stop the scheduler "},{"id":21,"href":"/en/co/random/","title":"Random number","section":"Documents for CO","content":"include: co/random.h.\n#Random The Random class is a very fast pseudo-random number generator, which can generate integers between 1 and 2G-2 continuously and without repetition.\n#Random::Random Random(); explicit Random(uint32_t seed); The default constructor uses 1 as the seed number, and the second constructor uses the parameter seed as the seed number. #Random::next uint32_t next(); Returns the next pseudo-random number, not thread safe. Once the seed number is determined, the random sequence generated by calling next() is completely determined.\nExample\nRandom r(7); int n = r.next(); "},{"id":22,"href":"/en/co/lrumap/","title":"LruMap","section":"Documents for CO","content":"include: co/lru_map.h.\n#LruMap template \u0026lt;typename K, typename V\u0026gt; class LruMap; LruMap is a map implemented based on the LRU (least recently used) strategy. When the number of elements in the map reaches the upper limit, the least recently used data will be replaced first. It is implemented based on std::list and std::unordered_map, and the internal elements are unordered.\n#LruMap::LruMap LruMap(); explicit LruMap(size_t capacity); The default constructor uses 1024 as the maximum capacity. The second constructor takes the parameter capacity as the maximum capacity. #LruMap::begin iterator begin() const; Returns an iterator pointing to the first element. When LruMap is empty, the return value is equal to LruMap::end(). #LruMap::clear void clear(); This method clears the elements in LruMap, size() will become 0, and the capacity will remain unchanged. #LruMap::empty bool empty() const; This method determines whether LruMap is empty. #LruMap::end iterator end() const; Returns an iterator pointing to the next position of the last element, it does not point to any element itself. When LruMap is empty, begin() and end() are equal. #LruMap::erase void erase(iterator it); void erase(const key_type\u0026amp; key); Erase an element through iterator or key. #LruMap::find iterator find(const key_type\u0026amp; key) This method finds an element by key, and returns an iterator refer to the element if it is found, otherwise the return value is equal to end(). #LruMap::insert template \u0026lt;typename Key, typename Val\u0026gt; void insert(Key\u0026amp;\u0026amp; key, Val\u0026amp;\u0026amp; value); Insert an element, only when the key does not exist, it will insert a new element. If the key already exists, no operation will be performed. During the insert operation, if the number of elements has reached the maximum capacity, the least recently accessed element will be removed. #LruMap::size size_t size() const; Returns the number of elements in LruMap. #LruMap::swap void swap(LruMap\u0026amp; x) noexcept; void swap(LruMap\u0026amp;\u0026amp; x) noexcept; Exchange the contents of two LruMaps. This operation only exchanges internal pointers, size, and capacity. #Code example LruMap\u0026lt;int, int\u0026gt; m(128); // capacity: 128 auto it = m.find(1); if (it == m.end()) { m.insert(1, 23); } else { it-\u0026gt;second = 23; } m.erase(it); // erase by iterator m.erase(it-\u0026gt;first); // erase by key m.clear(); // clear the map "},{"id":23,"href":"/en/co/hash/","title":"Hash","section":"Documents for CO","content":"include: co/hash.h.\n#Hash #hash32 uint32 hash32(const void* s, size_t n); uint32 hash32(const char* s); uint32 hash32(const fastring\u0026amp; s) uint32 hash32(const std::string\u0026amp; s); This function returns a 32-bit murmur hash value. When s is a pointer, it is generally required to be sizeof(void*) byte aligned. #hash64 uint64 hash64(const void* s, size_t n); uint64 hash64(const char* s); uint64 hash64(const fastring\u0026amp; s); uint64 hash64(const std::string\u0026amp; s); This function returns a 64-bit murmur hash value. When s is a pointer, it is generally required to be 8-byte aligned. #murmur_hash size_t murmur_hash(const void* s, size_t n); This function returns a hash value of size_t type. This value is 64-bit on 64-bit platform and 32-bit on 32-bit platform. The parameter s is generally required to be sizeof(void*) byte-aligned. #md5 #md5digest void md5digest(const void* s, size_t n, char res[16]); fastring md5digest(const void* s, size_t n); fastring md5digest(const char* s); fastring md5digest(const fastring\u0026amp; s); fastring md5digest(const std::string\u0026amp; s); This function calculates the md5 of a string and returns a 16-byte binary string. #md5sum void md5sum(const void* s, size_t n, char res[32]); fastring md5sum(const void* s, size_t n); fastring md5sum(const char* s); fastring md5sum(const fastring\u0026amp; s); fastring md5sum(const std::string\u0026amp; s); This function calculates the md5 of a string and returns a 32-byte string containing only hexadecimal characters(0-9,a-f). #Lower level APIs void md5_init(md5_ctx_t* ctx); void md5_update(md5_ctx_t* ctx, const void* s, size_t n); void md5_final(md5_ctx_t* ctx, uint8 res[16]); The above 3 APIs can be used to calculate md5 incrementally.\nExample\nchar buf[4096]; uint8 res[16]; md5_ctx_t ctx; md5_init(\u0026amp;ctx); while (true) { int r = read(fd, buf, 4096); if (r \u0026gt; 0) { md5_update(\u0026amp;ctx, buf, r); } else { break; } } md5_final(\u0026amp;ctx, res); #sha256 #sha256digest void sha256digest(const void* s, size_t n, char res[32]); fastring sha256digest(const void* s, size_t n); fastring sha256digest(const char* s); fastring sha256digest(const fastring\u0026amp; s); fastring sha256digest(const std::string\u0026amp; s); This function calculates the sha256 of a string and returns a 32-byte binary string. #sha256sum void sha256sum(const void* s, size_t n, char res[64]); fastring sha256sum(const void* s, size_t n); fastring sha256sum(const char* s); fastring sha256sum(const fastring\u0026amp; s); fastring sha256sum(const std::string\u0026amp; s); This function calculates the sha256 of a string and returns a 64-byte string containing only hexadecimal characters(0-9,a-f). #Lower level APIs void sha256_init(sha256_ctx_t* ctx); void sha256_update(sha256_ctx_t* ctx, const void* s, size_t n); void sha256_final(sha256_ctx_t* ctx, uint8 res[32]); The above 3 APIs can be used to calculate sha256 incrementally like that in md5. #base64 #base64_encode fastring base64_encode(const void* s, size_t n); fastring base64_encode(const char* s); fastring base64_encode(const fastring\u0026amp; s); fastring base64_encode(const std::string\u0026amp; s); base64 encoding, \\r\\n is not added in this implementation. #base64_decode fastring base64_decode(const void* s, size_t n); fastring base64_decode(const char* s); fastring base64_decode(const fastring\u0026amp; s); fastring base64_decode(const std::string\u0026amp; s); base64 decoding, if the input is not valid base64-encoded data, the decoding will fail and an empty string will be returned. #nanoid 1. fastring nanoid(int n=15); 2. fastring nanoid(const char* s, size_t len, int n); 3. fastring nanoid(const fastring\u0026amp; s, int n); 4. fastring nanoid(const std::string\u0026amp; s, int n); 5. fastring nanoid(const char* s, int n); Returns a random string of the specified length. It is a C++ implementation of ai/nanoid.\n1, use the default alphabet, the parameter n specifies the length of the random string, the default is 15.\n2, the parameters s and len specify an alphabet, and the parameter n specifies the length of the random string.\n3-5, parameter s specifies the alphabet, and parameter n specifies the length of the random string.\nExample\nauto s = nanoid(); // 15 byte id auto x = nanoid(23); // 23 byte id // Generate a 8-byte random string using characters in 0-9,a-f auto f = nanoid(\u0026#34;0123456789abcdef\u0026#34;, 8); #url #url_encode fastring url_encode(const void* s, size_t n); fastring url_encode(const char* s); fastring url_encode(const fastring\u0026amp; s); fastring url_encode(const std::string\u0026amp; s); url encoding, reserved characters !()*#$\u0026amp;'+,/:;=?@[] and a-z A-Z 0-9 -_.~ will not be encoded, all other characters will be encoded. #url_decode fastring url_decode(const void* s, size_t n); fastring url_decode(const char* s); fastring url_decode(const fastring\u0026amp; s); fastring url_decode(const std::string\u0026amp; s); url decoding, if the input is not a reasonably encoded url, the decoding will fail and an empty string will be returned. #crc16 uint16_t crc16(const void* s, size_t n); uint16_t crc16(const char* s); uint16_t crc16(const fastring\u0026amp; s); uint16_t crc16(const std::string\u0026amp; s); This function calculates the crc16 value of a string. The implementation is taken from redis and will be used when implementing the redis cluster client. "},{"id":24,"href":"/en/co/path/","title":"Path","section":"Documents for CO","content":"include: co/path.h.\n#path co/path is ported from golang, the path separator must be '/' .\n#path::clean() fastring clean(const fastring\u0026amp; s); Return the shortest equivalent form of the path, the consecutive separators in the path will be removed.\nExample\npath::clean(\u0026#34;./x//y/\u0026#34;); // return \u0026#34;x/y\u0026#34; path::clean(\u0026#34;./x/..\u0026#34;); // return \u0026#34;.\u0026#34; path::clean(\u0026#34;./x/../..\u0026#34;); // return \u0026#34;..\u0026#34; #path::join() fastring join(const fastring\u0026amp; s, const fastring\u0026amp; t); template \u0026lt;typename ...S\u0026gt; fastring join(const S\u0026amp;... s); The first version concatenates two fastrings into a complete path.\nThe second version concatenates any number of fastrings into a complete path.\nThe returned result is a cleaned path by path::clean().\nExample\npath::join(\u0026#34;x\u0026#34;, \u0026#34;y\u0026#34;, \u0026#34;z\u0026#34;); // return \u0026#34;x/y/z\u0026#34; path::join(\u0026#34;/x/\u0026#34;, \u0026#34;y\u0026#34;); // return \u0026#34;/x/y\u0026#34; #path::split() std::pair\u0026lt;fastring, fastring\u0026gt; split(const fastring\u0026amp; s); Divide the path into two parts, dir and file. If the path does not contain a separator, the dir part will be empty.\nThe returned result satisfies the property path = dir + file.\nExample\npath::split(\u0026#34;/\u0026#34;); // -\u0026gt; {\u0026#34;/\u0026#34;, \u0026#34;\u0026#34;} path::split(\u0026#34;/a\u0026#34;); // -\u0026gt; {\u0026#34;/\u0026#34;, \u0026#34;a\u0026#34;} path::split(\u0026#34;/a/b\u0026#34;); // -\u0026gt; {\u0026#34;/a/\u0026#34;, \u0026#34;b\u0026#34;} #path::dir() fastring dir(const fastring\u0026amp; s); Return the directory part of the path, the return value is a cleaned path by path::clean().\nExample\npath::dir(\u0026#34;a\u0026#34;); // return \u0026#34;.\u0026#34; path::dir(\u0026#34;a/\u0026#34;); // return \u0026#34;a\u0026#34; path::dir(\u0026#34;/\u0026#34;); // return \u0026#34;/\u0026#34; path::dir(\u0026#34;/a\u0026#34;); // return \u0026#34;/\u0026#34;; #path::base() fastring base(const fastring\u0026amp; s); Return the last element of the path.\nExample\npath::base(\u0026#34;\u0026#34;); // return \u0026#34;.\u0026#34; path::base(\u0026#34;/\u0026#34;); // return \u0026#34;/\u0026#34; path::base(\u0026#34;/a/\u0026#34;); // return \u0026#34;a\u0026#34; ignores the delimiter at the end path::base(\u0026#34;/a\u0026#34;); // return \u0026#34;a\u0026#34; path::base(\u0026#34;/a/b\u0026#34;); // return \u0026#34;b\u0026#34; #path::ext() fastring ext(const fastring\u0026amp; s); Return the file extension.\nExample\npath::ext(\u0026#34;/a.cc\u0026#34;); // return \u0026#34;.cc\u0026#34; path::ext(\u0026#34;/a.cc/\u0026#34;); // return \u0026#34;\u0026#34; "},{"id":25,"href":"/en/co/fs/","title":"File System","section":"Documents for CO","content":"include: co/fs.h.\nco/fs.h implements common file system operations. It is recommended to use '/' uniformly as the path separator on different platforms.\n#Metadata operations #fs::exists bool exists(const char* path); bool exists(const fastring\u0026amp; path); bool exists(const std::string\u0026amp; path); Check whether the file exists, the parameter path is path of a file or directory. #fs::fsize int64 fsize(const char* path); int64 fsize(const fastring\u0026amp; path); int64 fsize(const std::string\u0026amp; path); Get the file size. -1 will be returned if the file does not exist. #fs::isdir bool isdir(const char* path); bool isdir(const fastring\u0026amp; path); bool isdir(const std::string\u0026amp; path); Check whether the file is a directory, if path exists and is a directory, it returns true, otherwise it returns false. #fs::mtime int64 mtime(const char* path); int64 mtime(const fastring\u0026amp; path); int64 mtime(const std::string\u0026amp; path); Get the modification time of the file, return -1 when the file does not exist. #fs::mkdir bool mkdir(const char* path, bool p=false); bool mkdir(const fastring\u0026amp; path, bool p=false); bool mkdir(const std::string\u0026amp; path, bool p=false); Create a directory, the parameter p indicates whether to create the entire path. The parameter p is false by default, and the directory will be created only when the parent directory exists; when the parameter p is true, it is equivalent to mkdir -p, and the parent directory will be created first if it does not exist, . #fs::remove bool remove(const char* path, bool rf=false); bool remove(const fastring\u0026amp; path, bool rf=false); bool remove(const std::string\u0026amp; path, bool rf=false); Delete a file or directory. When path is a directory, the parameter rf indicates whether to force deletion, the default is false, and only delete an empty directory. If rf is true, it is equivalent to rm -rf, non-empty directory will also be deleted. When path is a file, the parameter rf will be ignored. #fs::rename bool rename(const char* from, const char* to); bool rename(const fastring\u0026amp; from, const fastring\u0026amp; to); bool rename(const std::string\u0026amp; from, const std::string\u0026amp; to); Rename the file or directory, the parameter from is the original path, and the parameter to is the new path. When the parameter to is a directory, windows requires to and from to be under the same drive. It is generally recommended to use this method when the path specified by the parameter to does not exist. For details, please refer to win32/MoveFile, linux/rename. #fs::symlink bool symlink(const char* dst, const char* lnk); bool symlink(const fastring\u0026amp; dst, const fastring\u0026amp; lnk); bool symlink(const std::string\u0026amp; dst, const std::string\u0026amp; lnk); Create a soft link, the parameter dst is the path of the target file or directory, and the parameter lnk is the path of the soft link. This function first calls fs::remove(lnk) to delete the old soft link, and then create a new soft link. On windows, this function requires admin permission. #Code example bool x = fs::exists(path); // Determine whether the file exists bool x = fs::isdir(path); // Determine whether the file is a directory int64 x = fs::mtime(path); // Get the modification time of the file int64 x = fs::fsize(path); // Get the size of the file fs::mkdir(\u0026#34;a/b\u0026#34;); // mkdir a/b fs::mkdir(\u0026#34;a/b\u0026#34;, true); // mkdir -p a/b fs::remove(\u0026#34;x/x.txt\u0026#34;); // rm x/x.txt fs::remove(\u0026#34;a/b\u0026#34;); // rmdir a/b fs::remove(\u0026#34;a/b\u0026#34;, true); // rm -rf a/b fs::rename(\u0026#34;a/b\u0026#34;, \u0026#34;a/c\u0026#34;); // mv a/b a/c fs::symlink(\u0026#34;/usr\u0026#34;, \u0026#34;x\u0026#34;); // ln -s /usr x #Read and write files (fs::file) The fs::file class implements the basic read and write operations of files. Unlike fread and fwrite, it has no cache, but reads and writes files directly.\n#file::file file(); file(file\u0026amp;\u0026amp; f); file(const char* path, char mode); file(const fastring\u0026amp; path, char mode); file(const std::string\u0026amp; path, char mode); The first version is the default constructor, which creates an empty file object without opening a file. The second version is the move constructor. Version 3-5, open the specified file, the parameter path is the file path, and the parameter mode is the open mode. mode is one of 'r', 'w', 'a', 'm' or '+', r for read, w for write, a for append, m for modify, + for both read and write. When mode is 'r', the file must exist, otherwise the file is not opened. When mode is 'w', a new file will be created if it does not exist, and the file will be truncated if it already exists. When mode is 'a', 'm' or '+', a new file will be created when it does not exist, and the file will not be truncated if it already exists. '+' was added since v3.0. In this mode, read and write share the file pointer, therefore, you may need call the seek() method to set the offset before the read or write operation. #file::~file ~file(); Destructor, close the previously opened file and release related resources. #file::close void close(); Close the file, this method will be automatically called in the destructor. It is safe to call this method multiple times. #file::exists bool exists() const; Determine whether the file exists. The file may be deleted by other processes. This method can be used to determine whether the previously opened file still exists. #file::open bool open(const char* path, char mode); bool open(const fastring\u0026amp; path, char mode); bool open(const std::string\u0026amp; path, char mode); This method opens the specified file, mode is the open mode, see the description in Constructor. This method will close the previously opened file before opening a new file. #file::operator bool explicit operator bool() const; Convert fs::file to bool type, return true when the file is successfully opened, otherwise return false. #file::operator! bool operator!() const; It returns true when the file is not opened, otherwise it returns false. #file::path const fastring\u0026amp; path() const; This method returns a reference to the file path. If the file object is not associated with any file, the return value will refer to an empty string. #file::read size_t read(void* buf, size_t n); fastring read(size_t n); The first version reads data into the specified buffer, n is the number of bytes to be read, and returns the number of bytes actually read. The second version is similar to the first version, but returns a fastring, where n is the number of bytes to be read. The actual bytes read may be less than n, when it reaches the end of the file or an error occurs. #file::seek void seek(int64 off, int whence=seek_beg); Set the current position of the file pointer, the parameter off is the offset position, and the parameter whence is the starting position, which can be one of file::seek_beg, file::seek_cur, file::seek_end. This method is not valid for files opened with mode 'a'. #file::size int64 size() const; This method returns the size of the file. When the file is not opened, calling this method will return -1. #file::write size_t write(const void* s, size_t n); size_t write(const char* s); size_t write(const fastring\u0026amp; s); size_t write(const std::string\u0026amp; s); size_t write(char c); The first version writes a n-byte data. The 2-4th version writes a string. The fifth version writes a single character. This method returns the number of bytes actually written. When the disk space is insufficient or other error occurs, the return value may be less than n. This method has already handled EINTR error internally. #Example fs::file f; // empty file fs::file f(\u0026#34;xx\u0026#34;, \u0026#39;w\u0026#39;); // write mode f.open(\u0026#34;xx\u0026#34;, \u0026#39;m\u0026#39;); // reopen with modify mode f.open(\u0026#34;xx\u0026#34;, \u0026#39;r\u0026#39;); // read mode if (f) f.read(buf, 512); // read at most 512 bytes fastring s = f.read(32); // read at most 32 bytes and return fastring f.open(\u0026#34;xx\u0026#34;, \u0026#39;a\u0026#39;); // append mode if(f) f.write(buf, 32); // write 32 bytes f.write(\u0026#34;hello\u0026#34;); // write a C string f.write(\u0026#39;c\u0026#39;); // write a single character f.open(\u0026#34;xx\u0026#34;, \u0026#39;+\u0026#39;); // read/write mode f.seek(0); // seek to beginning before write f.write(\u0026#34;hello\u0026#34;); f.seek(0); // seek to beginning before read f.read(buf, 8); f.close(); // close the file #File Stream (fs::fstream) fs::file does not support caching, and the performance of writing small files is poor. For this reason, co/fs.h also implements the fs::fstream class that supports caching, it is designed for writing files and does not support read operations.\n#fstream::fstream fstream(); fstream(fstream\u0026amp;\u0026amp; fs); explicit fstream(size_t cap); fstream(const char* path, char mode, size_t cap=8192); fstream(const fastring\u0026amp; path, char mode, size_t cap=8192); fstream(const std::string\u0026amp; path, char mode, size_t cap=8192); The first version is the default constructor, and the internal cache size is 8k. The second version is the move constructor. The third version uses the parameter cap to specify the size of the cache. Version 4-6 open the specified file, cap is the cache size, and the default is 8k. The parameter mode is one of 'w' or 'a', and the read mode is not supported. When mode is 'w', the file is automatically created when it does not exist, and the file data is cleared if it already exists. When the mode is 'a', the file will be created automatically if it does not exist, and the file data will not be cleared if it already exists. #fstream::~fstream ~fstream(); Destructor, close the file, release related resources. #fstream::append fstream\u0026amp; append(const void* s, size_t n); Append data to the file, the parameter n is the length of the data. #fstream::close void close(); Close the file, this method will be automatically called in the destructor. It is safe to call this method multiple times. #fstream::flush void flush(); Write the data in the cache to the file. #fstream::open bool open(const char* path, char mode); bool open(const fastring\u0026amp; path, char mode); bool open(const std::string\u0026amp; path, char mode); Open the specified file. This method will close the previously opened file before opening a new file. #fstream::operator bool explicit operator bool() const; Convert fs::fstream to bool type, return true when the file is successfully opened, otherwise return false. #fstream::operator! bool operator!() const; It returns true when the file is not opened, otherwise it returns false. #fstream::operator\u0026laquo; fstream\u0026amp; operator\u0026lt;\u0026lt;(const char* s); fstream\u0026amp; operator\u0026lt;\u0026lt;(const fastring\u0026amp; s); fstream\u0026amp; operator\u0026lt;\u0026lt;(const std::string\u0026amp; s); fstream\u0026amp; operator\u0026lt;\u0026lt;(const fastream\u0026amp; s); template\u0026lt;typename T\u0026gt; fstream\u0026amp; operator\u0026lt;\u0026lt;(T v); In versions 1-3, the parameter s is a string type. In the 4th version, the parameter s is a fastream. In the fifth version, T can be any built-in type, such as bool, char, int, double, etc. #fstream::reserve void reserve(size_t n); Adjust the cache capacity, the parameter n is the capacity. If n is less than the previous capacity, the capacity remains unchanged. #Code example fs::fstream s; // cache size: 8k fs::fstream s(4096); // cache size: 4k fs::fstream s(\u0026#34;path\u0026#34;,\u0026#39;a\u0026#39;); // append mode, cache size: 8k fs::fstream s(\u0026#34;path\u0026#34;,\u0026#39;w\u0026#39;, 4096); // write mode, cache size: 4k s.reserve(8192); // make cache size at least 8k s.open(\u0026#34;path\u0026#34;,\u0026#39;a\u0026#39;); // open with append mode if (s) s \u0026lt;\u0026lt; \u0026#34;hello world\u0026#34; \u0026lt;\u0026lt; 23; // operator\u0026lt;\u0026lt; s.append(\u0026#34;hello\u0026#34;, 5); // append s.flush(); // flush data in cache to file s.close(); // close the file "},{"id":26,"href":"/en/co/os/","title":"Operating System","section":"Documents for CO","content":"include: co/os.h.\n#os #os::cpunum int cpunum(); Returns the number of system CPU cores. #os::cwd fastring cwd(); Returns path of the current working directory. On windows, \\ in the results will be converted to /. #os::daemon void daemon(); Put the current process to run in the background, for linux only. #os::env fastring env(const char* name); bool env(const char* name, const char* value); The first version, get value of the system environment variable. The second version, added since v2.0.2, set value of the system environment variable, return true on success, otherwise false. #os::exename fastring exename(); Returns name of the current process without path. #os::exepath fastring exepath(); Returns the full path of the current process. On windows, \\ in the results will be converted to /. #os::homedir fastring homedir(); Returns path of the home directory of the current user. On windows, \\ in the results will be converted to /. #os::pid int pid(); Returns the id of the current process. #os::signal typedef void (*sig_handler_t)(int); sig_handler_t signal(int sig, sig_handler_t handler, int flag=0); Set a handler for a signal, the parameter sig is the signal value, and the parameter flag is the combination of SA_RESTART, SA_ONSTACK or other options.\nThe parameter flag is only applicable to linux/mac platforms.\nThis function returns the old signal handler.\nExample\nvoid f(int); os::signal(SIGINT, f); // user defined handler os::signal(SIGABRT, SIG_DFL); // default handler os::signal(SIGPIPE, SIG_IGN); // ignore SIGPIPE "},{"id":27,"href":"/en/co/build/","title":"Compiling","section":"Documents for CO","content":"#Compiler requirements The compilers required are as follows:\nLinux: gcc 4.8+ Mac: clang 3.3+ Windows: vs2015+ #xmake CO recommends using xmake as the build tool.\n#Install xmake For Windows, mac and debian/ubuntu, you can go directly to the release page of xmake to get the installation package. For other systems, please refer to xmake\u0026rsquo;s Installation instructions.\nXmake disables compiling as root by default on Linux. ruki says it is not safe. You can add the following line to ~/.bashrc to enable it:\nexport XMAKE_ROOT=y #Build Run commands below in the root directory of CO to build libco and other projects:\nxmake -a # build all projects (libco, gen, test, unitest) To enable HTTP and SSL features, build with the following commands:\nxmake f --with_libcurl=true --with_openssl=true xmake -a Xmake may install libcurl and openssl from the network, which may be slow.\n-a in the command line means to build all projects in CO. If -a is not added, only libco will be built by default. In addition, users may use -v or -vD to print more detailed compiling information:\nxmake -v -a #Compiling options Xmake provides the xmake f command to configure compiling options. Note that multiple options must be set in a single xmake f command.\n#Build debug version of libco xmake f -m debug xmake -v #Build dynamic library xmake f -k shared xmake -v Note that dynamic library is not supported on Windows.\n#Build 32-bit libco Windows xmake f -a x86 xmake -v Linux xmake f -a i386 xmake -v The -a in xmake f command means arch. The arch supported by different platforms may be different. Run xmake f --help to see the details.\n#set vs_runtime on Windows On Windows, CO uses the MT runtime library by default, and users can use xmake f to configure it:\nxmake f --vs_runtime=MD xmake -v #Android and IOS support CO can also be built on Android and IOS platforms, see Github Actions for details. Since the author has no front-end development experience, it has not been tested on Android and IOS.\nandroid xmake f -p android --ndk=/path/to/android-ndk-r21 xmake -v ios xmake f -p iphoneos xmake -v #Build and run unitest code co/unitest contains some unit test code, run the following commands to build and run the test program:\nxmake -b unitest # build unitest xmake r unitest -a # run all unit tests xmake r unitest -os # run unit test: os xmake r unitest -json # run unit test: json #Build and run test code co/test contains some test code, add xx.cc source file in the co/test directory or its subdirectories, and then run xmake -b xx in the root directory of CO to build it.\nxmake -b flag # compile test/flag.cc xmake -b log # compile test/log.cc xmake -b json # compile test/json.cc xmake -b rpc # compile test/rpc.cc xmake r flag -xz # test flag library xmake r log # test log library xmake r log -cout # also log to terminal xmake r log -perf # test performance of log library xmake r json # test json xmake r rpc # start rpc server xmake r rpc -c # start rpc client #Build and use gen xmake -b gen cp gen /usr/local/bin/ gen hello_world.proto The proto file format can refer to hello_world.proto.\n#Install libco After building libco, you can use the xmake install command to install libco to the specified directory:\nxmake install -o pkg # install to pkg xmake i -o pkg # same as above xmake i -o /usr/local # install to /usr/local #Install libco from xmake repo xrepo install -f \u0026#34;openssl=true,libcurl=true\u0026#34; co #cmake izhengfan helped to provide the cmakefile:\nOnly build libco by default. The library files are in build/lib directory, and the executable files are in build/bin directory. You can use BUILD_ALL to build all projects. You can use CMAKE_INSTALL_PREFIX to specify the installation directory. #Build libco by default mkdir build \u0026amp;\u0026amp; cd build cmake .. make -j8 #Build all projects mkdir build \u0026amp;\u0026amp; cd build cmake .. -DBUILD_ALL=ON -DCMAKE_INSTALL_PREFIX=/usr/local make -j8 make install #Enable HTTP and SSL features To use HTTP or SSL features, libcurl, zlib, and openssl 1.1.0 or above must be installed.\nmkdir build \u0026amp;\u0026amp; cd build cmake .. -DBUILD_ALL=ON -DWITH_LIBCURL=ON -DWITH_OPENSSL=ON make -j8 #Install libco from vcpkg vcpkg install co:x64-windows # HTTP \u0026amp; SSL support vcpkg install co[libcurl,openssl]:x64-windows "}]