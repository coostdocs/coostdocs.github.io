<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Documents for Coost</title>
    <link>https://coostdocs.github.io/cn/</link>
    <description>Recent content on Documents for Coost</description>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://coostdocs.github.io/cn/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>原子操作</title>
      <link>https://coostdocs.github.io/cn/co/concurrency/atomic/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://coostdocs.github.io/cn/co/concurrency/atomic/</guid>
      <description>include: co/atomic.h.
#Memory Order coost 从 v3.0 开始，增加了对 memory order 的支持。coost 中的 6 种 memory order 定义如下：
enum memory_order_t { mo_relaxed, mo_consume, mo_acquire, mo_release, mo_acq_rel, mo_seq_cst, }; 为了保持兼容性，coost 中的原子操作默认的 memory order 均为 mo_seq_cst。
#v3.0 删除的 API atomic_get，使用 atomic_load 取代之。 atomic_set，使用 atomic_store 取代之。 atomic_reset，使用 atomic_store(&amp;amp;x, 0) 取代之。 #load &amp;amp; store #atomic_load template &amp;lt;typename T&amp;gt; inline T atomic_load(const T* p, memory_order_t mo = mo_seq_cst); 此函数获取 p 指向的变量的值，T 是长度为 1, 2, 4, 8 字节的任意内置数据类型(包括指针类型)。</description>
    </item>
    
    <item>
      <title>基本定义</title>
      <link>https://coostdocs.github.io/cn/co/def/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://coostdocs.github.io/cn/co/def/</guid>
      <description>include: co/def.h.
#typedefs #定长整数类型 co/def.h 定义了如下的 8 种整数类型：
typedef int8_t int8; typedef int16_t int16; typedef int32_t int32; typedef int64_t int64; typedef uint8_t uint8; typedef uint16_t uint16; typedef uint32_t uint32; typedef uint64_t uint64; 这些类型在不同平台的长度是一致的，不存在可移植性问题。Google Code Style 建议除了 int，不要使用 short, long, long long 等内置整数类型。
#macros #整型最大、最小值 MAX_UINT8 MAX_UINT16 MAX_UINT32 MAX_UINT64 MAX_INT8 MAX_INT16 MAX_INT32 MAX_INT64 MIN_INT8 MIN_INT16 MIN_INT32 MIN_INT64 这些宏分别表示 8 种整数类型的最大、最小值。
#DISALLOW_COPY_AND_ASSIGN 这个宏用于禁止 C++ 类中的拷贝构造函数与赋值操作。
示例 class T { public: T(); DISALLOW_COPY_AND_ASSIGN(T); }; #__arch64, __arch32 64位系统上，__arch64 定义为 1；32位系统上，__arch32 定义为 1。</description>
    </item>
    
    <item>
      <title>基本概念</title>
      <link>https://coostdocs.github.io/cn/co/concurrency/coroutine/basic/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://coostdocs.github.io/cn/co/concurrency/coroutine/basic/</guid>
      <description>#协程基本概念 协程是运行于线程中的轻量级调度单位。 协程之于线程，类似于线程之于进程。 一个进程中可以存在多个线程，一个线程中可以存在多个协程。 协程所在的线程一般被称为调度线程。 协程发生 io 阻塞或调用 sleep 等操作时，调度线程会挂起此协程。 协程挂起时，调度线程会切换到其他等待中的协程运行。 协程的切换是在用户态进行的，比线程间的切换更快。 协程非常适合写网络程序，可以实现同步的编程方式，不需要异步回调，大大减轻了程序员的思想负担。
#co 协程特性 coost 中实现的是一种类似 goroutine 的协程，有如下特性：
支持多线程调度，默认线程数为系统 CPU 核数。 共享栈，同一线程中的协程共用若干个栈(大小默认为 1MB)，内存占用低，Linux 上的测试显示 1000 万协程只用了 2.8G 内存(仅供参考)。 协程创建后，始终在同一个线程中运行，而不会切换到其他线程。 各协程之间为平级关系，可以在任何地方(包括在协程中)创建新的协程。 coost 协程库中 context 相关代码取自 ruki 的 tbox，而 tbox 则参考了 boost 的实现，在此表示感谢！ </description>
    </item>
    
    <item>
      <title>声明</title>
      <link>https://coostdocs.github.io/cn/about/announce/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://coostdocs.github.io/cn/about/announce/</guid>
      <description>#文档付费声明 本文档采取付费阅读模式，用户可选择如下付费方案之一：
每个用户一次性支付 59￥，获得本文档永久阅读权。 每个用户支付 23￥/年，持续 3 年，之后获得本文档永久阅读权。 支付页面</description>
    </item>
    
    <item>
      <title>字节序</title>
      <link>https://coostdocs.github.io/cn/co/net/byte_order/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://coostdocs.github.io/cn/co/net/byte_order/</guid>
      <description>include: co/byte_order.h.
计算机中的数据在内存中是以字节(8 bit)为基本单位进行存储的，大端机采用大端字节序，即高位字节在低地址，低位字节在高地址，小端机则采用小端字节序，即低位字节在低地址，高位字节在高地址。
单个字节在大、小端机器上是完全相同的，而多个字节的基本数据类型，在大、小端机器上有着不同的字节序。这里说的基本数据类型是指像 int, double 这样的内置类型，字符串不在此列，它是由单字节构成的序列，在大、小端机器上有着相同的存储形式。
网络上传输的数据采用大端字节序，所谓的网络字节序也就是大端字节序。发送数据到网络上时，需要将其中的多字节基本类型转换成网络字节序，而从网络上接收数据时，则需要转换成所在主机的字节序。
byte_order.h 定义了如下的方法：
ntoh16 ntoh32 ntoh64 hton16 hton32 hton64 这些方法分别适用于长度为 2, 4, 8 字节的整数，其中 ntoh 系列将网络字节序转换成主机字节序，hton 系列则将主机字节序转换成网络字节序。
代码示例 uint32 h = 777; uint32 n = hton32(h); </description>
    </item>
    
    <item>
      <title>终端输出</title>
      <link>https://coostdocs.github.io/cn/co/other/console/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://coostdocs.github.io/cn/co/other/console/</guid>
      <description>include: co/cout.h.
#颜色 如下：
cout &amp;lt;&amp;lt; text::red(&amp;#34;hello\n&amp;#34;); cout &amp;lt;&amp;lt; text::green(&amp;#34;hello\n&amp;#34;); cout &amp;lt;&amp;lt; text::blue(&amp;#34;hello\n&amp;#34;); cout &amp;lt;&amp;lt; text::yellow(&amp;#34;hello\n&amp;#34;); cout &amp;lt;&amp;lt; text::magenta(&amp;#34;hello\n&amp;#34;); cout &amp;lt;&amp;lt; text::cyan(&amp;#34;hello\n&amp;#34;); cout &amp;lt;&amp;lt; &amp;#34;hello\n&amp;#34;; cout &amp;lt;&amp;lt; text::bold(&amp;#34;hello\n&amp;#34;); cout &amp;lt;&amp;lt; text::bold(&amp;#34;hello\n&amp;#34;).red(); cout &amp;lt;&amp;lt; text::bold(&amp;#34;hello\n&amp;#34;).green(); cout &amp;lt;&amp;lt; text::bold(&amp;#34;hello\n&amp;#34;).blue(); cout &amp;lt;&amp;lt; text::bold(&amp;#34;hello\n&amp;#34;).yellow(); cout &amp;lt;&amp;lt; text::bold(&amp;#34;hello\n&amp;#34;).magenta(); cout &amp;lt;&amp;lt; text::bold(&amp;#34;hello\n&amp;#34;).cyan(); #co::print template&amp;lt;typename ...X&amp;gt; void print(X&amp;amp;&amp;amp; ... x); 接受任意数量的参数，输出到 stdout，末尾会添加换行符。 内部有加锁，支持多线程同时调用 co::print。 co::print(&amp;#34;hello &amp;#34;, 23); co::print(text::red(&amp;#34;hello&amp;#34;)); co::vector&amp;lt;int&amp;gt; v = { 1, 2, 3 }; co::print(v); </description>
    </item>
    
    <item>
      <title>APIs</title>
      <link>https://coostdocs.github.io/cn/co/concurrency/coroutine/api/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://coostdocs.github.io/cn/co/concurrency/coroutine/api/</guid>
      <description>include: co/co.h.
#Coroutine APIs v3.0 移除了 co::init, co::exit, co::stop。 #go 1. void go(Closure* cb); 2. template&amp;lt;typename F&amp;gt; void go(F&amp;amp;&amp;amp; f); 3. template&amp;lt;typename F, typename P&amp;gt; void go(F&amp;amp;&amp;amp; f, P&amp;amp;&amp;amp; p); 4. template&amp;lt;typename F, typename T, typename P&amp;gt; void go(F&amp;amp;&amp;amp; f, T* t, P&amp;amp;&amp;amp; p); 此函数用于创建协程，与创建线程类似，需要指定一个协程函数。
1, 参数 cb 指向一个 Closure 对象，协程启动后会调用 Closure 中的 run() 方法。
2-4, 将传入的参数打包成一个 Closure，然后调用 1。
2, 参数 f 是任意可调用的对象，只要能调用 f() 或 (*f)() 就行。
3, 参数 f 是任意可调用的对象，只要能调用 f(p), (*f)(p) 或 (p-&amp;gt;*f)() 就行。</description>
    </item>
    
    <item>
      <title>defer</title>
      <link>https://coostdocs.github.io/cn/co/other/defer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://coostdocs.github.io/cn/co/other/defer/</guid>
      <description>include: co/defer.h.
#defer defer 是 coost 提供的一个宏，它实现了类似 golang 中 defer 的功能。defer 的参数可以是一条或多条语句。
void f() { void* p = malloc(32); defer(free(p)); defer( std::cout &amp;lt;&amp;lt; &amp;#34;111&amp;#34; &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; &amp;#34;222&amp;#34; &amp;lt;&amp;lt; std::endl; ); std::cout &amp;lt;&amp;lt; &amp;#34;333&amp;#34; &amp;lt;&amp;lt; std::endl; } 上面的例子中，defer 中的代码将在函数 f 结束时执行，因此 333 先于 111 与 222 打印。</description>
    </item>
    
    <item>
      <title>socket 编程</title>
      <link>https://coostdocs.github.io/cn/co/net/sock/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://coostdocs.github.io/cn/co/net/sock/</guid>
      <description>include: co/co.h.
#Socket APIs co 提供了常用的协程化的 socket API，以支持基于协程的网络编程。
大部分 API 形式上与原生的 socket API 保持一致，这样可以减轻用户的学习负担，熟悉 socket 编程的用户可以轻松上手。
这些 API 大部分需要在协程中使用，它们在 I/O 阻塞或调用 sleep 等操作时，调度线程会挂起当前协程，切换到其他等待中的协程运行，调度线程本身并不会阻塞。借助这些 API，用户可以轻松的实现高并发、高性能的网络程序。
#术语约定 阻塞
在描述 co 中的一些 socket API 时，会用到阻塞一词，如 accept, recv，文档中说它们会阻塞，是指当前的协程会阻塞，而当前的调度线程并不会阻塞(可以切换到其他协程运行)。用户看到的是协程，而不是调度线程，因此从用户的角度看，它们是阻塞的。实际上，这些 API 内部使用 non-blocking socket，并不会真的阻塞，只是在 socket 上没有数据可读或者无法立即写入数据时，调度线程会挂起当前协程，当 socket 变为可读或可写时，调度线程会重新唤起该协程，继续 I/O 操作。
non-blocking socket
co 中的 socket API 必须使用 non-blocking socket，在 windows 平台还要求 socket 支持 overlapped I/O，win32 API 创建的 socket 默认都支持 overlapped I/O，用户一般不需要担心这个问题。为了叙述方便，这里约定文档中说到 non-blocking socket 时，同时也表示它在 windows 上支持 overlapped I/O。</description>
    </item>
    
    <item>
      <title>简介</title>
      <link>https://coostdocs.github.io/cn/about/co/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://coostdocs.github.io/cn/about/co/</guid>
      <description>#coost 简介 coost 是一个兼具性能与易用性的跨平台 C++ 基础库，其目标是打造一把 C++ 开发神器，让 C++ 编程变得简单、轻松、愉快。
coost 简称为 co，曾被称为小型 boost 库，与 boost 相比，coost 小而精美，在 linux 与 mac 上编译出来的静态库仅 1M 左右大小，却包含了不少强大的功能：
命令行与配置文件解析(flag) 高性能日志库(log) 单元测试框架 基准测试框架 go-style 协程 基于协程的网络编程框架 基于 JSON 的 RPC 框架 原子操作(atomic) 高效字符流(fastream) 高效字符串(fastring) 字符串操作(str) 时间库(time) 线程库(thread) 定时任务调度器 面向玄学编程 高效 JSON 库 hash 库 path 库 文件系统操作(fs) 系统操作(os) 高性能内存分配器 文档付费声明
本文档采取付费阅读模式，用户可选择如下付费方案之一：
每个用户一次性支付 59￥，获得本文档永久阅读权。 每个用户支付 23￥/年，持续 3 年，之后获得本文档永久阅读权。 支付页面
#coost 发展历程 2013-2015 年，Alvin(idealvin) 在使用 google gflags、glog、gtest 等时，感到有些繁琐，就自己动手实现了相应的功能，即现今 coost 中的 flag、log、unitest 等组件。</description>
    </item>
    
    <item>
      <title>线程</title>
      <link>https://coostdocs.github.io/cn/co/concurrency/thread/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://coostdocs.github.io/cn/co/concurrency/thread/</guid>
      <description>include: co/co.h.
#线程 v3.0.1 删除了 co/thread.h 头文件，移除了全局的 Thread 与 Mutex 类，其功能与 C++11 中的 std::thread 与 std::mutex 一样，用户可以直接使用 std 版本。 #co::thread_id uint32 thread_id(); 返回当前线程的 id 值。 #co::sync_event 同步事件是多线程间的一种同步机制，适用于生产者-消费者模型。消费者线程调用 wait() 方法等待同步信号，生产者线程则调用 signal() 方法产生同步信号。co::sync_event 支持多生产者、多消费者，但实际应用中，单个消费者的情况比较多。
v3.0.1 移除了全局范围的 SyncEvent，请使用 co::sync_event 替代之。 #constructor explicit sync_event(bool manual_reset=false, bool signaled=false); 构造函数，参数 manual_reset 表示是否手动将同步状态设置成未同步，参数 signaled 表示初始状态是否为同步状态。 #sync_event::reset void reset(); 将事件设置成未同步状态。 当构造函数中 manual_reset 为 true 时，用户在调用 wait() 后需要手动调用此方法，将事件设置成未同步状态。 #sync_event::signal void signal(); 产生同步信号，将事件设置成同步状态。 #sync_event::wait 1. void wait(); 2. bool wait(uint32 ms); 1, 一直等待直到事件变成同步状态。 2, 等待直到事件变成同步状态或超时。参数 ms 指定超时时间，单位为毫秒。若事件变成同步状态，返回 true，否则返回 false。 当构造函数中 manual_reset 为 false 时，wait() 结束时会自动将事件设置成未同步状态。 #代码示例 #include &amp;#34;co/co.</description>
    </item>
    
    <item>
      <title>错误</title>
      <link>https://coostdocs.github.io/cn/co/other/error/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://coostdocs.github.io/cn/co/other/error/</guid>
      <description>include: co/error.h.
#co::error 1. int error(); 2. void error(int e); 1, 返回当前的错误码。 2, 将当前错误码设置为 e。 #co::strerror 1. const char* strerror(int e); 2. const char* strerror(); 1, 获取错误码 e 的描述信息，线程安全。 2, 获取当前错误码的描述信息，线程安全。 </description>
    </item>
    
    <item>
      <title>面向玄学</title>
      <link>https://coostdocs.github.io/cn/co/god/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://coostdocs.github.io/cn/co/god/</guid>
      <description>include: co/god.h.
#god god 模块提供了一些与模板相关的功能，模板用到深处有点玄，一些 C++ 程序员将之称为面向玄学编程。
#god::bless_no_bugs void bless_no_bugs(); 祈求老天保佑代码无 bug，线程安全，可任意调用。
示例
#include &amp;#34;co/god.h&amp;#34; #include &amp;#34;co/cout.h&amp;#34; int main(int argc, char** argv) { god::bless_no_bugs(); co::print(&amp;#34;hello world&amp;#34;); return 0; } #god::cast template&amp;lt;typename To, typename From&amp;gt; constexpr To cast(From&amp;amp;&amp;amp; f) { return (To) std::forward&amp;lt;From&amp;gt;(f); } 万能转换，将 From 类型转换为 To 类型，To 可以是引用。
示例
int i = 65; char c = god::cast&amp;lt;char&amp;gt;(i); // c -&amp;gt; &amp;#39;A&amp;#39; god::cast&amp;lt;char&amp;amp;&amp;gt;(i) = &amp;#39;a&amp;#39;; // 将 i 的低字节设置为 &amp;#39;a&amp;#39; #&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; #god::align_down 1.</description>
    </item>
    
    <item>
      <title>channel</title>
      <link>https://coostdocs.github.io/cn/co/concurrency/coroutine/chan/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://coostdocs.github.io/cn/co/concurrency/coroutine/chan/</guid>
      <description>include: co/co.h.
#co::chan template&amp;lt;typename T&amp;gt; class chan; co::chan 是一个模板类，它类似于 golang 中的 channel，用于在协程之间传递数据。
从 v3.0.1 开始，co::chan 可在协程或非协程中使用，且可存储 std::string 等非 POD 类型的值。 #constructor 1. explicit chan(uint32 cap=1, uint32 ms=(uint32)-1); 2. chan(chan&amp;amp;&amp;amp; c); 3. chan(const chan&amp;amp; c); 1, 参数 cap 是内部队列的最大容量，默认是 1，参数 ms 是读写操作的超时时间，单位为毫秒，默认为 -1，永不超时。 2, 移动构造函数。 3, 拷贝构造函数，仅将内部引用计数加 1。 #close void close() const; 关闭 channel，关闭后 channel 不可写，但可读。 #done bool done() const; 判断读、写操作是否成功完成。 #operator bool explicit operator bool() const; 若 channel 为关闭状态，返回 false，否则返回 true。 #operator&amp;laquo; chan&amp;amp; operator&amp;lt;&amp;lt;(const T&amp;amp; x) const; chan&amp;amp; operator&amp;lt;&amp;lt;(T&amp;amp;&amp;amp; x) const; 写入元素 x。 此方法会阻塞，直到写入操作完成或超时。可以调用 done() 方法判断写操作是否成功完成。 若 channel 已关闭，写操作会失败，此方法立即返回。 #operator&amp;raquo; chan&amp;amp; operator&amp;gt;&amp;gt;(T&amp;amp; x) const; 读取元素。 此方法会阻塞，直到读取操作完成或超时。可以调用 done() 方法判断读操作是否成功完成。 若 channel 已关闭且 channel 中无元素可读时，读操作会失败，此方法立即返回。 #代码示例 #include &amp;#34;co/co.</description>
    </item>
    
    <item>
      <title>fastring</title>
      <link>https://coostdocs.github.io/cn/co/other/fastring/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://coostdocs.github.io/cn/co/other/fastring/</guid>
      <description>include: co/fastring.h.
#fastring fastring 是 coost 提供的字符串类型，它实现了 std::string 中的大部分方法，同时也提供了一些 std::string 没有的方法。
#constructor 1. constexpr fastring() noexcept; 2. explicit fastring(size_t cap); 3. fastring(const void* s, size_t n); 4. fastring(const char* s); 5. fastring(const std::string&amp;amp; s); 6. fastring(size_t n, char c); 7. fastring(char c, size_t n); 8. fastring(const fastring&amp;amp; s); 9. fastring(fastring&amp;amp;&amp;amp; s) noexcept; 1, 默认构造函数，创建一个空的 fastring 对象，不会分配任何内存。
2, 创建一个空的 fastring 对象，但用参数 cap 指定初始容量，即预分配 cap 字节的内存。
3, 用给定的字节序列创建 fastring 对象，参数 n 是序列长度。</description>
    </item>
    
    <item>
      <title>内存分配</title>
      <link>https://coostdocs.github.io/cn/co/mem/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://coostdocs.github.io/cn/co/mem/</guid>
      <description>include: co/mem.h.
#co::alloc 1. void* alloc(size_t size); 2. void* alloc(size_t size, size_t align); 1, 分配 size 字节的内存。 2, 分配 size 字节的内存，内存边界是 align 字节对齐的(align &amp;lt;= 1024)。 第 2 个版本中，align 必须是 2 的幂，且不能超过 1024。 #co::free void free(void* p, size_t size); 释放 co::alloc 或 co::realloc 分配的内存，size 是所分配内存的大小。 co::free 不同于系统提供的 ::free，需要额外带上一个 size 参数。 #co::realloc void* realloc(void* p, size_t old_size, size_t new_size); 重新分配内存，old_size 是之前的内存大小，new_size 是新的大小，后者必须大于前者。 #co::zalloc void* zalloc(size_t size); 分配 size 字节的内存，并将内存清零。 #&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; #co::make template&amp;lt;typename T, typename.</description>
    </item>
    
    <item>
      <title>网络编程模式</title>
      <link>https://coostdocs.github.io/cn/co/net/mode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://coostdocs.github.io/cn/co/net/mode/</guid>
      <description>#基于协程的网络编程模式 协程可以用同步的方式，实现高并发、高性能的网络程序。协程虽然会阻塞，但调度线程可以在大量的协程间快速切换，因此要实现高并发，只需要创建大量的协程即可。
以 TCP 程序为例，服务端一般采用一个连接一个协程的模式，为每个客户端连接创建新的协程，在协程中处理连接上的数据。客户端没必要一个连接一个协程，一般使用连接池，多个协程共用连接池中的连接。
#服务端网络模型 void on_connection(int fd) { while (true) { co::recv(fd, ...); // recv request from client process(...); // process the request co::send(fd, ...); // send response to client } } void server_fun() { while (true) { int fd = co::accept(...); if (fd != -1) go(on_connection, fd); } } go(server_fun); 服务端采用一个连接一个协程的模型。 在一个协程中，调用 co::accept() 接受客户端连接。 有连接到来时，创建一个新的协程，在协程中处理连接上的数据。 on_connection() 是处理连接的协程函数，接收、处理与发送数据，在该协程中以完全同步的方式进行，不需要任何异步回调。 #客户端网络模型 void client_fun() { while (true) { if (!connected) co::connect(...); // connect to the server co::send(.</description>
    </item>
    
    <item>
      <title>联系</title>
      <link>https://coostdocs.github.io/cn/about/contact/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://coostdocs.github.io/cn/about/contact/</guid>
      <description>联系方式
Email: idealvin at qq.com github: https://github.com/idealvin/coost gitee: https://gitee.com/idealvin/coost zhihu: idealvin </description>
    </item>
    
    <item>
      <title>fastream</title>
      <link>https://coostdocs.github.io/cn/co/other/fastream/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://coostdocs.github.io/cn/co/other/fastream/</guid>
      <description>include: co/fastream.h.
#fastream fastream 用于取代 C++ 标准库中的 std::ostringstream。std::ostringstream 性能较差，实测比 snprintf 慢好几倍，fastream 在不同平台测试比 snprintf 快 10~30 倍左右。
#constructor 1. constexpr fastream() noexcept; 2. explicit fastream(size_t cap); 3. fastream(fastream&amp;amp;&amp;amp; s) noexcept; 1, 默认构造函数，创建一个空的 fastream 对象，内部不会分配任何内存。
2, 用参数 cap 指定 fastream 的初始容量，即预分配 cap 字节的内存。
3, 移动构造函数，不会进行内存拷贝。
示例
fastream s; // 空对象, 未分配内存 fastream s(1024); // 预分配 1k 内存 fastream x(std::move(s)); // 移动构造, s 变成空对象 #operator= fastream&amp;amp; operator=(fastream&amp;amp;&amp;amp; s) noexcept; fastream 只支持 move 赋值操作，s 的内容被转移到 fastream 中，s 自身变成空对象。</description>
    </item>
    
    <item>
      <title>使用三方网络库</title>
      <link>https://coostdocs.github.io/cn/co/net/third/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://coostdocs.github.io/cn/co/net/third/</guid>
      <description>#协程中使用三方网络库 在协程中使用三方网络库有两种方式：
直接使用三方网络库的阻塞 API，此方式最简单，依赖于 co 内部的系统 API hook。 使用三方网络库的非阻塞 API，此方式需要借助 co::io_event 将其转换为同步方式。 #系统 API hook 原理 API hook 简单来说就是拦截系统 API 请求，如果该请求是在协程中，且使用 blocking socket，就将 socket 修改成 non-blocking 模式，当 socket 不可读或写时，利用 co::io_event 或 co 中更底层的接口等待 I/O 事件，I/O 事件到来时，再唤醒协程，调用系统原生的 socket API 完成 I/O 操作。
#使用非阻塞 API 下面是基于 openssl 的非阻塞 API 实现的 recv 方法：
int recv(S* s, void* buf, int n, int ms) { CHECK(co::sched()) &amp;lt;&amp;lt; &amp;#34;must be called in coroutine..&amp;#34;; int r, e; int fd = SSL_get_fd((SSL*)s); if (fd &amp;lt; 0) return -1; do { ERR_clear_error(); r = SSL_read((SSL*)s, buf, n); if (r &amp;gt; 0) return r; // success if (r == 0) return 0; e = SSL_get_error((SSL*)s, r); if (e == SSL_ERROR_WANT_READ) { co::io_event ev(fd, co::ev_read); if (!</description>
    </item>
    
    <item>
      <title>同步事件</title>
      <link>https://coostdocs.github.io/cn/co/concurrency/coroutine/event/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://coostdocs.github.io/cn/co/concurrency/coroutine/event/</guid>
      <description>include: co/co.h.
#co::event co::event 是协程间的一种同步机制，它与线程中的 co::sync_event 类似。
从 v2.0.1 版本开始，co::event 可以在协程与非协程中使用。 #constructor 1. explicit event(bool manual_reset=false, bool signaled=false); 2. event(event&amp;amp;&amp;amp; e); 3. event(const event&amp;amp; e); 1, 与线程中的 co::sync_event 类似。 2, 移动构造函数。 3, 拷贝构造函数，仅将内部引用计数加 1。 #reset void reset() const; 将事件重置为未同步状态。 #signal void signal() const; 产生同步信号，将事件设置成同步状态。 所有 waiting 状态的协程或线程会被唤醒。若当前并没有 waiting 状态的协程或线程，则下一个调用 wait() 方法的协程或线程会立即返回。 #wait 1. void wait() const; 2. bool wait(uint32 ms) const; 1, 等待直到事件变成同步状态。 2, 等待直到事件变成同步状态或超时。参数 ms 指定超时时间，单位为毫秒。若事件变成同步状态，返回 true，否则返回 false。 当构造函数中 manual_reset 为 false 时，wait() 结束时会自动将事件设置成未同步状态。 #代码示例 #include &amp;#34;co/co.</description>
    </item>
    
    <item>
      <title>赞助💕</title>
      <link>https://coostdocs.github.io/cn/about/sponsor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://coostdocs.github.io/cn/about/sponsor/</guid>
      <description>#赞助 coost 是个人项目，如果您有意向赞助 coost，可以联系 Alvin(idealvin at qq.com)，我们将会在这里展示您的 logo、网址等信息。非常感谢。
我们也提供面向企业用户的付费服务，企业用户可选择支付 7000￥/年或 5000￥/年，即可享受不同程度的 coost 相关的技术支持与咨询服务。 #咖啡 如果您喜欢 coost，也可以考虑给作者来杯咖啡，非常感谢。</description>
    </item>
    
    <item>
      <title>配置</title>
      <link>https://coostdocs.github.io/cn/co/flag/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://coostdocs.github.io/cn/co/flag/</guid>
      <description>include: co/flag.h.
#基本概念 co.flag 是一个命令行参数及配置文件解析库，其原理很简单，代码中定义全局变量，然后在程序启动时解析命令行参数或配置文件，修改这些全局变量的值。
#flag 变量 co.flag 中的宏定义的全局变量，称为 flag 变量。如下面的代码定义了一个 flag 变量，变量名是 FLG_x。
DEF_int32(x, 0, &amp;#34;xxx&amp;#34;); // int32 FLG_x = 0; co.flag 支持 7 种类型的 flag 变量：
bool, int32, int64, uint32, uint64, double, string 每个 flag 变量都有一个默认值，用户可以通过命令行参数或配置文件修改 flag 变量的值。如前面定义的 FLG_x，在命令行中可以用 -x=23，在配置文件中可以用 x = 23，设置一个新的值。
#command line flag 命令行参数中，以 -x=y 的形式出现，其中 x 被称为一个 command line flag(以下简称为 flag)。命令行中的 flag x 对应代码中的全局变量 FLG_x，命令行中的 -x=y 就相当于将 FLG_x 的值设置为 y。为了方便，下面可能将 flag 与 flag 变量统一称为 flag。</description>
    </item>
    
    <item>
      <title>IO 事件</title>
      <link>https://coostdocs.github.io/cn/co/concurrency/coroutine/io_event/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://coostdocs.github.io/cn/co/concurrency/coroutine/io_event/</guid>
      <description>include: co/co.h.
#co::_ev_t enum _ev_t { ev_read = 1, ev_write = 2, }; I/O 事件类型，ev_read 表示读，ev_write 表示写。 #co::io_event co::io_event 用于将非阻塞 I/O 转换为同步方式。用户在协程中对一个 non-blocking socket 进行 I/O 操作，当 socket 不可读或不可写时，用户调用 co::io_event 的 wait() 方法挂起协程，等待 I/O 事件；当 socket 变为可读或可写时，调度线程唤醒该协程，继续 I/O 操作。
#constructor 1. io_event(sock_t fd, _ev_t ev); 2. io_event(sock_t fd, int n=0); // for windows only 1, 参数 fd 是一个 non-blocking socket，参数 ev 是 ev_read 或 ev_write 中的一种。调用 wait() 方法会在 socket 上等待 ev 指定的 I/O 事件，wait() 成功返回时，需要用户调用 recv, send 等函数完成 I/O 操作。在 windows 平台，fd 必须是 TCP socket(对于 UDP，很难用 IOCP 模拟 epoll 或 kqueue 的行为)。 2, 仅适用于 windows，fd 可以是 UDP socket，但用户需要手动调用 WSARecvFrom, WSASendTo 等函数向 IOCP 发送 overlapped I/O 请求，然后调用 wait() 方法，当 wait() 成功返回时，表示 IOCP 已经帮用户完成了 I/O 操作。具体的用法此处不详述，代码中有详细的注释，建议直接参考 co::io_event 的源码，以及 windows 上 co::accept, co::connect, co::recvfrom, co::sendto 的实现。 #destructor ~io_event(); 析构函数，从 epoll 或 kqueue 中移除之前注册的 I/O 事件。 #wait bool wait(uint32 ms=-1); 此方法等待 socket 上的 I/O 事件，参数 ms 是超时时间，单位为毫秒，默认为 -1，永不超时。 此方法阻塞，直到 I/O 事件到来，或者超时、发生错误。 此方法成功时返回 true，超时或发生错误时返回 false。 #代码示例 int recv(sock_t fd, void* buf, int n, int ms) { const auto sched = xx::gSched; CHECK(sched) &amp;lt;&amp;lt; &amp;#34;must be called in coroutine.</description>
    </item>
    
    <item>
      <title>STL</title>
      <link>https://coostdocs.github.io/cn/co/other/stl/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://coostdocs.github.io/cn/co/other/stl/</guid>
      <description>include: co/stl.h.
#常用容器 下表中，左边 coost 中的容器与右边相应的 std 版本是等价的，仅内部的内存分配器不同。
coost std co::deque std::deque co::list std::list co::map std::map co::set std::set co::multimap std::multimap co::multiset std::multiset co::hash_map std::unordered_map co::hash_set std::unordered_set 当 key 为 const char* 类型(即 C 风格字符串)时，co::map, co::set, co::multimap, co::multiset, co::hash_map, co::hash_set 会根据字符串内容比较 key 及计算 key 的 hash 值。 #co::lru_map template&amp;lt;typename K, typename V&amp;gt; class lru_map; co::lru_map 是基于 LRU (least recently used) 策略实现的 map，当 map 中元素数量达到上限时，优先替换掉最近最少使用的数据。它基于 co::hash_map 与 co::list 实现，内部元素是无序的。
#constructor 1. lru_map(); 2.</description>
    </item>
    
    <item>
      <title>TCP</title>
      <link>https://coostdocs.github.io/cn/co/net/tcp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://coostdocs.github.io/cn/co/net/tcp/</guid>
      <description>include: co/tcp.h.
#tcp::Connection tcp::Connection 类是对 TCP 连接的简单封装，用于实现 TCP server，客户端不需要用这个类。当服务端启用 SSL 时，tcp::Connection 会用 SSL 传输数据。
#Connection::Connection Connection(int sock); Connection(void* ssl); Connection(Connection&amp;amp;&amp;amp; c); 构造函数，Connection 由 tcp::Server 创建，用户不需要手动创建。 第 1 个版本构造一般的 TCP 连接，第 2 个版本构造使用 SSL 传输数据的 TCP 连接，第 3 个是移动构造函数。 从 v2.0.2 开始，用户不能继承 Connection 类。 #Connection::~Connection Connection::~Connection(); 析构函数，调用 close() 关闭连接。 #Connection::close int close(int ms = 0); 关闭连接，参数 ms &amp;gt; 0 时，延迟一段时间再关闭连接。 从 v2.0.1 开始，此方法可以在协程或非协程中调用。 #Connection::recv int recv(void* buf, int n, int ms=-1); 接收数据，与 co::recv 类似。 此方法必须在协程中调用。 此方法成功时返回值 &amp;gt;0，超时或发生错误时返回值 &amp;lt;0，对端关闭连接时返回 0。 #Connection::recvn int recvn(void* buf, int n, int ms=-1); 接收指定长度的数据，与 co::recvn 类似。 此方法成功时返回 n，超时或发生错误时返回值 &amp;lt;0，对端关闭连接时返回 0。 #Connection::reset int reset(int ms = 0) 重置 TCP 连接，与 close() 不同，它不会进入 TIME_WAIT 状态。参数 ms &amp;gt; 0 时，延迟一段时间再重置连接。 此方法必须在 I/O 线程(一般是进行 I/O 操作的协程)中调用。 #Connection::send int send(const void* buf, int n, int ms=-1); 发送数据，与 co::send() 类似。 此方法成功时返回 n，超时或发生错误时返回值 &amp;lt;=0。 #Connection::socket int socket() const; 返回内部的 socket 描述符，连接已关闭时返回 -1。 #Connection::strerror const char* strerror() const; Connection 中的方法报错时，可以调用此方法查看错误信息。 #tcp::Server tcp::Server 是基于协程的 TCP 服务端，它的特性如下：</description>
    </item>
    
    <item>
      <title>日志</title>
      <link>https://coostdocs.github.io/cn/co/log/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://coostdocs.github.io/cn/co/log/</guid>
      <description>include: co/log.h.
#简介 co.log 是 coost 提供的高性能日志库，支持两种类型的日志，level log 与 topic log(TLOG)，它像下面这样打印日志：
LOG &amp;lt;&amp;lt; &amp;#34;hello world&amp;#34; &amp;lt;&amp;lt; 23; // level log TLOG(&amp;#34;topic&amp;#34;) &amp;lt;&amp;lt; &amp;#34;hello&amp;#34; &amp;lt;&amp;lt; 23; // topic log #Level Log Level log 分为 debug, info, warning, error, fatal 5 个级别，并提供一系列的宏，用于打印不同级别的日志。
打印 fatal 级别的日志会终止程序的运行，co.log 还会试图在程序退出前打印函数调用栈信息，以方便排查程序崩溃的原因。 此类型的日志会写入同一个文件中，一般用于打印调试信息。
#Topic Log Topic log(TLOG) 没有级别之分，而是按主题分类。
此类型的日志，按主题写入不同的文件，一般用于打印业务日志，按业务功能划分，便于日志管理。
#性能 co.log 内部采用异步的实现方式，日志先写入缓存，达到一定量或超过一定时间后，由后台线程一次性写入文件，性能在不同平台比 glog 提升了 20~150 倍左右。下表是不同平台单线程连续打印 100 万条(每条 50 字节左右) info 日志的测试结果：
platform glog co.log win2012 HHD 1.6MB/s 180MB/s win10 SSD 3.</description>
    </item>
    
    <item>
      <title>HTTP</title>
      <link>https://coostdocs.github.io/cn/co/net/http/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://coostdocs.github.io/cn/co/net/http/</guid>
      <description>include: co/http.h.
#http::Client http::Client 是基于协程的 http 客户端，它基于 libcurl 实现。
#Client::Client explicit Client(const char* serv_url); 构造函数，参数 serv_url 是服务器的 url 地址，它的形式是 protocol://host:port，下面的 server url 都是合理的： &amp;ldquo;github.com&amp;rdquo; &amp;ldquo;https://github.com&amp;rdquo; &amp;ldquo;http://127.0.0.1:7788&amp;rdquo; &amp;ldquo;http://[::1]:8888&amp;rdquo; http::Client 对象创建时，并不会立即建立连接。 #Client::~Client Client::~Client(); 析构函数，关闭连接，释放 libcurl 相关资源。 #Client::add_header void add_header(const char* key, const char* val); void add_header(const char* key, int val); 添加 HTTP 头部，用户在进行 HTTP 请求前，可以用此方法添加头部，这些头部会自动添加到后续所有请求中。 第 2 个版本中，参数 val 是整数，内部自动转换成字符串。 #Client::body const fastring&amp;amp; body() const; 获取当前 HTTP 请求的响应体。 #Client::close void close(); 关闭 HTTP 连接，一般需要在协程中调用此方法。 调用此方法后，http::Client 对象就不能再用了，直到用户调用 reset() 方法重置 server url。 #Client::del void del(const char* url, const char* s, size_t n); void del(const char* url, const char* s); void del(const char* url); HTTP DELETE 请求，必须在协程中调用。 参数 url 必须是 &#39;/&#39; 开头的字符串。 前两个版本，适用于带 body 部分的 DELETE 请求，参数 s 是 body，n 是 s 的长度，第 2 个版本 s 以 &amp;lsquo;\0&amp;rsquo; 结尾。 第 3 个版本适用于不带 body 的 DELETE 请求。 #Client::easy_handle void* easy_handle() const; 返回 libcurl 的 easy handle。 #Client::get void get(const char* url); HTTP GET 请求，必须在协程中调用。 参数 url 必须是 &#39;/&#39; 开头的字符串。 #Client::head void head(const char* url); HTTP HEAD 请求，必须在协程中调用。 参数 url 必须是 / 开头的字符串。 #Client::header const char* header(const char* key); const fastring&amp;amp; header() const; 第 1 个版本获取当前 HTTP 响应中 header 的值，header 不存在时，返回一个空字符串。</description>
    </item>
    
    <item>
      <title>string utility</title>
      <link>https://coostdocs.github.io/cn/co/other/str/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://coostdocs.github.io/cn/co/other/str/</guid>
      <description>include: co/str.h.
#字符串操作 #str::cat template&amp;lt;typename ...X&amp;gt; inline fastring cat(X&amp;amp;&amp;amp; ...x); v2.0.3 新增，将任意数量的元素连接为一个字符串。
示例
str::cat(&amp;#34;hello&amp;#34;, &amp;#39; &amp;#39;, 23); // -&amp;gt; &amp;#34;hello 23&amp;#34; str::cat(&amp;#34;xx&amp;#34;, 3.14, &amp;#34;true&amp;#34;); // -&amp;gt; &amp;#34;xx3.14true&amp;#34; #str::replace fastring replace(const char* s, size_t n, const char* sub, size_t m, const char* to, size_t l, size_t t=0); fastring replace(const char* s, size_t n, const char* sub, const char* to, size_t t=0); fastring replace(const char* s, const char* sub, const char* to, size_t t=0); fastring replace(const fastring&amp;amp; s, const char* sub, const char* to, size_t t=0); fastring replace(const std::string&amp;amp; s, const char* sub, const char* to, size_t t=0); 将字符串 s 中的子串 sub 替换为 to，n 是 s 的长度，m 是 sub 的长度，l 是 to 的长度；t 是最大替换次数，默认为 0 不限次数。</description>
    </item>
    
    <item>
      <title>互斥锁</title>
      <link>https://coostdocs.github.io/cn/co/concurrency/coroutine/mutex/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://coostdocs.github.io/cn/co/concurrency/coroutine/mutex/</guid>
      <description>include: co/co.h.
#co::mutex 从 v3.0.1 开始，co::mutex 可以在协程与非协程中使用。 #constructor 1. mutex(); 2. mutex(mutex&amp;amp;&amp;amp; m); 3. mutex(const mutex&amp;amp; m); 1, 默认构造函数。 2, 移动构造函数。 3, 拷贝构造函数，仅将内部引用计数加 1。 #lock void lock() const; 获取锁，阻塞直到获得锁为止。 #try_lock bool try_lock() const; 获取锁，不会阻塞，成功获取锁时返回 true，否则返回 false。 #unlock void unlock() const; 释放锁，一般由之前获得锁的协程或线程调用。 #co::mutex_guard #constructor explicit mutex_guard(co::mutex&amp;amp; m); explicit mutex_guard(co::mutex* m); 构造函数，调用 m.lock() 获取锁，参数 m 是 co::mutex 类的引用或指针。 #destructor ~mutex_guard(); 析构函数，释放构造函数中获得的锁。 #代码示例 #include &amp;#34;co/co.h&amp;#34; #include &amp;#34;co/cout.h&amp;#34; co::mutex g_m; int g_v = 0; void f() { co::mutex_guard g(g_m); ++g_v; } int main(int argc, char** argv) { flag::parse(argc, argv); go(f); go(f); f(); f(); co::sleep(100); co::print(&amp;#34;g_v: &amp;#34;, g_v); return 0; } </description>
    </item>
    
    <item>
      <title>单元测试</title>
      <link>https://coostdocs.github.io/cn/co/unitest/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://coostdocs.github.io/cn/co/unitest/</guid>
      <description>include: co/unitest.h.
#基本概念 co.unitest 是一个单元测试框架，与 google gtest 类似，但更简单易用。
#测试单元与测试用例 一个测试程序可以按功能或模块划分为多个测试单元，每个测试单元下面可以有多个测试用例。如可以给 C++ 中的一个类(或模块)定义一个测试单元，类(或模块)中的每个方法定义一个测试用例。
DEF_test(test_name) { DEF_case(a) { // write test code here } DEF_case(b) { // write test code here } } 上面的例子中，DEF_test 定义了一个测试单元(实际上就是定义了一个函数)，DEF_case 则定义了测试用例，一个测试用例就相当于函数内的一个代码块。
#DEF_test #define DEF_test(_name_) \ DEF_bool(_name_, false, &amp;#34;enable this test if true&amp;#34;); \ ... \ void _co_ut_##_name_(unitest::xx::Test&amp;amp; _t_) DEF_test 宏用于定义测试单元，参数 _name_ 是测试单元的名字。 宏的第一行定义了一个 bool 类型的 flag 变量，是该测试单元的开关。如 DEF_test(os) 定义了一个测试单元 os，命令行参数中可以用 -os 指定运行 os 中的测试代码 宏的最后一行定义测试单元对应的函数。 #DEF_case #define DEF_case(name) \ _t_.</description>
    </item>
    
    <item>
      <title>RPC</title>
      <link>https://coostdocs.github.io/cn/co/net/rpc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://coostdocs.github.io/cn/co/net/rpc/</guid>
      <description>include: co/rpc.h.
coost 实现了一个基于协程的 RPC 框架，它内部使用 JSON 格式传输数据，与使用 protobuf 等二进制协议的 RPC 框架相比，它更加灵活，用起来更方便。
从 v3.0 开始，RPC 框架同时也支持 HTTP 协议，可以用 HTTP 的 POST 方法调用 RPC 服务。 #rpc::Service class Service { public: Service() = default; virtual ~Service() = default; typedef std::function&amp;lt;void(Json&amp;amp;, Json&amp;amp;)&amp;gt; Fun; virtual const char* name() const = 0; virtual const co::map&amp;lt;const char*, Fun&amp;gt;&amp;amp; methods() const = 0; }; 接口类，它表示一个 RPC service，一个 RPC server 中可以包含多个 service。 方法 name() 返回 service 名，methods() 返回所有的 RPC 接口及其业务处理函数。 用户不需要关心此类。 #rpc::Server #Server::Server Server(); 默认构造函数，用户不需要关心。 #Server::add_service 1.</description>
    </item>
    
    <item>
      <title>wait group</title>
      <link>https://coostdocs.github.io/cn/co/concurrency/coroutine/wg/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://coostdocs.github.io/cn/co/concurrency/coroutine/wg/</guid>
      <description>include: co/co.h.
#co::wait_group co::wait_group 类似于 golang 中的 sync.WaitGroup，可用于等待协程或线程的退出。
#constructor 1. explicit wait_group(uint32 n); 2. wait_group(); 3. wait_group(wait_group&amp;amp;&amp;amp; wg); 4. wait_group(const wait_group&amp;amp; wg); 1, 将内部计数器初始化为 n。 2, 默认构造函数，将内部计数器初始化为 0。 3, 移动构造函数。 4, 拷贝构造函数，仅将内部引用计数加 1。 #add void add(uint32 n=1) const; 将内部计数器加 n，n 默认为 1。 #done void done() const; 将内部计数器减 1。 #wait void wait() const; 等待直到内部计数器的值变为 0。 #代码示例 #include &amp;#34;co/co.h&amp;#34; #include &amp;#34;co/cout.h&amp;#34; DEF_uint32(n, 8, &amp;#34;coroutine number&amp;#34;); int main(int argc, char** argv) { flag::parse(argc, argv); co::wait_group wg; wg.</description>
    </item>
    
    <item>
      <title>基准测试</title>
      <link>https://coostdocs.github.io/cn/co/benchmark/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://coostdocs.github.io/cn/co/benchmark/</guid>
      <description>include: co/benchmark.h.
#基本概念 co.benchmark 是 v3.0.1 新增的基准测试框架，可用于性能基准测试。
#BM_group #define BM_group(_name_) \ ...... \ void _co_bm_group_##_name_(bm::xx::Group&amp;amp; _g_) BM_group 宏用于定义基准测试组，实际上定义了一个函数。 每个 group 内可以用 BM_add 定义多条基准测试。 参数 _name_ 是组名，也是所定义函数名的一部分，如 BM_group(atomic) 是合理的，而 BM_group(co.atomic) 则是不允许的。 #BM_add #define BM_add(_name_) \ _g_.bm = #_name_; \ _BM_add BM_add 宏用于定义基准测试，它必须在 BM_group 定义的函数内使用。 参数 _name_ 是基准测试名，与 BM_group 不同，BM_add(co.atomic) 也是允许的。 #BM_use #define BM_use(v) bm::xx::use(&amp;amp;v, sizeof(v)) BM_use 宏告诉编译器变量 v 会被使用，防止编译器将一些测试代码优化掉。 #编写基准测试代码 #测试代码示例 #include &amp;#34;co/benchmark.h&amp;#34; #include &amp;#34;co/mem.h&amp;#34; BM_group(malloc) { void* p; BM_add(::malloc)( p = ::malloc(32); ); BM_use(p); BM_add(co::alloc)( p = co::alloc(32); ); BM_use(p); } int main(int argc, char** argv) { flag::parse(argc, argv); bm::run_benchmarks(); return 0; } 上面的代码定义了一个名为 malloc 的基准测试组，组内用 BM_add 添加了 2 个基准测试。 调用 bm::run_benchmarks()，会执行所有的基准测试代码。 上例中，若无 BM_use(p)，编译器可能认为 p 是未使用的变量，将相关的测试代码优化掉，导致无法测出准确的结果。 #测试结果示例 基准测试结果输出为 markdown 表格，可以轻松将测试结果复制到 markdown 文档中。 多个 BM_group 会生成多个 markdown 表格。 表格第 1 列是 group 内的所有基准测试，第 2 列是单次迭代用时(单位为纳秒)，第 3 列是每秒迭代次数，第 4 列是性能提升倍数，以第一个基准测试为基准。 </description>
    </item>
    
    <item>
      <title>随机值</title>
      <link>https://coostdocs.github.io/cn/co/other/rand/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://coostdocs.github.io/cn/co/other/rand/</guid>
      <description>include: co/rand.h.
#随机数(co::rand) 1. uint32 rand(); 2. uint32 rand(uint32&amp;amp; seed); 1, 返回一个 1 到 2G-2 之间的随机数，线程安全。 2, 返回一个 1 到 2G-2 之间的随机数，需要用户指定种子数 seed，种子数必须在 1 到 2G-2 之间，此函数会更新 seed 的值，非线程安全。 可以用 1 中的返回值初始化 2 中的种子数。 示例 uint32 x = co::rand(); uint32 y = co::rand(); uint32 seed = co::rand(); uint32 u = co::rand(seed); uint32 v = co::rand(seed); #随机字符串(co::randstr) 1. fastring randstr(int n=15); 2. fastring randstr(const char* s, int n); 1, 返回一个长度为 n(默认为15) 的随机字符串，线程安全。 2, 返回一个长度为 n、由字符串 s 中的字符构成的随机字符串，s 中可以使用类似 0-9, a-z 的缩写，s 展开后的长度不能超过 255，线程安全。 randstr 基于 nanoid 算法实现，返回的随机字符串足够长时，一般也可以用作唯一 id。 示例 fastring s = co::randstr(); s = co::randstr(8); s = co::randstr(&amp;#34;0123456789&amp;#34;, 6); s = co::randstr(&amp;#34;0-9a-f&amp;#34;, 8); // 长度为8的16进制字符串 </description>
    </item>
    
    <item>
      <title>Hash</title>
      <link>https://coostdocs.github.io/cn/co/other/hash/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://coostdocs.github.io/cn/co/other/hash/</guid>
      <description>include: co/hash.h.
#Hash #hash32 uint32 hash32(const void* s, size_t n); uint32 hash32(const char* s); uint32 hash32(const fastring&amp;amp; s) uint32 hash32(const std::string&amp;amp; s); 此函数返回 32 位的 murmur hash 值。 s 为指针时，一般要求是 sizeof(void*) 字节对齐的。 #hash64 uint64 hash64(const void* s, size_t n); uint64 hash64(const char* s); uint64 hash64(const fastring&amp;amp; s); uint64 hash64(const std::string&amp;amp; s); 此函数返回 64 位的 murmur hash 值。 s 为指针时，一般要求是 8 字节对齐的。 #murmur_hash size_t murmur_hash(const void* s, size_t n); 此函数返回 size_t 类型的 hash 值，这个值在 64 位平台是 64 位的，在 32 位平台是 32 位的。 参数 s 一般要求是 sizeof(void*) 字节对齐的。 #md5 #md5digest void md5digest(const void* s, size_t n, char res[16]); fastring md5digest(const void* s, size_t n); fastring md5digest(const char* s); fastring md5digest(const fastring&amp;amp; s); fastring md5digest(const std::string&amp;amp; s); 计算字符串的 md5 值，结果为 16 字节的二进制字符串。 #md5sum void md5sum(const void* s, size_t n, char res[32]); fastring md5sum(const void* s, size_t n); fastring md5sum(const char* s); fastring md5sum(const fastring&amp;amp; s); fastring md5sum(const std::string&amp;amp; s); 计算字符串的 md5 值，结果为 32 字节、仅含十六进制字符(0-9,a-f)的字符串。 #Lower level APIs void md5_init(md5_ctx_t* ctx); void md5_update(md5_ctx_t* ctx, const void* s, size_t n); void md5_final(md5_ctx_t* ctx, uint8 res[16]); 上述 3 个 API 可用于增量计算 md5。</description>
    </item>
    
    <item>
      <title>JSON</title>
      <link>https://coostdocs.github.io/cn/co/json/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://coostdocs.github.io/cn/co/json/</guid>
      <description>include: co/json.h.
co.json 是一个类似 rapidjson 的 JSON 库，与 rapidjson 相比，它既有性能上的优势，同时又更简单易用。
#基本概念 JSON 是一种简单的数据格式，它支持两种数据结构：
由一系列 key/value 键值对构成的集合，这类结构称为 object，对应编程语言中的 struct, map 等等。 由一系列 value 构成的列表，这类结构称为 array，对应编程语言中的 vector, list 等等。 上述 key 是 string，value 一般也称为 JSON value (co.json 中用 Json 类表示)，可以是 object, array, number, string, bool(false, true), null 中的任意一种。number 是整数或浮点数，大部分实现会将整数与浮点数区分开。
object 由一对大括号括起来，array 由一对中括号括起来，它们看起来像下面这样：
{&amp;#34;a&amp;#34;:1, &amp;#34;b&amp;#34;:false, &amp;#34;s&amp;#34;:&amp;#34;xxx&amp;#34;} [1, 2, 3] 由定义 object 与 array 可以嵌套，从而可以表示树等复杂数据结构。
#Json #Json::Json 1. Json() noexcept; 2. Json(decltype(nullptr)) noexcept; 3. Json(Json&amp;amp;&amp;amp; v) noexcept; 4.</description>
    </item>
    
    <item>
      <title>协程池</title>
      <link>https://coostdocs.github.io/cn/co/concurrency/coroutine/pool/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://coostdocs.github.io/cn/co/concurrency/coroutine/pool/</guid>
      <description>include: co/co.h.
#co::pool co::pool 是一种通用的协程池，它是协程安全的，内部存储 void* 类型的指针，可以用作连接池、内存池或其他用途的缓存。
#constructor 1. pool(); 2. pool(pool&amp;amp;&amp;amp; p); 3. pool(const pool&amp;amp; p); 4. pool(std::function&amp;lt;void*()&amp;gt;&amp;amp;&amp;amp; ccb, std::function&amp;lt;void(void*)&amp;gt;&amp;amp;&amp;amp; dcb, size_t cap=(size_t)-1); 1, 默认构造函数，与 4 相比，ccb 与 dcb 为 NULL。
2, 移动构造函数。
3, 拷贝构造函数，仅将内部引用计数加 1。
4, 参数 ccb 用于创建元素，参数 dcb 用于销毁元素，参数 cap 指定 pool 的最大容量，默认为 -1，不限容量。
注意参数 cap 并不是总容量，它是对单个线程而言，在 co::pool 内部实现中，每个线程都有自己的 pool，如 cap 设置为 1024，调度线程有 8 个，则总容量是 8192。
当 dcb 为 NULL 时，参数 cap 会被忽略，这是因为当元素个数超过最大容量时，co::pool 需要用 dcb 销毁多余的元素。</description>
    </item>
    
    <item>
      <title>时间</title>
      <link>https://coostdocs.github.io/cn/co/other/time/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://coostdocs.github.io/cn/co/other/time/</guid>
      <description>include: co/time.h.
#epoch time epoch 是一个特定的时刻 1970-01-01 00:00:00 UTC，epoch time 是从 epoch 时刻开始的时间，它受系统时间影响。
#epoch::ms int64 ms(); 返回自 epoch 到当前时刻的时间，单位为毫秒。 #epoch::us int64 us(); 返回自 epoch 到当前时刻的时间，单位为微秒。 #monotonic time monotonic time 是单调递增时间，大多数平台实现为自系统启动开始的时间，一般用于计时，比系统时间稳定，不受系统时间的影响。
#now::ms int64 ms(); 返回一个单调递增的时间戳，单位为毫秒。 在 mac 平台，如果系统不支持 CLOCK_MONOTONIC，则使用 epoch::ms()。 #now::us int64 us(); 返回一个单调递增的时间戳，单位为微秒。
在 mac 平台，如果系统不支持 CLOCK_MONOTONIC，则使用 epoch::us()。
示例
int64 beg = now::us(); int64 end = now::us(); LOG &amp;lt;&amp;lt; &amp;#34;time used: &amp;#34; &amp;lt;&amp;lt; (end - beg) &amp;lt;&amp;lt; &amp;#34; us&amp;#34;; #时间字符串(now::str) // fm: 时间输出格式 fastring str(const char* fm=&amp;#34;%Y-%m-%d %H:%M:%S&amp;#34;); 此函数以指定格式返回当前系统时间的字符串形式，它基于 strftime 实现。</description>
    </item>
    
    <item>
      <title>配置项</title>
      <link>https://coostdocs.github.io/cn/co/concurrency/coroutine/conf/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://coostdocs.github.io/cn/co/concurrency/coroutine/conf/</guid>
      <description>#配置 Coost 使用 co.flag 定义了协程相关的配置项，配置详细用法请参考 co.flag 文档。
#co_hook_log DEF_bool(co_hook_log, false, &amp;#34;&amp;gt;&amp;gt;#1 print log for API hooks&amp;#34;); 打印 API hook 相关的日志，默认为 false。 v3.0.1 中将配置项 hook_log 重命名为 co_hook_log。 #co_sched_log DEF_bool(co_sched_log, false, &amp;#34;&amp;gt;&amp;gt;#1 print logs for coroutine schedulers&amp;#34;); 打印协程调度相关的调试日志，默认为 false。 v3.0.1 将配置项 co_debug_log 重命名为 co_sched_log。 #co_sched_num DEF_uint32(co_sched_num, os::cpunum(), &amp;#34;&amp;gt;&amp;gt;#1 number of coroutine schedulers&amp;#34;); 协程调度线程的数量，默认为系统 CPU 核数。目前的实现中，这个值最大也是系统 CPU 核数。 #co_stack_num DEF_uint32(co_stack_num, 8, &amp;#34;&amp;gt;&amp;gt;#1 number of stacks per scheduler, must be power of 2&amp;#34;); v3.0.1 新增，每个协程调度器的共享协程栈数量，该值必须是 2 的幂，默认为 8。 #co_stack_size DEF_uint32(co_stack_size, 1024 * 1024, &amp;#34;&amp;gt;&amp;gt;#1 size of the stack shared by coroutines&amp;#34;); 协程栈大小，默认为 1M。 </description>
    </item>
    
    <item>
      <title>定时任务</title>
      <link>https://coostdocs.github.io/cn/co/other/tasked/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://coostdocs.github.io/cn/co/other/tasked/</guid>
      <description>include: co/tasked.h.
#co::Tasked Tasked 类是一个简单的定时任务调度器，内部由单线程调度所有任务，但可以从任意线程添加任务。Tasked 中的任务阻塞时，会影响后面的所有任务，因此不推荐用 Tasked 调度可能会长时间阻塞的任务。
v3.0.1 将 Tasked 类加入 namespace co 中。 #constructor 1. Tasked(); 2. Tasked(Tasked&amp;amp;&amp;amp; t); 1, 默认构造函数，对象创建完，调度线程即开始运行。 2, 移动构造函数，支持将 Tasked 对象放到 STL 容器中。 #destructor ~Tasked(); 析构函数，退出任务调度线程。 #F typedef std::function&amp;lt;void()&amp;gt; F; 任务类型，固定为 std::function&amp;lt;void()&amp;gt; 类型的函数。 #run_at void run_at(F&amp;amp;&amp;amp; f, int hour, int minute=0, int second=0); void run_at(const F&amp;amp; f, int hour, int minute=0, int second=0); 添加指定时刻运行的任务，f 将在 hour:minute:second 时刻运行一次。 hour 必须是 0-23 之间的整数，minute 与 second 必须是 0-59 之间的整数，默认为 0。 #run_daily void run_daily(F&amp;amp;&amp;amp; f, int hour=0, int minute=0, int second=0); void run_daily(const F&amp;amp; f, int hour=0, int minute=0, int second=0); 添加每天指定时刻运行的周期性任务，f 将在每天的 hour:minute:second 时刻运行一次。 hour 必须是 0-23 之间的整数，默认为 0，minute 与 second 是 0-59 之间的整数，默认为 0。 #run_every void run_every(F&amp;amp;&amp;amp; f, int n); void run_every(const F&amp;amp; f, int n); 添加每 n 秒运行一次的周期性任务。 #run_in void run_in(F&amp;amp;&amp;amp; f, int n); void run_in(const F&amp;amp; f, int n); 添加 n 秒后运行一次的任务。 #stop void stop(); 退出任务调度线程，析构函数中会自动调用此方法。 多次调用此方法是安全的。 #代码示例 co::Tasked s; // create and start the scheduler s.</description>
    </item>
    
    <item>
      <title>文件路径(path)</title>
      <link>https://coostdocs.github.io/cn/co/other/path/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://coostdocs.github.io/cn/co/other/path/</guid>
      <description>include: co/path.h.
#path 此部分功能移植于 golang，路径分隔符必须为 /。
#path::clean fastring clean(const char* s, size_t n); fastring clean(const char* s); fastring clean(const fastring&amp;amp; s); 返回路径的最短等价形式，路径中连续的分隔符会被清除掉。
示例
path::clean(&amp;#34;&amp;#34;); // &amp;#34;.&amp;#34; path::clean(&amp;#34;./x//y/&amp;#34;); // &amp;#34;x/y&amp;#34; path::clean(&amp;#34;./x/..&amp;#34;); // &amp;#34;.&amp;#34; path::clean(&amp;#34;./x/../..&amp;#34;); // &amp;#34;..&amp;#34; #path::join template&amp;lt;typename ...S&amp;gt; inline fastring join(S&amp;amp;&amp;amp;... s); 将任意数量的字符串拼接成一个完整的路径，返回 path::clean 处理后的结果。
参数中的空字符串将会被忽略。
示例
path::join(&amp;#34;&amp;#34;, &amp;#34;&amp;#34;); // &amp;#34;&amp;#34; path::join(&amp;#34;x&amp;#34;, &amp;#34;y&amp;#34;, &amp;#34;z&amp;#34;); // &amp;#34;x/y/z&amp;#34; path::join(&amp;#34;/x/&amp;#34;, &amp;#34;y&amp;#34;); // &amp;#34;/x/y&amp;#34; #path::split std::pair&amp;lt;fastring, fastring&amp;gt; split(const char* s, size_t n); std::pair&amp;lt;fastring, fastring&amp;gt; split(const char* s); std::pair&amp;lt;fastring, fastring&amp;gt; split(const fastring&amp;amp; s); 将路径切分为 dir, file 两部分，若路径中不含分隔符，则 dir 部分为空。</description>
    </item>
    
    <item>
      <title>文件系统</title>
      <link>https://coostdocs.github.io/cn/co/other/fs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://coostdocs.github.io/cn/co/other/fs/</guid>
      <description>include: co/fs.h.
fs 模块最小限度的实现了常用的文件系统操作，不同平台路径分隔符建议统一使用 /。
#元数据操作 #fs::exists bool exists(const char* path); bool exists(const fastring&amp;amp; path); bool exists(const std::string&amp;amp; path); 判断文件是否存在，参数 path 是文件或目录路径。 #fs::fsize int64 fsize(const char* path); int64 fsize(const fastring&amp;amp; path); int64 fsize(const std::string&amp;amp; path); 获取文件大小，文件不存在或其他错误返回 -1。 #fs::isdir bool isdir(const char* path); bool isdir(const fastring&amp;amp; path); bool isdir(const std::string&amp;amp; path); 判断文件是否是目录，若 path 存在且是目录，则返回 true，否则返回 false。 #fs::mtime int64 mtime(const char* path); int64 mtime(const fastring&amp;amp; path); int64 mtime(const std::string&amp;amp; path); 获取文件的修改时间，文件不存在时返回 -1。 #fs::mkdir bool mkdir(const char* path, bool p=false); bool mkdir(const fastring&amp;amp; path, bool p=false); bool mkdir(const std::string&amp;amp; path, bool p=false); 创建目录，参数 path 是目录路径，参数 p 表示是否创建整个路径。 参数 p 默认为 false，仅当父目录存在时，才会创建目录；参数 p 为 true 时，相当于 mkdir -p ，父目录不存在时，先创建父目录。 #fs::remove bool remove(const char* path, bool rf=false); bool remove(const fastring&amp;amp; path, bool rf=false); bool remove(const std::string&amp;amp; path, bool rf=false); 删除文件或目录，参数 path 是路径。 path 是目录时，参数 rf 表示是否强制删除，默认为 false，仅删除空目录。若 rf 为 true，则相当于 rm -rf，非空目录也会被删除。 path 是文件时，参数 rf 会被忽略。 #fs::rename bool rename(const char* from, const char* to); bool rename(const fastring&amp;amp; from, const fastring&amp;amp; to); bool rename(const std::string&amp;amp; from, const std::string&amp;amp; to); 重命名文件或目录，参数 from 是原路径，参数 to 是新路径。 参数 to 是目录时，windows 要求 to 和 from 在同一个盘符(drive) 下面。 详情可以参考 win32/MoveFile, linux/rename。 #fs::symlink bool symlink(const char* dst, const char* lnk); bool symlink(const fastring&amp;amp; dst, const fastring&amp;amp; lnk); bool symlink(const std::string&amp;amp; dst, const std::string&amp;amp; lnk); 创建软链接，参数 dst 是目标文件或目录的路径，参数 lnk 是软链接的路径。 此函数先调用 fs::remove(lnk) 删除旧的软链接，再创建新的软链接文件。 在 windows 平台，此函数需要 admin 权限。 #代码示例 bool x = fs::exists(path); // 判断文件是否存在 bool x = fs::isdir(path); // 判断文件是否为目录 int64 x = fs::mtime(path); // 获取文件的修改时间 int64 x = fs::fsize(path); // 获取文件的大小 fs::mkdir(&amp;#34;a/b&amp;#34;); // mkdir a/b fs::mkdir(&amp;#34;a/b&amp;#34;, true); // mkdir -p a/b fs::remove(&amp;#34;x/x.</description>
    </item>
    
    <item>
      <title>操作系统</title>
      <link>https://coostdocs.github.io/cn/co/other/os/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://coostdocs.github.io/cn/co/other/os/</guid>
      <description>include: co/os.h.
#os #os::cpunum int cpunum(); 返回系统 CPU 核数。 #os::cwd fastring cwd(); 返回当前工作目录。 在 windows 平台，返回值中的 \ 会转换成 /。 #os::daemon void daemon(); 将当前进程放到后台运行，仅支持 linux 平台。 #os::env 1. fastring env(const char* name); 2. bool env(const char* name, const char* value); 1, 获取系统环境变量的值，参数 name 是环境变量名。 2, v2.0.2 新增，设置环境变量的值，成功时返回 true，否则返回 false。 #os::exename fastring exename(); 返回当前进程名，不含路径。 #os::exepath fastring exepath(); 返回当前进程的完整路径。 在 windows 平台，返回值中的 \ 会转换成 /。 #os::homedir fastring homedir(); 返回当前用户的 home 目录。 在 windows 平台，返回值中的 \ 会转换成 /。 #os::pid int pid(); 返回当前进程的 id。 #os::signal typedef void (*sig_handler_t)(int); sig_handler_t signal(int sig, sig_handler_t handler, int flag=0); 设置信号处理函数，参数 sig 是信号值，参数 flag 是 SA_RESTART，SA_ONSTACK 等选项的组合。</description>
    </item>
    
    <item>
      <title>编译</title>
      <link>https://coostdocs.github.io/cn/co/build/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://coostdocs.github.io/cn/co/build/</guid>
      <description>#编译器要求 各平台需要安装的编译器如下：
Linux: gcc 4.8+ Mac: clang 3.3+ Windows: vs2015+ #xmake co 推荐使用 xmake 作为构建工具。
#安装 xmake windows, mac 与 debian/ubuntu 可以直接去 xmake 的 release 页面下载安装包，其他系统请参考 xmake 的 Installation 说明。
#快速构建 在 co 根目录执行下述命令构建：
xmake -a # 构建所有项目 (libco, gen, test, unitest) 若需要使用 HTTP 或 SSL 特性，则可以用下面的命令构建：
xmake f --with_libcurl=true --with_openssl=true xmake -a 启用 HTTP 或 SSL 特性时，xmake 会自动从网络安装 libcurl 与 openssl，可能需要花点时间。
命令行中的 -a 表示构建 co 中的所有项目，如果不加 -a，默认只会构建 libco。另外，可以用 -v 或 -vD 让 xmake 打印更详细的编译信息：</description>
    </item>
    
  </channel>
</rss>
